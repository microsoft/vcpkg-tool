{
  "ABaseline": "базовый уровень",
  "ABaselineObject": "базовый объект",
  "ABoolean": "логическое значение",
  "ABuiltinRegistry": "встроенный реестр",
  "AConfigurationObject": "объект конфигурации",
  "ACpuArchitecture": "архитектура ЦП",
  "ADateVersionString": "строка версии даты",
  "ADefaultFeature": "компонент по умолчанию",
  "ADemandObject": "объект требования",
  "ADependency": "зависимость",
  "ADependencyFeature": "компонент зависимости",
  "ADictionaryOfContacts": "словарь контактов",
  "AFeature": "компонент",
  "AFeatureName": "имя компонента",
  "AFilesystemRegistry": "реестр файловой системы",
  "AGitObjectSha": "SHA объекта Git",
  "AGitReference": "ссылка Git (например, ветвь)",
  "AGitRegistry": "реестр Git",
  "AGitRepositoryUrl": "URL-адрес репозитория Git",
  "AManifest": "манифест",
  "AMaximumOfOneAssetReadUrlCanBeSpecified": "можно указать не более одного URL-адреса для чтения ресурса.",
  "AMaximumOfOneAssetWriteUrlCanBeSpecified": "можно указать не более одного URL-адреса для записи ресурса.",
  "ANonNegativeInteger": "неотрицательное целое число",
  "APackageName": "имя пакета",
  "APackagePattern": "шаблон пакета",
  "APackagePatternArray": "массив шаблонов пакета",
  "APath": "путь",
  "APlatformExpression": "выражение платформы",
  "ARegistry": "реестр",
  "ARegistryImplementationKind": "тип реализация реестра",
  "ARegistryPath": "путь реестра",
  "ARegistryPathMustBeDelimitedWithForwardSlashes": "Путь к реестру должен использовать одиночную косую черту в качестве разделителей пути.",
  "ARegistryPathMustNotHaveDots": "Путь к реестру не должен содержать элементы пути \"dot\" или \"dot dot\".",
  "ARegistryPathMustStartWithDollar": "Путь к реестру должен начинаться с \"$\", что указывает на корневой каталог реестра. Например, \"$/foo/bar\".",
  "ARelaxedVersionString": "строка нестрогой версии",
  "ASemanticVersionString": "строка семантической версии",
  "ASetOfFeatures": "набор функций",
  "ASha512": "хэш SHA-512",
  "AString": "строка",
  "AStringOrArrayOfStrings": "строка или массив строк",
  "AStringStringDictionary": "\"string\": словарь \"string\"",
  "AToolDataArray": "массив метаданных инструмента",
  "AToolDataFile": "файл данных инструмента",
  "AToolDataOS": "операционная система данных инструмента",
  "AToolDataObject": "метаданные инструмента",
  "AToolDataVersion": "версия данных инструмента",
  "AUrl": "URL-адрес",
  "AVcpkgRepositoryCommit": "фиксация репозитория vcpkg",
  "AVersionConstraint": "ограничение версии",
  "AVersionDatabaseEntry": "запись базы данных версии",
  "AVersionObject": "объект версии",
  "AVersionOfAnyType": "версия любого типа",
  "AddArtifactOnlyOne": "\"{command_line}\" может добавлять только один артефакт за раз.",
  "AddCommandFirstArg": "Первым добавляемым параметром должен быть \"артефакт\" или \"порт\".",
  "AddPortRequiresManifest": "\"{command_line}\" требуется активный файл манифеста.",
  "AddPortSucceeded": "Порты успешно добавлены в файл vcpkg.json.",
  "AddRecurseOption": "Если вы действительно хотите удалить их, выполните команду с параметром --recurse.",
  "AddTripletExpressionNotAllowed": "тройные выражения здесь не допускаются. Вы можете изменить `{package_name}:{triplet}` на `{package_name}`.",
  "AddVersionAddedVersionToFile": "добавлена версия {version} в {path}",
  "AddVersionArtifactsOnly": "--version содержит только артефакты и не может использоваться с портом добавления vcpkg",
  "AddVersionCommitChangesReminder": "Вы не забыли зафиксировать изменения?",
  "AddVersionFileNotFound": "не удалось найти необходимый файл {path}",
  "AddVersionFormatPortSuggestion": "Выполните \"{command_line}\", чтобы форматировать файл",
  "AddVersionIgnoringOptionAll": "пропуск --{option}, так как указан аргумент имени порта",
  "AddVersionInstructions": "для автоматического добавления текущей версии {package_name} можно выполнить следующие команды:",
  "AddVersionNewFile": "(новый файл)",
  "AddVersionNewShaIs": "новый SHA: {commit_sha}",
  "AddVersionNoFilesUpdated": "Файлы не были обновлены",
  "AddVersionNoFilesUpdatedForPort": "Для {package_name} файлы не были обновлены",
  "AddVersionOldShaIs": "старый SHA: {commit_sha}",
  "AddVersionOverwriteOptionSuggestion": "Чтобы обойти эту проверку, используйте --{option}",
  "AddVersionPortFilesShaChanged": "зарегистрированные файлы для {package_name} изменились, но версия не обновлена",
  "AddVersionPortFilesShaUnchanged": "зарегистрированные файлы для {package_name} не изменялись с версии {version}",
  "AddVersionPortHasImproperFormat": "Неверный формат {package_name}",
  "AddVersionPortVersionShouldBeGone": "В {package_name} {version} — это совершенно новая версия, поэтому параметр \"port-version\" должен отсутствовать. Удалите \"port-version\" и попробуйте снова. Чтобы пропустить эту проверку, запустите ее повторно с параметром --skip-version-format-check.",
  "AddVersionPortVersionShouldBeOneMore": "В {package_name} текущий параметр \"port-version\" для {version} — {count}, поэтому ожидаемый новый параметр \"port-version\" — {expected_version}, но порт объявляет \"port-version\" {actual_version}. Измените \"port-version\" на {expected_version} и повторите попытку. Чтобы пропустить эту проверку, запустите ее повторно с параметром --skip-version-format-check.",
  "AddVersionSuggestVersionDate": "В формате версии \"{package_name}\" используется \"version-string\", но формат допустим в виде \"version-date\". Если этот формат на самом деле должен быть датой ISO 8601, измените формат на \"version-date\" и выполните эту команду повторно. В противном случае отключите эту проверку, выполнив команду повторно и добавив --skip-version-format-check.",
  "AddVersionSuggestVersionRelaxed": "В формате версии \"{package_name}\" используется \"version-string\", но формат допустим в виде \"version\". Если версии для этого порта можно упорядочить с помощью правил с нестрогой версией, измените формат на \"version\" и выполните эту команду повторно. Правила с нестрогой версией упорядочивают версии по каждому числовому компоненту. Затем версии с пунктирными суффиксами сортируются лексикографически в начале. Теги сборок с плюсами игнорируются. Примеры:\n1.0 < 1.1-alpha < 1.1-b < 1.1 < 1.1.1 < 1.2+build = 1.2 < 2.0\nОбратите внимание, что пунктирные суффиксы сортируются *в начале*, а не в конце. 1.0-anything < 1.0\nОбратите внимание, что этот порядок сортировки совпадает с выбранным в Семантическом версионировании (см. страницу https://semver.org), хотя фактически семантические части не применяются.\nЕсли версии для этого порта не упорядочиваются этими правилами, отключите эту проверку, повторно выполнив эту команду и добавив параметр --skip-version-format-check.",
  "AddVersionUpdateVersionReminder": "Вы не забыли обновить версию или версию порта?",
  "AddVersionUseOptionAll": "Чтобы одновременно обновить все версии портов, для {command_name} без аргументов требуется передача параметра --{option}",
  "AddVersionVersionAlreadyInFile": "версия {version} уже находится в {path}",
  "AddVersionVersionIs": "версия: {version}",
  "AddingCompletionEntry": "Добавление записи завершения vcpkg в {path}.",
  "AdditionalPackagesToExport": "Для завершения этой операции необходимо экспортировать дополнительные пакеты.",
  "AdditionalPackagesToRemove": "Требуется удалить дополнительные пакеты (*) для завершения этой операции.",
  "AllFeatureTestsPassed": "Все тесты функций пройдены.",
  "AllFormatArgsRawArgument": "строка формата \"{value}\" содержит необработанный аргумент формата",
  "AllFormatArgsUnbalancedBraces": "несбалансированная фигурная скобка в строке формата \"{value}\"",
  "AllPackagesAreUpdated": "Никакие действия не выполнены, так как для всех пакетов установлены новейшие версии.",
  "AllShasValid": "Все проверенные sha действительны.",
  "AlreadyInstalled": "Уже установлено: {spec}",
  "AmbiguousConfig": "Неоднозначная конфигурация vcpkg, указанная как в манифесте, так и в файле конфигурации. Выберите один из них, удалив этот файл или удалив \"{json_field}\" из файла манифеста.",
  "AnArrayOfDefaultFeatures": "массив компонентов по умолчанию",
  "AnArrayOfDependencies": "массив зависимостей",
  "AnArrayOfDependencyOverrides": "массив переопределений зависимостей",
  "AnArrayOfFeatures": "массив функций",
  "AnArrayOfIdentifers": "массив идентификаторов",
  "AnArrayOfOverlayPaths": "массив путей наложения",
  "AnArrayOfOverlayTripletsPaths": "массив тройных путей наложения",
  "AnArrayOfRegistries": "массив реестров",
  "AnArrayOfVersions": "массив версий",
  "AnArtifactsGitRegistryUrl": "URL-адрес реестра Git артефактов",
  "AnArtifactsRegistry": "реестр артефактов",
  "AnExactVersionString": "строка точной версии",
  "AnIdentifer": "идентификатор",
  "AnObjectContainingVcpkgArtifactsMetadata": "объект, содержащий метаданные vcpkg-artifacts",
  "AnOverlayPath": "путь наложения",
  "AnOverlayTripletsPath": "тройной путь",
  "AnOverride": "переопределение",
  "AnSpdxLicenseExpression": "выражение лицензии SPDX",
  "AnotherInstallationInProgress": "На машине выполняется другая установка, которая находится в спящем режиме в течение 6 секунд, прежде чем повторить попытку.",
  "AppliedUserIntegration": "Применена общепользовательская интеграция для этого корня vcpkg.",
  "ApplocalProcessing": "развертывание зависимостей",
  "ArtifactsBootstrapFailed": "vcpkg-артефакты не установлены и не могут использоваться для начальной загрузки.",
  "ArtifactsOptionIncompatibility": "--{option} не влияет на поиск артефакта.",
  "ArtifactsOptionJson": "Полный путь к файлу JSON, в котором записаны переменные среды и другие свойства",
  "ArtifactsOptionMSBuildProps": "Полный путь к файлу, в который будут записаны свойства MSBuild",
  "ArtifactsOptionVersion": "Версия или диапазон версий для сопоставления; допустимо только для артефактов",
  "ArtifactsOptionVersionMismatch": "Число переключателей --version должно соответствовать числу именованных артефактов",
  "ArtifactsSwitchARM": "Принудительно обнаруживает узел для ARM при получении артефактов",
  "ArtifactsSwitchARM64": "Принудительно обнаруживает узел на ARM64 при получении артефактов",
  "ArtifactsSwitchAllLanguages": "Получает все языковые файлы при получении артефактов",
  "ArtifactsSwitchForce": "Принудительно запускает повторное получение, если артефакт уже получен",
  "ArtifactsSwitchFreebsd": "Принудительно обнаруживает узел для FreeBSD при получении артефактов",
  "ArtifactsSwitchLinux": "Принудительно обнаруживает узел в Linux при получении артефактов",
  "ArtifactsSwitchOnlyOneHostPlatform": "Можно установить только одну платформу узла (--x64, --x86, --arm, --arm64).",
  "ArtifactsSwitchOnlyOneOperatingSystem": "Можно установить только одну операционную систему (--windows, --osx, --linux, --freebsd).",
  "ArtifactsSwitchOnlyOneTargetPlatform": "Можно установить только одну целевую платформу (--target:x64, --target:x86, --target:arm, --target:arm64).",
  "ArtifactsSwitchOsx": "Принудительно обнаруживает узел в MacOS при получении артефактов",
  "ArtifactsSwitchTargetARM": "Устанавливает обнаружение целевого объекта на ARM при получении артефактов.",
  "ArtifactsSwitchTargetARM64": "Устанавливает обнаружение цели на ARM64 при получении артефактов",
  "ArtifactsSwitchTargetX64": "Устанавливает обнаружение целевого объекта на x64 при получении артефактов",
  "ArtifactsSwitchTargetX86": "Устанавливает целевой объект на x86 при получении артефактов",
  "ArtifactsSwitchWindows": "Принудительно обнаруживает узел в Windows при получении артефактов",
  "ArtifactsSwitchX64": "Принудительно обнаруживает узел в x64 при получении артефактов",
  "ArtifactsSwitchX86": "Принудительно обнаруживает узел на x86 при получении артефактов",
  "AssetCacheConsult": "Попытка скачать {path} с помощью кэша ресурсов {url}",
  "AssetCacheConsultScript": "Попытка скачать {path} с помощью сценария кэша ресурсов",
  "AssetCacheHit": "Скачивание выполнено успешно! Попадание в кэш ресурсов.",
  "AssetCacheHitUrl": "Скачивание выполнено успешно! Попадание в кэш ресурсов, не выполнена попытка авторизованного исходного {url}",
  "AssetCacheMiss": "Промах кэша ресурсов; выполняется попытка принудительного {url}",
  "AssetCacheMissBlockOrigin": "не обнаружено попаданий в кэш ресурсов, а блоки X-block-origin пытается использовать заслуживающий доверия источник {url}",
  "AssetCacheMissNoUrls": "Кэш ресурсов пропущен при поиске {sha} и неизвестен заслуживающий доверия URL-адрес",
  "AssetCacheProviderAcceptsNoArguments": "непредвиденные аргументы: \"{value}\" не принимает аргументы",
  "AssetCacheScriptBadVariable": "шаблон скрипта {value} содержит неизвестные заменяемые {list}",
  "AssetCacheScriptBadVariableHint": "если это необходимо в командной строке литерала, используйте {{{{{list}}}}",
  "AssetCacheScriptCommandLine": "командная строка полного сценария:",
  "AssetCacheScriptFailed": "сценарий кэша ресурсов вернул ненулевой код завершения {exit_code}",
  "AssetCacheScriptFailedToWriteCorrectHash": "скрипт кэша ресурсов вернул успешное выполнение, но полученный файл имеет непредвиденный хэш",
  "AssetCacheScriptFailedToWriteFile": "скрипт кэша ресурсов вернул успешное выполнение, но не вернул ожидаемый файл результатов",
  "AssetCacheScriptNeedsSha": "для шаблона {value} требуется SHA, но sha не известен для попытки скачивания {url}",
  "AssetCacheScriptNeedsUrl": "для шаблона {value} требуется URL-адрес, но ни один URL-адрес неизвестен для попытки скачивания {sha}",
  "AssetSourcesArg": "Источники для кэширования ресурсов. См. \"vcpkg help assetcaching\"",
  "AttemptingToSetBuiltInBaseline": "попытка задать встроенный базовый план в vcpkg.json при переопределения default-registry в vcpkg-configuration.json.\nБудет использоваться default-registry из vcpkg-configuration.json.",
  "AuthenticationMayRequireManualAction": "Один или несколько поставщиков учетных данных {vendor} запросили действие вручную. Добавьте двоичный источник «интерактивный», чтобы обеспечить интерактивность.",
  "AutoSettingEnvVar": "-- Автоматическая установка переменных среды {env_var} в \"{url}\".",
  "AutomaticLinkingForMSBuildProjects": "Все проекты MSBuild C++ теперь могут #include любые установленные библиотеки. Связывание будет выполнено автоматически. Установка новых библиотек сделает их мгновенно доступными.",
  "AutomaticLinkingForVS2017AndLater": "Visual Studio 2017 и более поздние версии теперь могут включать (#include) любые установленные библиотеки. Связывание будет выполнено автоматически. Установка новых библиотек сделает их мгновенно доступными.",
  "AvailableHelpTopics": "Доступные разделы справки:",
  "AzUrlAssetCacheRequiresBaseUrl": "непредвиденные аргументы: для конфигурации ресурса \"azurl\" требуется базовый URL-адрес",
  "AzUrlAssetCacheRequiresLessThanFour": "непредвиденные аргументы: для конфигурации ресурса \"azurl\" требуется менее 4 аргументов",
  "AzcopyFailedToPutBlob": "Решению azcopy не удалось отправить файл по адресу {url}. Код завершения: {exit_code}, код HTTP: {value}.",
  "BaselineConflict": "Указание vcpkg-configuration.default-registry в файле манифеста конфликтует со встроенным базовым планом.\nУдалите один из этих конфликтующих параметров.",
  "BaselineGitShowFailed": "при проверке базовых показателей из фиксации \"{commit_sha}\" не удалось \"git show\" versions/baseline.json. Это можно исправить путем получения фиксаций с помощью \"git fetch\".",
  "BaselineMissing": "Для {package_name} не назначена версия",
  "BaselineOnlyPlatformExpressionOrTriplet": "Невозможно указать выражение платформы и триаду",
  "BinariesRelativeToThePackageDirectoryHere": "двоичные файлы здесь относятся к ${{CURRENT_PACKAGES_DIR}}",
  "BinarySourcesArg": "Источники для двоичного кэширования. См. \"vcpkg help binarycaching\"",
  "BinaryWithInvalidArchitecture": "{path} создан для {arch}",
  "BuildAlreadyInstalled": "{spec} — уже установлено. Удалите {spec}, прежде чем выполнять сборку.",
  "BuildDependenciesMissing": "Для команды сборки необходимо установить все зависимости.\nОтсутствуют следующие зависимости:",
  "BuildResultBuildFailed": "BUILD_FAILED",
  "BuildResultCacheMissing": "CACHE_MISSING",
  "BuildResultCascadeDueToMissingDependencies": "CASCADED_DUE_TO_MISSING_DEPENDENCIES",
  "BuildResultDownloaded": "СКАЧАНО",
  "BuildResultExcluded": "ИСКЛЮЧЕНО",
  "BuildResultFileConflicts": "FILE_CONFLICTS",
  "BuildResultPostBuildChecksFailed": "POST_BUILD_CHECKS_FAILED",
  "BuildResultRemoved": "УДАЛЕНО",
  "BuildResultSucceeded": "УСПЕШНО",
  "BuildResultSummaryHeader": "СВОДКА ПО {triplet}",
  "BuildResultSummaryLine": "{build_result}: {count}",
  "BuildTreesRootDir": "Каталог Buildtrees (экспериментальная функция)",
  "BuildTroubleshootingMessage1": "Используйте последние файлы портов с \"git pull\" и \"vcpkg update\".\nЗатем проверьте наличие известных проблем в:",
  "BuildTroubleshootingMessage2": "Вы можете отправить новую проблему в:",
  "BuildTroubleshootingMessage3": "Добавьте \"Ошибка сборки [{package_name}]\" в название отчета об ошибке, следующие сведения о версии в описании ошибки и вложите любые релевантные журналы ошибок из раздела выше.",
  "BuildTroubleshootingMessageGH": "Вы также можете отправить проблему с помощью запуска (необходимо установить интерфейс командной строки GitHub):",
  "BuildingFromHead": "Сборка {spec} из HEAD...",
  "BuildingPackage": "Сборка {spec}...",
  "BuildingPackageFailed": "сбой {spec} при построении: {build_result}",
  "BuildingPackageFailedDueToMissingDeps": "из-за следующих отсутствующих зависимостей:",
  "BuiltInTriplets": "Встроенные триплеты:",
  "BuiltWithIncorrectArchitecture": "Триплет запрашивает создание двоичных файлов для {arch}, но следующие двоичные файлы созданы для другой архитектуры. Обычно это означает, что сведения о наборе инструментов неправильно передаются в систему сборки двоичных файлов. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_ARCHITECTURE_CHECK enabled)",
  "CISettingsOptCIBase": "Путь к файлу ci.baseline.txt. Используется для пропуска портов и обнаружения регрессий.",
  "CISettingsOptExclude": "Список разделенных запятой портов, которые нужно пропустить",
  "CISettingsOptFailureLogs": "Каталог, в который будут скопированы журналы сбоев",
  "CISettingsOptHostExclude": "Разделенный запятыми список портов, которые нужно пропустить для триплета узла",
  "CISettingsOptKnownFailuresFrom": "Путь к файлу известных сбоев сборки пакета",
  "CISettingsOptOutputHashes": "Файл для вывода всех определенных хэшей пакетов",
  "CISettingsOptParentHashes": "Чтение файлов хэшей пакетов для родительского состояния CI для уменьшения набора измененных пакетов.",
  "CISettingsOptXUnit": "Файл для вывода результатов в формате XUnit",
  "CISettingsVerifyGitTree": "Проверяет, соответствует ли каждый объект дерева git объявленной версии (это очень медленно)",
  "CISettingsVerifyVersion": "Печатает результат для каждого порта, а не только для ошибок",
  "CISkipInstallation": "Следующие пакеты уже установлены и больше не будут собираться:",
  "CISwitchOptAllowUnexpectedPassing": "Скрывает результаты \"Передача, удаление из списка сбоев\"",
  "CISwitchOptDryRun": "Распечатывает план без выполнения",
  "CISwitchOptRandomize": "Применяет произвольный порядок установки",
  "CISwitchOptSkipFailures": "Пропускает порты, помеченные как \"=fail\" в ci.baseline.txt",
  "CISwitchOptXUnitAll": "Сообщает о неизмененных портах в выходных данных XUnit",
  "CMakePkgConfigTargetsUsage": "{package_name} предоставляет модули pkg-config:",
  "CMakeTargetsUsage": "{package_name} предоставляет целевые объекты CMake:",
  "CMakeTargetsUsageHeuristicMessage": "# этот элемент создан эвристически и может быть неверным",
  "CMakeToolChainFile": "В проектах CMake следует использовать: \"-DCMAKE_TOOLCHAIN_FILE={path}\"",
  "CMakeUsingExportedLibs": "Чтобы использовать экспортированные библиотеки в проектах CMake, добавьте {value} в командную строку CMake.",
  "ChecksFailedCheck": "сбой vcpkg; дополнительные сведения недоступны.",
  "ChecksUnreachableCode": "достигнут недостижимый код",
  "ChecksUpdateVcpkg": "обновление vcpkg путем повторного запуска bootstrap-vcpkg может устранить этот сбой.",
  "CiBaselineAllowUnexpectedPassingRequiresBaseline": "--allow-unexpected-passing-passing можно использовать, только если указан базовый план с помощью --ci-baseline.",
  "CiBaselineDisallowedCascade": "Регрессия: значение {spec} является каскадным, но необходима его передача ({path}).",
  "CiBaselineIndependentRegression": "РЕГРЕССИЯ: сбой независимого объекта {spec} с {build_result}.",
  "CiBaselineRegression": "РЕГРЕССИЯ: {spec} с ошибкой {build_result}. Если требуется, добавьте {spec}=fail в {path}.",
  "CiBaselineRegressionHeader": "РЕГРЕССИИ:",
  "CiBaselineRegressionNoPath": "РЕГРЕССИЯ: сбой {spec} с {build_result}.",
  "CiBaselineUnexpectedFail": "РЕГРЕССИЯ: {spec} помечен как сбой, но не поддерживается для {triplet}.",
  "CiBaselineUnexpectedFailCascade": "РЕГРЕССИЯ: {spec} помечен как сбой, но одна зависимость не поддерживается для {triplet}.",
  "CiBaselineUnexpectedPass": "ПЕРЕДАЧА, УДАЛЕНИЕ ИЗ СПИСКА СБОЕВ: {spec} ({path}).",
  "ClearingContents": "Очистка содержимого {path}",
  "CmakeTargetsExcluded": "Дополнительные целевые объекты ({count}) не отображаются.",
  "CmdAcquireExample1": "vcpkg acquire <artifact>",
  "CmdAcquireProjectSynopsis": "Получает все артефакты, на которые ссылается манифест",
  "CmdAcquireSynopsis": "Получает именуемый артефакт",
  "CmdActivateSynopsis": "Активирует артефакты из манифеста",
  "CmdAddExample1": "vcpkg add port <port name>",
  "CmdAddExample2": "vcpkg add artifact <artifact name>",
  "CmdAddSynopsis": "Добавляет зависимость в манифест",
  "CmdAddVersionExample1": "vcpkg x-add-version <имя порта>",
  "CmdAddVersionOptAll": "Обрабатывает версии для всех портов",
  "CmdAddVersionOptOverwriteVersion": "Перезаписывает git-tree существующей версии",
  "CmdAddVersionOptSkipFormatChk": "Пропускает проверку форматирования файлов vcpkg.json",
  "CmdAddVersionOptSkipVersionFormatChk": "Пропускает проверку формата версии",
  "CmdAddVersionOptVerbose": "Печатает сообщения об успешном выполнении, а не только ошибки",
  "CmdAddVersionSynopsis": "Добавляет версию в базу данных версий",
  "CmdBootstrapStandaloneSynopsis": "Выполняет начальную загрузку корня vcpkg только из двоичного файла vcpkg",
  "CmdBuildExample1": "vcpkg build <port spec>",
  "CmdBuildExternalExample1": "vcpkg build-external <port name> <source path>",
  "CmdBuildExternalExample2": "vcpkg build-external zlib2 C:\\путь\\к\\каталогу\\с\\vcpkg.json",
  "CmdBuildExternalSynopsis": "Выполняет сборку порта из пути",
  "CmdBuildSynopsis": "Собирает порт",
  "CmdCheckSupportExample1": "vcpkg x-check-support <port name>",
  "CmdCheckSupportSynopsis": "Проверяет, поддерживается ли порт, без его сборки.",
  "CmdCheckToolsShaSwitchFix": "Исправляет запись sha в указанном файле",
  "CmdCheckToolsShaSwitchOnlyWithName": "Проверять только записи с указанным именем",
  "CmdCheckToolsShaSynopsis": "Проверяет записи sha512 в файле данных инструментов, скачивая все записи и вычисляя хэши",
  "CmdCiCleanSynopsis": "Очищает все файлы для подготовки к запуску CI.",
  "CmdCiSynopsis": "Пытается собрать все порты для CI-тестирования.",
  "CmdCiVerifyVersionsSynopsis": "Проверяет целостность базы данных версий",
  "CmdCreateExample1": "vcpkg create <port name> <uri>",
  "CmdCreateExample2": "vcpkg create my-fancy-port https://example.com/sources.zip",
  "CmdCreateExample3": "vcpkg create <port name> <uri> <downloaded filename>",
  "CmdDeactivateSynopsis": "Удаляет все активации артефактов из текущей оболочки",
  "CmdDependInfoExample1": "vcpkg depend-info <port name>",
  "CmdDependInfoFormatConflict": "Указаны конфликтующие форматы. Допускается только один из следующих: --format, --dgml или --dot.",
  "CmdDependInfoFormatHelp": "Выбирает формат вывода: \"list\", \"tree\", \"mermaid\", \"dot\" или \"dgml\"",
  "CmdDependInfoFormatInvalid": "--format={value} является нераспознанным форматом. --format должен иметь одно из следующих значений: \"list\", \"tree\", \"mermaid\", \"dot\" или \"dgml\".",
  "CmdDependInfoOptDepth": "Показывает глубину рекурсии в выходных данных \"list\"",
  "CmdDependInfoOptMaxRecurse": "Задает максимальную глубину рекурсии. Значение по умолчанию — \"Без ограничений\"",
  "CmdDependInfoOptSort": "Выбирает одно из следующих значений для порядка сортировки формата \"list\": \"lexicographical\" (лексикографический), \"topological\" (топологический) (по умолчанию), \"reverse\" (обратный)",
  "CmdDependInfoShowDepthFormatMismatch": "--show-depth можно использовать только с форматами \"list\" и \"tree\".",
  "CmdDependInfoXtreeTree": "--sort=x-tree не может использоваться с форматами, отличными от \"tree\"",
  "CmdDownloadExample1": "vcpkg x-download <filepath> <sha512> --url=https://...",
  "CmdDownloadExample2": "vcpkg x-download <filepath> --sha512=<sha512> --url=https://...",
  "CmdDownloadExample3": "vcpkg x-download <filepath> --skip-sha512 --url=https://...",
  "CmdDownloadSynopsis": "Скачивает файл",
  "CmdEditExample1": "vcpkg edit <port name>",
  "CmdEditOptAll": "Открывает редактор в порте, а также в подпапке дерева сборки для конкретного порта",
  "CmdEditOptBuildTrees": "Открывает редактор во вложенной папке buildtree для конкретного порта.",
  "CmdEnvOptions": "Добавляет установленный {path} в {env_var}",
  "CmdExportEmptyPlan": "Отказ от создания экспорта нулевых пакетов. Установите пакеты перед экспортом.",
  "CmdExportExample1": "vcpkg export <имена портов> [--nuget] [--output-dir=out_dir]",
  "CmdExportOpt7Zip": "Экспортирует в файл 7zip (.7z)",
  "CmdExportOptDereferenceSymlinks": "Копирует символические ссылки как обычные файлы и каталоги в экспортированные результаты",
  "CmdExportOptDryRun": "Фактически не выполняет экспорт",
  "CmdExportOptInstalled": "Экспортирует все установленные пакеты",
  "CmdExportOptNuget": "Экспортирует пакет NuGet",
  "CmdExportOptRaw": "Экспортирует в несжатый каталог",
  "CmdExportOptZip": "Экспортирует в ZIP-файл",
  "CmdExportSettingNugetDesc": "Описание для экспортированного пакета NuGet",
  "CmdExportSettingNugetID": "Идентификатор для экспортированного пакета NuGet (переопределяет параметр --output)",
  "CmdExportSettingNugetVersion": "Версия экспортированного пакета NuGet",
  "CmdExportSettingOutput": "Выходное имя (используется для создания имени файла)",
  "CmdExportSettingOutputDir": "Выходной каталог для производства артефактов",
  "CmdExportSynopsis": "Создает изолированное развертывание установленных портов",
  "CmdFetchOptXStderrStatus": "Печатает сообщения о состоянии и скачивании в stderr, а не в stdout (ошибки и сбои по-прежнему отправляются в stdout)",
  "CmdFetchSynopsis": "Извлекает содержимое из системы или Интернета",
  "CmdFindExample1": "vcpkg find port <port name>",
  "CmdFindExample2": "vcpkg find artifact <artifact name>",
  "CmdFindSynopsis": "Выполняет поиск порта или артефакта, который может быть установлен или активирован",
  "CmdFormatFeatureBaselineExample": "vcpkg format-feature-baseline <путь к ci.feature.baseline.txt>",
  "CmdFormatFeatureBaselineSynopsis": "Форматирует базовый файл функций",
  "CmdFormatManifestExample1": "vcpkg format-manifest <vcpkg.json path>",
  "CmdFormatManifestOptAll": "Форматирует файлы манифеста всех портов",
  "CmdFormatManifestOptConvertControl": "Преобразует файлы CONTROL в файлы манифеста",
  "CmdFormatManifestSynopsis": "Улучшает vcpkg.json",
  "CmdGenerateMSBuildPropsExample1": "vcpkg generate-msbuild-props --msbuild-props <путь>",
  "CmdGenerateMSBuildPropsExample2": "vcpkg generate-msbuild-props --msbuild-props out.props",
  "CmdGenerateMSBuildPropsSynopsis": "Создает файлы msbuild .props, как если бы они активировали зависимости артефакта манифеста, без их получения.",
  "CmdGenerateMessageMapOptNoOutputComments": "Исключает комментарии при создании карты сообщения (удобно для создания файла локализации на английском языке)",
  "CmdHashExample1": "vcpkg hash <path>",
  "CmdHashExample2": "vcpkg hash <path> SHA256",
  "CmdHashSynopsis": "Получает SHA256 или SHA512 файла",
  "CmdHelpCommandSynopsis": "Отображает подробную справку для <command>",
  "CmdHelpCommands": "help <команда>",
  "CmdHelpCommandsSynopsis": "Отображает полный список команд, включая редкие, не указанные здесь.",
  "CmdHelpTopic": "help <topic>",
  "CmdInfoOptInstalled": "Сообщает о установленных пакетах, а не о доступных (экспериментальная функция)",
  "CmdInfoOptTransitive": "Также сообщает о зависимостях установленных пакетов (экспериментальная функция)",
  "CmdInitRegistryExample1": "vcpkg x-init-registry <path>",
  "CmdInitRegistrySynopsis": "Создает пустой реестр git.",
  "CmdInstallExample1": "vcpkg install <port name> <port name>...",
  "CmdIntegrateSynopsis": "Интегрирует vcpkg с компьютерами, проектами или оболочками",
  "CmdLicenseReportSynopsis": "Показывает объявленные лицензии для всех портов в установленном дереве",
  "CmdListExample2": "vcpkg list <filter>",
  "CmdNewExample1": "vcpkg new --name=example --version=1.0",
  "CmdNewOptApplication": "Создает манифест приложения (не требует имени или версии)",
  "CmdNewOptSingleFile": "Встраивает vcpkg-configuration.json в vcpkg.json.",
  "CmdNewOptVersionDate": "Интерпретирует --version как дату ISO 8601. (ДД-ММ-ГГГГ)",
  "CmdNewOptVersionRelaxed": "Интерпретирует --version как упрощенно-числовую версию (неотрицательные числа разделены точками)",
  "CmdNewOptVersionString": "Интерпретирует --version как строку без поведения упорядочения",
  "CmdNewSettingName": "Имя для нового манифеста",
  "CmdNewSettingVersion": "Версия нового манифеста",
  "CmdNewSynposis": "Создает новый манифест",
  "CmdOptForMergeWith": "тестовые порты, предназначенные для слияния с этой ссылкой git",
  "CmdOwnsExample1": "vcpkg owns <шаблон>",
  "CmdPackageInfoExample1": "vcpkg x-package-info <имя пакета>...",
  "CmdPortsdiffExample1": "vcpkg portsdiff <имя ветви>",
  "CmdPortsdiffExample2": "vcpkg portsdiff <из> <в>",
  "CmdPortsdiffSynopsis": "Разностные изменения в версиях портов между фиксациями",
  "CmdRegenerateOptDryRun": "Фактически не выполняет действие, отображает только то, что было бы выполнено",
  "CmdRegenerateOptForce": "Выполняет (потенциально опасное) действие без подтверждения",
  "CmdRegenerateOptNormalize": "Применяет все исправления нерекомендуемых элементов",
  "CmdRemoveExample1": "vcpkg remove <имя пакета>...",
  "CmdRemoveOptDryRun": "Печатает удаляемые пакеты, но не удаляет их",
  "CmdRemoveOptOutdated": "Удаляет все пакеты с версиями, не соответствующими встроенному реестру",
  "CmdRemoveOptRecurse": "Позволяет удалять зависимые пакеты, не указанные явным образом",
  "CmdSearchExample1": "vcpkg search <шаблон>",
  "CmdSetInstalledExample1": "vcpkg x-set-installed <имя пакета> <имя пакета>...",
  "CmdSetInstalledOptDryRun": "Фактически не выполняет сборку и установку",
  "CmdSetInstalledOptNoUsage": "Не печатает сведения об использовании CMake после установки",
  "CmdSetInstalledOptWritePkgConfig": "Записывает файл в формате NuGet packages.config для использования с внешним двоичным кэшированием. Дополнительные сведения см. в \"vcpkg help binarcaching\"",
  "CmdSetInstalledSynopsis": "Устанавливает, обновляет или удаляет пакеты, чтобы установленные пакеты совпадали с указанными",
  "CmdSettingCopiedFilesLog": "Путь к создаваемому журналу скопированных файлов",
  "CmdSettingInstalledDir": "Путь к установленному дереву для использования",
  "CmdSettingTLogFile": "Путь к создаваемому TLOG-файлу",
  "CmdSettingTargetBin": "Путь к двоичному файлу для анализа",
  "CmdTestCIFeatureBaseline": "Путь к файлу ci.feature.baseline.txt. Используется для пропуска портов с известными сбоями тестов и обнаружения регрессий",
  "CmdTestFeaturesAll": "Выполняет тесты для всех портов",
  "CmdTestFeaturesFailingAbis": "Путь к файлу, в который будут записаны все хэши ABI со сбоями",
  "CmdTestFeaturesNoCombined": "Пропускает тестирование всех включенных функций",
  "CmdTestFeaturesNoCore": "Пропускает тестирование только включенной функции \"core\"",
  "CmdTestFeaturesNoSeparated": "Пропускает тестирование каждой функции по отдельности",
  "CmdTestFeaturesSynopsis": "Тестирует функции порта",
  "CmdUpdateBaselineOptDryRun": "Распечатывает план без выполнения",
  "CmdUpdateBaselineOptInitial": "Добавляет \"builtin-baseline\" в vcpkg.json, который его еще не содержит",
  "CmdUpdateBaselineSynopsis": "Обновляет базовые показатели реестров Git в манифесте для фиксации HEAD реестров",
  "CmdUpdateRegistryAll": "Обновляет все известные реестры артефактов",
  "CmdUpdateRegistryAllExcludesTargets": "Обновить реестр --all нельзя использовать со списком реестров артефактов",
  "CmdUpdateRegistryAllOrTargets": "Для обновления реестра требуется список имен реестра артефактов или URiIs, или --all.",
  "CmdUpdateRegistryExample3": "vcpkg x-update-registry <имя реестра артефактов>",
  "CmdUpdateRegistrySynopsis": "Повторно скачивает реестр артефактов",
  "CmdUpgradeOptNoDryRun": "Фактическое обновление",
  "CmdUpgradeOptNoKeepGoing": "Остановить установку пакетов при сбое",
  "CmdUseExample1": "vcpkg use <имя артефакта>",
  "CmdUseSynopsis": "Активировать один артефакт в этой оболочке",
  "CmdVSInstancesSynopsis": "Перечисляет обнаруженные экземпляры Visual Studio",
  "CmdXDownloadOptHeader": "Дополнительный заголовок для использования при извлечении из URL-адресов",
  "CmdXDownloadOptSha": "Хэш загружаемого файла",
  "CmdXDownloadOptSkipSha": "Пропускает проверку SHA512 загруженного файла",
  "CmdXDownloadOptStore": "Сохраняет файл вместо его извлечения",
  "CmdXDownloadOptUrl": "URL-адрес для скачивания и хранения, если он отсутствует в кэше",
  "CmdZApplocalSynopsis": "Копирует зависимости двоичного файла из установленного дерева в расположение этого двоичного файла для локального развертывания приложения",
  "CmdZExtractExample1": "vcpkg z-extract <путь к архиву> <выходной каталог>",
  "CmdZExtractExample2": "vcpkg z-extract источник.zip исходный_каталог --strip 2",
  "CmdZExtractOptStrip": "Количество начальных каталогов, которые нужно удалить из всех путей",
  "CommandEnvExample2": "vcpkg env \"ninja -C <путь>\" --triplet x64-windows",
  "CommandFailed": "следующую команду:\n{command_line}\nвыполнить не удалось. Выдано сообщение об ошибке:",
  "CommunityTriplets": "Триплеты сообщества:",
  "CompilerPath": "Найден компилятор: {path}",
  "ComputeAllAbis": "Вычисление всех хэшей ABI...",
  "ComputeInstallPlans": "Вычисление планов установки ({count})...",
  "ComputingInstallPlan": "Вычисление плана установки...",
  "ConfigurationErrorRegistriesWithoutBaseline": "Конфигурация, определенная в {path}, недопустима..\n\nПри использовании реестров необходимо, чтобы для стандартного реестра были настроены базовые показатели или чтобы стандартному реестру было присвоено значение NULL.\n\nДополнительные сведения: {url}.",
  "ConfigurationNestedDemands": "[\"{json_field}\"] содержит вложенный объект \"demands\" (вложенный объект \"demands\" не оказывает влияния)",
  "ConflictingEmbeddedConfiguration": "можно использовать только один из {{\"configuration\", \"vcpkg-configuration\"}}",
  "ConflictingFiles": "Следующие файлы уже установлены в {path} и конфликтуют с {spec}",
  "ConsideredVersions": "Следующие исполняемые файлы были рассмотрены, но отклонены из-за требования версии {version}:",
  "ConstraintViolation": "Обнаружено нарушение ограничения:",
  "ContinueCodeUnitInStart": "найдена единица кода продолжения в начальной позиции",
  "ControlCharacterInString": "Управляющий символ в строке",
  "ControlSupportsMustBeAPlatformExpression": "\"Supports\" должно быть выражением платформы",
  "CopyrightIsDir": "этот порт устанавливает ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/copyright в каталог, но это должно быть файлом. Рассмотрите возможность объединения отдельных файлов об авторских правах в один с помощью vcpkg_install_copyright. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_COPYRIGHT_CHECK enabled)",
  "CorruptedDatabase": "База данных установки vcpkg повреждена. Это может объясняться дефектом в vcpkg или непредвиденным изменением содержимого каталога \"installed\". Проблему можно устранить, удалив каталог \"installed\" и переустановив нужные компоненты. Если проблема возникает постоянно, зарегистрируйте дефект на https://github.com/microsoft/vcpkg.",
  "CouldNotDeduceNugetIdAndVersion": "Не удалось определить идентификатор nuget и версию по имени файла: {path}",
  "CouldNotFindBaselineInCommit": "Не удалось найти базовый показатель в ссылке {url} в {commit_sha} для {package_name}.",
  "CouldNotFindGitTreeAtCommit": "не удалось найти дерево Git для \"versions\" в репозитории {package_name} фиксации {commit_sha}",
  "CouldNotFindVersionDatabaseFile": "Не удалось найти файл базы данных версий: {path}",
  "CreateFailureLogsDir": "Создание выходного каталога для журналов сбоев: {path}.",
  "CreatedNuGetPackage": "Создан пакет nupkg: {path}",
  "Creating7ZipArchive": "Создание архива 7zip...",
  "CreatingNugetPackage": "Создание пакета NuGet...",
  "CreatingZipArchive": "Создание архива Zip...",
  "CreationFailed": "Не удалось создать {path}.",
  "CurlFailedGeneric": "Операция завитка завершилась сбоем, код ошибки {exit_code}.",
  "CurlFailedToPut": "curl не удалось поместить файл в {url} с кодом завершения {exit_code}.",
  "CurlFailedToPutHttp": "curl не удалось поместить файл в {url} с кодом завершения {exit_code} и HTTP-кодом {value}.",
  "CurlFailedToReturnExpectedNumberOfExitCodes": "Не удалось вернуть ожидаемое число кодов завершения. это может произойти, если что-то завершает завиток до его завершения. Завиток завершился {exit_code} что обычно является кодом результата последней операции, но может быть результатом сбоя. Командная строка {command_line}, и все выходные данные приведены ниже:",
  "CurrentCommitBaseline": "Текущую фиксацию можно использовать в качестве базового плана, а именно:\n\t\"builtin-baseline\": \"{commit_sha}\"",
  "CycleDetectedDuring": "обнаружен цикл во время {spec}:",
  "DefaultBinaryCachePlatformCacheRequiresAbsolutePath": "Переменная среды VCPKG_DEFAULT_BINARY_CACHE должна быть каталогом (было: {path})",
  "DefaultBinaryCacheRequiresAbsolutePath": "Значение переменной среды VCPKG_DEFAULT_BINARY_CACHE должно быть абсолютным (было: {path})",
  "DefaultBinaryCacheRequiresDirectory": "Переменная среды VCPKG_DEFAULT_BINARY_CACHE должна быть каталогом (было: {path})",
  "DefaultFeatureCore": "компонент \"core\" отключает компоненты по умолчанию и поэтому не может находиться в списке компонентов по умолчанию",
  "DefaultFeatureDefault": "компонент \"default\" ссылается на список компонентов по умолчанию и поэтому не может находиться в списке компонентов по умолчанию",
  "DefaultFeatureIdentifier": "имена компонентов по умолчанию должны быть идентификаторами",
  "DefaultFlag": "По умолчанию включено --{option}.",
  "DefaultRegistryIsArtifact": "Реестр, используемый по умолчанию, не может быть реестром артефактов.",
  "DependencyFeatureCore": "компонент \"core\" не может находиться в списке компонентов зависимости. Чтобы отключить компоненты по умолчанию, добавьте \"default-features\": false.",
  "DependencyFeatureDefault": "компонент \"default\" не может находиться в списке компонентов зависимости. Чтобы включить компоненты по умолчанию, добавьте \"default-features\": true.",
  "DependencyGraphCalculation": "Отправка графа зависимостей включена.",
  "DependencyGraphFailure": "Сбой отправки графа зависимостей.",
  "DependencyGraphSuccess": "Граф зависимостей успешно отправлен.",
  "DependencyInFeature": "зависимость находится в функции с именем {feature}",
  "DependencyNotInVersionDatabase": "в базе данных версий нет зависимости {package_name}. Существует ли этот порт?",
  "DependencyWillFail": "Зависимость {feature_spec} не будет выполнять сборку => cascade",
  "DetectCompilerHash": "Обнаружение хэша компилятора для триплета {triplet}...",
  "DirectoriesRelativeToThePackageDirectoryHere": "каталоги здесь относятся к ${{CURRENT_PACKAGES_DIR}}",
  "DllsRelativeToThePackageDirectoryHere": "библиотеки DLL здесь относятся к ${{CURRENT_PACKAGES_DIR}}",
  "DocumentedFieldsSuggestUpdate": "Если это задокументированные поля, которые следует распознать, попробуйте обновить средство VCPKG.",
  "DownloadAvailable": "Доступна загружаемая копия этого инструмента, которую можно использовать, отключив {env_var}.",
  "DownloadFailedHashMismatch": "скачивание из {url} имеет непредвиденный хэш",
  "DownloadFailedHashMismatchActualHash": "Фактически: {sha}",
  "DownloadFailedHashMismatchExpectedHash": "Ожидается: {sha}",
  "DownloadFailedHashMismatchZero": "не удалось скачать, так как ожидаемый SHA512 был нулевым. Измените ожидаемое значение SHA512 на: {sha}",
  "DownloadFailedProxySettings": "Если вы используете прокси-сервер, проверьте правильность его настроек..\nВозможные причины:\n1. Фактически вы используете HTTP-прокси, но устанавливаете переменную HTTPS_PROXY на \"https//address:port\".\nЭто неправильно, так как префикс \"https://\" утверждает, что прокси-сервер является HTTPS-прокси, в то время как ваш прокси-сервер (v2ray, shadowsocksr и т. д.) является HTTP-прокси.\nПопробуйте вместо \"http://address:port\" задать значение HTTP_PROXY и HTTPS_PROXY.\n2. Если вы используете Windows, vcpkg автоматически будет использовать настройки прокси-сервера Windows IE, установленные программным обеспечением прокси-сервера. Сведения: https://github.com/microsoft/vcpkg-tool/pull/77\nЗначение, установленное прокси-сервером, может быть неправильным или содержать тот же префикс \"https://\".\n3. Удаленный сервер этого прокси-сервера не обслуживается.\nЕсли вы считаете, что это не временная ошибка сервера скачивания и vcpkg необходимо изменить, чтобы скачать этот файл из другого расположения, отправьте проблему по адресу https://github.com/Microsoft/vcpkg/issues",
  "DownloadFailedRetrying": "Сбой скачивания {url} — повторная попытка через {value} мс",
  "DownloadFailedStatusCode": "{url}: сбой: код состояния {value}",
  "DownloadOrUrl": "или {url}",
  "DownloadRootsDir": "Скачивает каталог (по умолчанию: {env_var})",
  "DownloadSuccesful": "Успешно загружено {path}",
  "DownloadSuccesfulUploading": "Успешно загружена {path}, сохранена в {url}",
  "DownloadTryingAuthoritativeSource": "Попытка {url}",
  "DownloadWinHttpError": "{url}: сбой {system_api} с кодом завершения {exit_code}.",
  "DownloadedSources": "Скачанные источники для {spec}",
  "DownloadingAssetShaToFile": "Скачивание записи кэша ресурсов {sha} -> {path}",
  "DownloadingAssetShaWithoutAssetCache": "запрошено скачивание записи кэша ресурсов {sha} -> {path}, но кэши ресурсов не настроены",
  "DownloadingFile": "Скачивание {path}",
  "DownloadingFileFirstAuthoritativeSource": "Скачивание {path}, попытка {url}",
  "DownloadingPortableToolVersionX": "Подходящая версия инструмента {tool_name} не найдена (требуется версия {version}).",
  "DownloadingTools": "Скачивание инструментов ({count})",
  "DownloadingUrlToFile": "Скачивание {url} -> {path}",
  "DownloadingVcpkgStandaloneBundle": "Скачивание изолированного пакета {version}.",
  "DownloadingVcpkgStandaloneBundleLatest": "Скачивание новейшего изолированного пакета.",
  "DuplicateDependencyOverride": "{package_name} уже имеет переопределение",
  "DuplicatePackagePattern": "Пакет \"{package_name}\" дублируется.",
  "DuplicatePackagePatternFirstOcurrence": "Первое объявление в:",
  "DuplicatePackagePatternIgnoredLocations": "Следующие повторные объявления будут пропущены.",
  "DuplicatePackagePatternLocation": "расположение: {path}",
  "DuplicatePackagePatternRegistry": "реестр: {url}",
  "DuplicatedKeyInObj": "Дублированный ключ \"{value}\" в объекте",
  "ElapsedForPackage": "Затраченное время на обработку {spec}: {elapsed}",
  "ElapsedTimeForChecks": "Время определения успешного выполнения или сбоя: {elapsed}",
  "EmailVcpkgTeam": "Отправьте электронное письмо с любым отзывом на адрес {url}.",
  "EmptyLicenseExpression": "Выражение лицензии SPDX было пустым.",
  "EndOfStringInCodeUnit": "найден конец строки в середине кодовой точки",
  "EnvInvalidMaxConcurrency": "{env_var} имеет значение {value}, но должно быть > 0",
  "EnvPlatformNotSupported": "Команды среды сборки не поддерживаются на этой платформе",
  "EnvStrFailedToExtract": "не удалось развернуть строку среды:",
  "EnvVarMustBeAbsolutePath": "{env_var} ({path}) не был абсолютным путем",
  "ErrorDetectingCompilerInfo": "при обнаружении сведений о компиляторе:\nсодержимое файла журнала в \"{path}\":",
  "ErrorIndividualPackagesUnsupported": "В режиме манифеста \"установка vcpkg\" не поддерживает отдельные аргументы пакета. \nЧтобы установить дополнительные пакеты, отредактируете vcpkg.json и запустите \"vcpkg install\" без аргументов пакета.",
  "ErrorInvalidClassicModeOption": "Параметр --{option} не поддерживается в классическом режиме, и манифест не найден.",
  "ErrorInvalidExtractOption": "В качестве параметра --{option} должно быть установлено неотрицательное целое число или значение \"AUTO\".",
  "ErrorInvalidManifestModeOption": "Параметр --{option} не поддерживается в режиме манифеста.",
  "ErrorManifestMustDifferFromOverlay": "Каталог манифеста ({path}) не может совпадать с каталогом, настроенным в наложенных портах.",
  "ErrorManifestMustDifferFromOverlayDot": "Каталог манифеста не может совпадать с каталогом, настроенным в наложенных портах, поэтому значения \"overlay-ports\" не могут иметь значение \".\".",
  "ErrorMissingVcpkgRoot": "Не удалось обнаружить vcpkg-root. Если вы пытаетесь использовать созданную копию VCPKG, необходимо определить переменную среду VCPKG_ROOT, чтобы она указывала на клонированную копию https://github.com/Microsoft/vcpkg.",
  "ErrorNoVSInstance": "в триплете {triplet}: Не удается найти допустимый экземпляр Visual Studio",
  "ErrorNoVSInstanceAt": "в \"{path}\"",
  "ErrorNoVSInstanceFullVersion": "с префиксом версии набора инструментов {version}",
  "ErrorNoVSInstanceVersion": "с версией набора инструментов {version}",
  "ErrorParsingBinaryParagraph": "при анализе абзаца двоичного файла для {spec}",
  "ErrorRequireBaseline": "для взаимодействия с портами для этого экземпляра vcpkg требуется манифест с указанным базовым показателем. Пожалуйста, добавьте \"builtin-baseline\" или \"vcpkg-configuration.json\" в манифест, который переопределяет реестр по умолчанию.",
  "ErrorRequirePackagesList": "Для установки vcpkg требуется список пакетов для установки в классическом режиме.",
  "ErrorUnableToDetectCompilerInfo": "vcpkg не удалось обнаружить сведения об активном компиляторе. См. выше вывод об ошибке CMake.",
  "ErrorVcvarsUnsupported": "в триплете {triplet}: Использование запроса разработчика Visual Studio не поддерживается на узлах, отличных от Windows. \nОпределите \"VCPKG_CMAKE_SYSTEM_NAME\" или \"VCPKG_CHAINLOAD_TOOLCHAIN_FILE\" в файле триплета.",
  "ErrorVsCodeNotFound": "Visual Studio Code не найден, а переменная среды {env_var} не задана или недействительна.",
  "ErrorVsCodeNotFoundPathExamined": "Рассмотрены следующие пути:",
  "ErrorWhileFetchingBaseline": "при получении базового плана \"{value}\" из репозитория {package_name}:",
  "ErrorWhileParsing": "При анализе {path} возникли ошибки.",
  "ErrorWhileWriting": "Произошла ошибка при записи {path}.",
  "ExamplesHeader": "Примеры:",
  "ExceededRecursionDepth": "Превышена глубина рекурсии.",
  "ExcludedPackage": "Исключено: {spec}",
  "ExcludedPackages": "Исключены следующие пакеты:",
  "ExecutablesRelativeToThePackageDirectoryHere": "исполняемые файлы здесь относятся к ${{CURRENT_PACKAGES_DIR}}",
  "ExpectedAnObject": "ожидается объект",
  "ExpectedAtMostOneSetOfTags": "Найдено {count} наборов {old_value}.*{new_value}, но ожидается не более 1, в блоке:\n{value}",
  "ExpectedCharacterHere": "здесь ожидается \"{expected}\"",
  "ExpectedDefaultFeaturesList": "требуется \",\" или конец текста в списке функций по умолчанию",
  "ExpectedDependenciesList": "требуется \",\" или конец текста в списке зависимостей",
  "ExpectedDigitsAfterDecimal": "Ожидаемые цифры после десятичной запятой",
  "ExpectedExplicitTriplet": "ожидался явный триплет",
  "ExpectedFailSkipOrPass": "Ожидалось значение fail, skip или pass.",
  "ExpectedFeatureBaselineState": "здесь ожидается \"fail\", \"skip\", \"pass\", \"cascade\", \"no-separate-feature-test\", \"options\", \"feature-fails\" или \"combination-fails\"",
  "ExpectedFeatureListTerminal": "в списке функций ожидается \",\" или \"]\"",
  "ExpectedFeatureName": "ожидаемое имя функции (должно быть строчными буквами, цифрами, \"-\")",
  "ExpectedInstallStateField": "ожидается одно из следующих значений: \"not-installed\", \"half-installed\" или \"installed\"",
  "ExpectedOneSetOfTags": "Найдено {count} наборов {old_value}.*{new_value}, но ожидается ровно 1, в блоке:\n{value}",
  "ExpectedOneVersioningField": "ожидается только одно поле управления версиями",
  "ExpectedPathToExist": "Ожидается, что {path} будет существовать после получения",
  "ExpectedPortName": "здесь ожидается имя порта (должно быть в нижнем регистре, цифры, \"-\")",
  "ExpectedReadWriteReadWrite": "непредвиденный аргумент: ожидается \"read\", \"readwrite\" или \"write\"",
  "ExpectedStatusField": "В абзаце состояния ожидалось поле \"status\"",
  "ExpectedTextHere": "здесь ожидается \"{expected}\"",
  "ExpectedTripletName": "здесь ожидается имя триплета (должно быть в нижнем регистре, цифры, \"-\")",
  "ExpectedWantField": "ожидается один из следующих значений: \"install\", \"hold\", \"deinstall\" или \"purge\"",
  "Exported7zipArchive": "Архив 7zip экспортирован в папку: {path}",
  "ExportedZipArchive": "Архив Zip экспортирован в папку: {path}",
  "ExportingAlreadyBuiltPackages": "Следующие пакеты уже созданы и будут экспортированы:",
  "ExportingPackage": "Экспорт {package_name}...",
  "ExtendedDocumentationAtUrl": "Расширенная документация доступна по адресу '{url}'.",
  "ExtractHelp": "Извлекает архив.",
  "ExtractingTool": "Извлечение {tool_name}...",
  "FailedPostBuildChecks": "Обнаружено проблем с проверкой после сборки: {count}. Обычно это вызвано ошибками в portfile.cmake или вышестоящей системе сборки. Исправьте их перед отправкой этого порта в курированный реестр.",
  "FailedToAcquireMutant": "не удалось получить {path} мутанта",
  "FailedToCheckoutRepo": "не удалось извлечь \"versions\" из репозитория {package_name}",
  "FailedToDeleteDueToFile": "не удалось remove_all({value}) из-за {path}: ",
  "FailedToDeleteDueToFile2": "не удалось удалить из-за {path}",
  "FailedToDeleteInsideDueToFile": "не удалось remove_all_inside({value}) из-за {path}: ",
  "FailedToDetermineCurrentCommit": "Не удалось определить текущую фиксацию:",
  "FailedToExtract": "Сбой извлечения \" {path}\":",
  "FailedToFetchRepo": "Не удалось получить {url}.",
  "FailedToFindPortFeature": "{package_name} не содержит функции с именем {feature}.",
  "FailedToFormatMissingFile": "Нет файлов для форматирования.\nПередайте либо --all, либо явные файлы для форматирования или преобразования.",
  "FailedToLoadInstalledManifest": "Не удалось загрузить файл управления или манифеста для {package_name} из-за следующей ошибки. Удалите {package_name} и повторите попытку.",
  "FailedToLoadManifest": "Не удалось загрузить манифест из {path} каталога",
  "FailedToLocateSpec": "Сбой поиска спецификации в графе: {spec}",
  "FailedToOpenAlgorithm": "не удалось открыть {value}",
  "FailedToParseBaseline": "Не удалось проанализировать базовый план: {path}",
  "FailedToParseCMakeConsoleOut": "Сбой анализа выходных данных консоли CMake для поиска маркеров начала или конца блока.",
  "FailedToParseConfig": "не удалось выполнить анализ конфигурации",
  "FailedToParseNoTopLevelObj": "Не удалось проанализировать {path}, ожидался объект верхнего уровня.",
  "FailedToParseNoVersionsArray": "Не удалось проанализировать {path}, ожидался массив \"versions\".",
  "FailedToParseSerializedBinParagraph": "[проверка работоспособности] Не удалось проанализировать абзац сериализованного двоичного файла.\nОткройте проблему на странице https://github.com/microsoft/vcpkg со следующими выходными данными:\n{error_msg}\nАбзац сериализованного двоичного файла:",
  "FailedToRunToolToDetermineVersion": "Сбой запуска \"{path}\" для определения версии {tool_name}.",
  "FailedToStoreBackToMirror": "Не удалось сохранить путь {path} для URL-адреса {url}.",
  "FailedToStoreBinaryCache": "Сбой сохранения двоичного кэша {path}",
  "FailedToTakeFileSystemLock": "Не удалось заблокировать файловую систему",
  "FailedVendorAuthentication": "Одному или нескольким поставщикам учетных данных {vendor} не удалось пройти аутентификацию. См. «{url}» для получения дополнительной информации о том, как предоставить учетные данные.",
  "FeatureBaselineEntryAlreadySpecified": "\"{feature}\" уже объявлено как \"{value}\"",
  "FeatureBaselineExpectedFeatures": "При использовании \"{value}\" необходимо указать список функций.",
  "FeatureBaselineFormatted": "Форматирование базового файла функций успешно выполнено.",
  "FeatureBaselineNoFeaturesForFail": "При использовании \"= fail\" список функций не разрешен.",
  "FeatureBaselineNoFeaturesForPass": "При использовании \"= pass\" список функций не разрешен.",
  "FeatureTestProblems": "Возникли проблемы с тестированием функций!",
  "FetchingBaselineInfo": "Извлечение базовой информации из {package_name}...",
  "FetchingRegistryInfo": "Получение сведений реестра из {url} ({value})...",
  "FieldKindDidNotHaveExpectedValue": "неожиданное значение \"kind\": (ожидалось одно из следующих значений: {expected}; найдено {actual})",
  "FileIsNotExecutable": "этот файл не похож на исполняемый",
  "FileNotFound": "файл не найден",
  "FileReadFailed": "Не удалось прочитать {count} байт из {path} по смещению {byte_offset}.",
  "FileSeekFailed": "Не удалось найти расположение {byte_offset} в {path}.",
  "FilesContainAbsolutePath1": "В установленном пакете не должно быть абсолютных путей, таких как следующие. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_ABSOLUTE_PATHS_CHECK enabled)",
  "FilesContainAbsolutePath2": "здесь найдены абсолютные пути",
  "FilesContainAbsolutePathPkgconfigNote": "Добавление вызова \"vcpkg_fixup_pkgconfig()\" может исправить абсолютные пути в файлах .pc.",
  "FilesExported": "Файлы экспортированы в папку: {path}",
  "FilesRelativeToTheBuildDirectoryHere": "файлы здесь относятся к каталогу сборки",
  "FilesRelativeToThePackageDirectoryHere": "файлы здесь относятся к ${{CURRENT_PACKAGES_DIR}}",
  "FindCommandFirstArg": "Первым аргументом для \"find\" должен быть \"artifact\" или \"port\".",
  "FindVersionArtifactsOnly": "--version нельзя использовать с поиском vcpkg или портом поиска vcpkg",
  "FishCompletion": "Завершение vcpkg fish уже полностью добавлено в \"{path}\".",
  "FixedEntriesInFile": "Исправлены записи ({count}) в {path}.",
  "FloatingPointConstTooBig": "Слишком большая константа с плавающей запятой: {count}",
  "FollowingPackagesMissingControl": "Следующие пакеты не содержат допустимый CONTROL или vcpkg.json.",
  "FollowingPackagesNotInstalled": "Следующие пакеты не установлены.",
  "FollowingPackagesUpgraded": "Следующие пакеты обновлены.",
  "ForMergeWithTestingTheFollowing": "--for-merge-with {value} тестирует:",
  "ForMoreHelp": "Для получения дополнительной справки",
  "ForceClassicMode": "Принудительный классический режим, даже если удалось найти манифест.",
  "ForceSystemBinariesOnWeirdPlatforms": "Переменная среды VCPKG_FORCE_SYSTEM_BINARIES должна быть задана на платформах ARM, s390x, ppc64le и RISC.",
  "FormattedParseMessageExpressionPrefix": "в выражении:",
  "GetParseFailureInfo": "Используйте \"--debug\", чтобы получить дополнительные сведения о сбоях анализа.",
  "GhaBinaryCacheDeprecated": "Внутренний сервер кэширования двоичных файлов \"x-gha\" был удален. Вместо этого рассмотрите возможность использования поставщика двоичного кэширования на основе NuGet. См. дополнительную документацию в {url}.",
  "GitCommandFailed": "не удалось выполнить: {command_line}",
  "GitCommitUpdateVersionDatabase": "git commit -m \"Обновить базу данных версий\"",
  "GitFailedToFetch": "не удалось получить ссылку {value} из репозитория {url}",
  "GitFailedToInitializeLocalRepository": "не удалось инициализировать локальный репозиторий {path}",
  "GitRegistryMustHaveBaseline": "Поле реестра Git \"{url}\" должно содержать поле \"baseline\", которое является допустимым SHA фиксации Git (40 шестнадцатеричных символов).\nЧтобы использовать последние версии, задайте базовый показатель для этого репозитория HEAD, \"{commit_sha}\".",
  "GitUnexpectedCommandOutputCmd": "Git создал непредвиденные выходные данные при выполнении {command_line}",
  "GraphCycleDetected": "Обнаружен цикл в графе в {package_name}:",
  "HashPortManyFiles": "{package_name} содержит несколько файлов ({count}). Хэширование этого содержимого может занять много времени при определении хэша ABI для двоичного кэширования. Рассмотрите возможность уменьшения количества файлов. Распространенные причины: случайное извлечение исходных файлов или файлов сборки в каталог порта.",
  "HeaderOnlyUsage": "{package_name} является заголовочным и может использоваться из CMake через:",
  "HelpAssetCaching": "**Экспериментальная функция: она может быть изменена или удалена в любое время**\n\nvcpkg может использовать зеркала для кэширования скачанных ресурсов, что гарантирует продолжение операции, даже если исходный источник изменяется или исчезает.\n\nКэширование ресурсов можно настроить, задав для переменной среды X_VCPKG_ASSET_SOURCES список источников с разделителями-точками с запятой или передав последовательность параметров командной строки --x-asset-sources=<source>. Источники командной строки интерпретируются после источников среды. Запятые, точки с запятой и обратные апострофы можно экранировать с помощью обратного апострофа (`).\n\nНеобязательный параметр <rw> для определенных строк управляет способом получения к ним доступа. Для него можно указать значения \"read\", \"write\" или \"readwrite\". По умолчанию используется \"read\".\n\nДопустимые источники:",
  "HelpAssetCachingAzUrl": "Добавляет источник Хранилища BLOB-объектов Azure, используя при необходимости проверку подписанных URL-адресов. URL-адрес должен содержать путь к контейнеру и заканчиваться конечным символом \"/\". <sas>, если определен, должен иметь префикс \"?\". Серверы, отличные от Azure, также будут работать, если отвечают на запросы GET и PUT в формате \"<url><sha512><sas>\".",
  "HelpAssetCachingBlockOrigin": "Отключает возврат к исходным URL-адресам в случае, если в зеркале нет доступного файла.",
  "HelpAssetCachingScript": "Выполняет отправку во внешнее средство для получения ресурса. В шаблоне \"{{url}}\" будет заменен исходным URL-адресом, \"{{sha512}}\" будет заменен значением SHA512, а \"{{dst}}\" будет заменен выходным путем для сохранения. Все эти подстановки будут правильно экранированы оболочкой, поэтому пример шаблона будет выглядеть следующим образом: \"curl -L {{url}} --output {{dst}}\". \"{{{{\" будет заменен \"}}\", а \"}}}}\" будет заменен \"}}\" во избежание расширения. Обратите внимание, что эта операция будет выполняться в среде сборки, поэтому переменная PATH и другие переменные среды будут изменены с помощью триплета.",
  "HelpBinaryCaching": "vcpkg может кэшировать скомпилированные пакеты для ускорения восстановления на одном компьютере или в сети. По умолчанию vcpkg сохраняет сборки в кэше локального компьютера. Этот параметр можно отключить, передавая \"--binarysource=clear\" в качестве последнего параметра в командной строке.\n\nДвоичное кэширование можно дополнительно настроить, передав параметры \"--binarysource=<source>\" каждой командной строке или задав для переменной среды \"VCPKG_BINARY_SOURCES\" набор источников (пример: \"<source>;<source>;...\"). Источники командной строки интерпретируются после источников среды.\n\nНеобязательный параметр \"<rw>\" для определенных строк определяет, будут ли они использоваться для скачивания двоичных файлов, и будут ли сборки по запросу отправляться на этот удаленный сервер. Его можно указать как \"read\", \"write\" или \"readwrite\".\n\nОбщие источники:",
  "HelpBinaryCachingAws": "**Экспериментальная функция: будет изменена или удалена без предупреждения**\nДобавляет источник AWS S3. Использует aws CLI для отправки и скачивания. Префикс должен содержать схему \"s3://\" и иметь суффикс \"/\".",
  "HelpBinaryCachingAwsConfig": "**Экспериментальная функция: будет изменена или удалена без предупреждения**\nДобавляет источник AWS S3. Добавляет конфигурацию AWS. Сейчас поддерживает только параметр \"no-sign-request\", который эквивалентен параметру --no-sign-request в AWS CLI.",
  "HelpBinaryCachingAwsHeader": "Источники веб-служб Azure",
  "HelpBinaryCachingAzBlob": "**Экспериментальная функция: будет изменена или удалена без предупреждения**\nДобавляет источник Хранилища BLOB-объектов Azure. Использует проверку подписанного URL-адреса. <url> должен содержать путь к контейнеру. <sas> должен быть указан с префиксом \"?\".",
  "HelpBinaryCachingAzUpkg": "**Экспериментальная функция: будет изменена или удалена без предупреждения**\nДобавляет источник Universal Package Azure Artifacts. Использует Azure CLI (az artifacts) для отправки и скачивания.",
  "HelpBinaryCachingCos": "**Экспериментальная функция: будет изменена или удалена без предупреждения**\nДобавляет источник COS. Использует cos CLI для отправки и скачивания. <prefix> должен содержать схему \"cos://\" и иметь суффикс \"/\".",
  "HelpBinaryCachingDefaults": "Добавляет расположение на основе файла по умолчанию. В соответствии с настройками вашей системы путь по умолчанию для хранения двоичных файлов — \"{path}\". Для этого используется %LOCALAPPDATA%/%APPDATA% в Windows и $XDG_CACHE_HOME или $HOME на других платформах.",
  "HelpBinaryCachingDefaultsError": "Добавляет расположение на основе файлов по умолчанию.",
  "HelpBinaryCachingFiles": "Добавляет пользовательское расположение на основе файлов.",
  "HelpBinaryCachingGcs": "**Экспериментальная функция: будет изменена или удалена без предупреждения**\nДобавляет источник Google Cloud Storage (GCS). Использует gsutil CLI для отправки и скачивания. Префикс должен содержать схему \"gs://\" и иметь суффикс \"/\".",
  "HelpBinaryCachingHttp": "Добавляет пользовательское расположение на основе HTTP. Запросы GET, HEAD и PUT выполняются для скачивания, проверки и отправки двоичных файлов. Можно использовать переменные {{name}}, {{version}}, {{sha}} и {{triplet}}. Пример URL-адреса — \"https://cache.example.com/{{triplet}}/{{name}}/{{version}}/{{sha}}\". В поле заголовка можно задать настраиваемый заголовок для передачи маркера авторизации.",
  "HelpBinaryCachingNuGet": "Добавляет источник на основе NuGet. Эквивалент параметра \"-Source\" в NuGet CLI.",
  "HelpBinaryCachingNuGetConfig": "Добавляет источник на основе файла конфигурации NuGet. Эквивалент параметра \"-Config\" в NuGet CLI. Эта конфигурация должна указывать \"defaultPushSource\" для отправки.",
  "HelpBinaryCachingNuGetFooter": "Кэш NuGet не используется по умолчанию. Чтобы использовать его для каждого источника на основе NuGet, задайте для переменной среды \"VCPKG_USE_NUGET_CACHE\" значение \"true\" (без учета регистра) или \"1\".\nПоставщики источников \"nuget\" и \"nugetconfig\" учитывают определенные переменные среды при создании пакетов NuGet. Если соответствующие переменные среды определены и не являются пустыми, поле \"metadata.repository\" будет создано, как показано в одном из следующих примеров:",
  "HelpBinaryCachingNuGetHeader": "Источники NuGet",
  "HelpBinaryCachingNuGetInteractive": "Включает интерактивное управление учетными данными NuGet. Противоположность параметра \"-NonInteractive\" в NuGet CLI.",
  "HelpBinaryCachingNuGetTimeout": "Указывает время ожидания NuGet для сетевых операций NuGet. Эквивалент параметра \"-Timeout\" в NuGet CLI.",
  "HelpBuiltinBase": "Базовый план ссылается на фиксацию в репозитории vcpkg, устанавливающую минимальную версию для каждой зависимости в графе. Например, если никакие другие ограничения не указаны (напрямую или транзитивно), версия будет разрешаться в базовый план манифеста верхнего уровня. Базовые линии транзитивных зависимостей игнорируются.",
  "HelpCachingClear": "Удаляет все предыдущие источники, включая значения по умолчанию.",
  "HelpContactCommand": "Отображает контактные данные для отправки отзыва",
  "HelpCreateCommand": "Создает новый порт",
  "HelpDependInfoCommand": "Отображает список зависимостей для портов",
  "HelpEditCommand": "Изменяет порт, при необходимости с {env_var}, по умолчанию — \"code\"",
  "HelpEnvCommand": "Создает среду чистой оболочки для разработки или компиляции",
  "HelpExampleCommand": "Дополнительные сведения (включая примеры) см. на странице https://learn.microsoft.com/vcpkg",
  "HelpExampleManifest": "Пример манифеста:",
  "HelpInstallCommand": "Устанавливает пакет",
  "HelpManifestConstraints": "Манифесты могут накладывать три типа ограничений на используемые версии.",
  "HelpMinVersion": "Vcpkg выберет минимальную найденную версию, соответствующую всем применимым ограничениям, включая версию из базовой линии, указанной на верхнем уровне, а также любые ограничения \"version>=\" в графе.",
  "HelpOverrides": "При использовании в качестве манифеста верхнего уровня (например, при запуске \"vcpkg install\" в каталоге) переопределения позволяют манифесту сократить разрешение зависимостей и точно указать используемую версию. Их можно использовать для обработки конфликтов версий, например, с зависимостями \"version-string\". Они не будут рассматриваться, когда от них зависит транзитивно.",
  "HelpOwnsCommand": "Выполняет поиск владельца файла в установленных пакетах",
  "HelpPackagePublisher": "Кроме того, издатели пакетов могут использовать ограничения \"version>=\" для обеспечения использования потребителями хотя бы некоторой минимальной версии данной зависимости. Например, если библиотеке требуется API, добавленный в boost-asio в версии 1.70, ограничение \"version>=\" гарантирует, что переходные пользователи будут использовать достаточную версию даже при переопределении отдельных версий или перекрестных ссылках реестра.",
  "HelpPortVersionScheme": "Каждая версия дополнительно содержит \"версию порта\", представляющую собой неотрицательное целое число. При отображении в виде текста версия порта (если она не равна нулю) добавляется как суффикс к тексту основной версии, разделенному решеткой (#). Версии порта сортируются лексикографически после текста основной версии, например:\n1.0.0 < 1.0.0#1 < 1.0.1 < 1.0.1#5 < 2.0.0",
  "HelpRemoveCommand": "Удаляет пакет",
  "HelpResponseFileCommand": "Содержит один аргумент на строку, развернутую в этом расположении",
  "HelpSearchCommand": "Выполняет поиск пакетов, доступных для сборки",
  "HelpTextOptFullDesc": "Не обрезает длинный текст",
  "HelpTopicCommand": "Отображает конкретный раздел справки",
  "HelpTopicsCommand": "Отображает полный список разделов справки",
  "HelpTxtOptAllowUnsupportedPort": "Продолжает с предупреждением о неподдерживаемых портах вместо сбоя",
  "HelpTxtOptCleanAfterBuild": "Очищает деревья сборки, пакеты и загрузки после сборки каждого пакета",
  "HelpTxtOptCleanBuildTreesAfterBuild": "Очищает деревья сборки после сборки каждого пакета.",
  "HelpTxtOptCleanDownloadsAfterBuild": "Очищает загрузки после сборки каждого пакета",
  "HelpTxtOptCleanPkgAfterBuild": "Очищает пакеты после сборки каждого пакета",
  "HelpTxtOptDryRun": "Фактически не выполняет сборку и установку",
  "HelpTxtOptEditable": "Отключает повторное извлечение исходного кода и двоичное кэширование библиотек в командной строке (классический режим)",
  "HelpTxtOptEnforcePortChecks": "Завершает установку сбоем, если порт обнаруживает проблемы или пытается использовать нерекомендуемую функцию.",
  "HelpTxtOptKeepGoing": "Продолжить установку пакетов в случае сбоя",
  "HelpTxtOptManifestFeature": "Дополнительные функции из манифеста верхнего уровня для установки (режим манифеста)",
  "HelpTxtOptManifestNoDefault": "Не устанавливает функции по умолчанию из манифеста верхнего уровня (режим манифеста).",
  "HelpTxtOptNoDownloads": "Не скачивает новые исходники",
  "HelpTxtOptNoUsage": "Не распечатывает сведения об использовании CMake после установки",
  "HelpTxtOptOnlyBinCache": "Завершает работу сбоем, если кэшированные двоичные файлы недоступны.",
  "HelpTxtOptOnlyDownloads": "Делает все возможное, чтобы скачать исходники без сборки",
  "HelpTxtOptRecurse": "Разрешает удалять пакеты в рамках установки.",
  "HelpTxtOptUseHeadVersion": "Устанавливает библиотеки из командной строки, используя последние исходные коды (классический режим).",
  "HelpTxtOptWritePkgConfig": "Записывает файл в формате NuGet packages.config для использования с внешним двоичным кэшированием. Дополнительные сведения см. в `vcpkg helpbinarcaching`.",
  "HelpUpdateBaseline": "Лучший способ поддержания библиотек в актуальном состоянии — обновление базового эталона. Это обеспечит обновление всех пакетов, включая транзитивные. Но если вам нужно обновить пакет независимо, вы можете использовать ограничение \"version>=\".",
  "HelpUpdateCommand": "Перечисляет пакеты, которые можно обновить",
  "HelpUpgradeCommand": "Перестраивает все устаревшие пакеты",
  "HelpVersionCommand": "Отображает сведения о версии",
  "HelpVersionDateScheme": "Дата (2021-01-01.5)",
  "HelpVersionGreater": "В поле \"зависимости\" для каждой зависимости может быть указано минимальное ограничение. Эти минимальные ограничения будут использоваться при транзитивной зависимости от этой библиотеки. Минимальная версия порта может быть дополнительно указана с суффиксом \"#\".",
  "HelpVersionScheme": "Последовательность чисел, разделенных точками (1.2.3.4)",
  "HelpVersionSchemes": "Принимаются следующие схемы управления версиями.",
  "HelpVersionSemverScheme": "Семантическая версия 2.0 (2.1.0-rc2)",
  "HelpVersionStringScheme": "Точная несовместимая версия (Vista)",
  "HelpVersioning": "Управление версиями позволяет вам детерминированно управлять точными версиями зависимостей, используемых вашим проектом, из своего файла манифеста.",
  "IgnoringVcpkgRootEnvironment": "vcpkg {value} использует обнаруженный корень vcpkg {actual} и пропускает несовпадающее значение среды VCPKG_ROOT {path}. Чтобы скрыть это сообщение, удалите переменную среды или воспользуйтесь переключателем командной строки --vcpkg-root.",
  "IllegalFeatures": "Список функций не разрешен в этом контексте",
  "IllegalPlatformSpec": "Квалификатор платформы не разрешен в этом контексте",
  "ImproperShaLength": "Длина SHA512 должна составлять 128 шестнадцатеричных символов: {value}",
  "IncorrectArchiveFileSignature": "Неверная подпись файла архива",
  "InfoSetEnvVar": "Вы также можете установить {env_var} в свой редактор.",
  "InitRegistryFailedNoRepo": "Не удалось создать реестр в {path}: это не корневой каталог репозитория Git.\nИспользуйте команду \"git init {command_line}\", чтобы создать репозиторий Git в этой папке.",
  "InstallCopiedFile": "{path_source} -> {path_destination}: готово",
  "InstallFailed": "сбой: {path}: {error_msg}",
  "InstallPackageInstruction": "Открыв проект, перейдите в Инструменты->Диспетчер пакетов NuGet->Консоль диспетчера пакетов и вставьте:\n Install-Package \"{value}\" -Source \"{path}\"",
  "InstallRootDir": "Каталог Installed (экспериментальная функция)",
  "InstallSkippedUpToDateFile": "{path_source} -> {path_destination}: пропущено, обновлено",
  "InstallWithSystemManager": "Этот инструмент можно установить с помощью системного диспетчера пакетов.",
  "InstallWithSystemManagerMono": "Пользователям Ubuntu 18.04 может потребоваться более новая версия Mono, доступная по адресу {url}.",
  "InstallWithSystemManagerPkg": "Этот инструмент можно установить с помощью диспетчера системных пакетов ({command_line}).",
  "InstalledBy": "Установлено посредством {path}",
  "InstalledPackages": "Следующие пакеты уже установлены:",
  "InstalledPackagesHead": "Следующие пакеты уже установлены, но были запрошены в версии --head. Их установленное содержимое не будет изменено. Чтобы получить обновленные версии, сначала удалите следующие пакеты:",
  "InstalledRequestedPackages": "Все запрашиваемые пакеты сейчас установлены.",
  "InstallingFromFilesystemRegistry": "установка из реестра файловой системы здесь",
  "InstallingFromGitRegistry": "установка из реестра Git",
  "InstallingOverlayPort": "производится установка порта наложения отсюда",
  "InstallingPackage": "Выполняется установка {action_index}/{count} {spec}…",
  "IntegrateBashHelp": "Включить завершение табуляции bash. Только для систем, отличных от Windows",
  "IntegrateFishHelp": "Включить завершение табуляции fish. Только для систем, отличных от Windows.",
  "IntegrateInstallHelpLinux": "Делает установленные пакеты доступными на уровне пользователя.",
  "IntegrateInstallHelpWindows": "Делает установленные пакеты доступными на уровне пользователя. Требуются права администратора при первом использовании",
  "IntegrateNonWindowsOnly": "{command_line} используется только для систем, отличных от Windows, и не поддерживается в этой системе.",
  "IntegratePowerShellHelp": "Включите заполнение табуляции Windows PowerShell. Только для Windows",
  "IntegrateProjectHelp": "Создает ссылочный пакет NuGet для использования в отдельном проекте Visual Studio. Только для Windows.",
  "IntegrateRemoveHelp": "Удаляет интеграцию на уровне пользователя",
  "IntegrateWindowsOnly": "{command_line} используется только для Windows и не поддерживается в этой системе.",
  "IntegrateZshHelp": "Включить завершение табуляции zsh. Только для систем, отличных от Windows",
  "IntegrationFailedVS2015": "Интеграция не была применена для Visual Studio 2015.",
  "InternalCICommand": "vcpkg ci — внутренняя команда, она может измениться несовместимым образом или может быть удалена в любое время.",
  "InternalErrorMessageContact": "Откройте проблему на странице https://github.com/microsoft/vcpkg/issues/new?template=other-type-of-bug-report.md&labels=category:vcpkg-bug с подробными инструкциями по ее воспроизведению.",
  "InvalidArchitectureValue": "Недопустимая архитектура: {value}. Ожидается одно из следующих: {expected}",
  "InvalidArgument": "недопустимый аргумент.",
  "InvalidArgumentRequiresAbsolutePath": "недопустимый аргумент: аргументы пути двоичной config \"{binary_source}\" для двоичных строк config должны быть абсолютными",
  "InvalidArgumentRequiresBaseUrl": "недопустимый аргумент: для двоичной config \"{binary_source}\" в качестве первого аргумента требуется базовый URL-адрес {base_url}",
  "InvalidArgumentRequiresBaseUrlAndToken": "недопустимый аргумент: для двоичной config \"{binary_source}\" требуется по крайней мере базовый URL-адрес и маркер SAS",
  "InvalidArgumentRequiresFourOrFiveArguments": "недопустимый аргумент: для двоичной конфигурации \"{binary_source}\" требуется 4 или 5 аргументов",
  "InvalidArgumentRequiresNoWildcards": "не удается исправить регистр пути Windows для пути, содержащего подстановочные знаки: {path}",
  "InvalidArgumentRequiresNoneArguments": "недопустимый аргумент: двоичная config \"{binary_source}\" не принимает аргументы",
  "InvalidArgumentRequiresOneOrTwoArguments": "недопустимый аргумент: для двоичной config \"{binary_source}\" требуется 1 или 2 аргумента",
  "InvalidArgumentRequiresPathArgument": "недопустимый аргумент: двоичная конфигурация '{binary_source}' требует по крайней мере один аргумент пути",
  "InvalidArgumentRequiresPrefix": "недопустимый аргумент: двоичная конфигурация '{binary_source}' требует по крайней мере один префикс",
  "InvalidArgumentRequiresSingleArgument": "недопустимый аргумент: двоичная config \"{binary_source}\" не принимает более 1 аргумента",
  "InvalidArgumentRequiresSingleStringArgument": "недопустимый аргумент: двоичная config \"{binary_source}\" ожидает однострочного аргумента",
  "InvalidArgumentRequiresSourceArgument": "недопустимый аргумент: двоичная конфигурация '{binary_source}' требует по крайней мере один исходный аргумент",
  "InvalidArgumentRequiresTwoOrThreeArguments": "недопустимый аргумент: для двоичной config \"{binary_source}\" требуется 2 или 3 аргумента",
  "InvalidArgumentRequiresValidToken": "недопустимый аргумент: для двоичной config \"{binary_source}\" требуется маркер SAS без предварительного значения \"?\" в качестве второго аргумента",
  "InvalidBuildInfo": "Недопустимый файл BUILD_INFO для пакета: {error_msg}",
  "InvalidBuiltInBaseline": "встроенный базовый план верхнего уровня ({value}) не является допустимым SHA фиксации: ожидалось 40 шестнадцатеричных символов.",
  "InvalidBundleDefinition": "Недопустимое определение пакета.",
  "InvalidCharacterInFeatureList": "недопустимый символ в имени функции (должен содержать строчные буквы, цифры, символы \"-\" или \"*\")",
  "InvalidCharacterInFeatureName": "недопустимый символ в имени функции (должен содержать строчные буквы, цифры, символы \"-\")",
  "InvalidCharacterInPortName": "недопустимый символ в имени порта (разрешаются только строчные буквы, цифры и дефисы \"-\")",
  "InvalidCodePoint": "Недопустимая кодовая точка передана в utf8_encoded_code_point_count",
  "InvalidCodeUnit": "недопустимая кодовая единица",
  "InvalidCommandArgSort": "Значением --sort должен быть один из следующих вариантов: \"lexicographical\", \"topographical\", \"reverse\".",
  "InvalidCommentStyle": "vcpkg не поддерживает комментарии в стиле C, однако большинство объектов позволяют использовать в качестве комментариев поля с префиксом $.",
  "InvalidCommitId": "Недопустимый ИД фиксации: {commit_sha}",
  "InvalidDefaultFeatureName": "\"default\" является зарезервированным именем функции",
  "InvalidFeature": "для функций должны использоваться строчные буквы, цифры и дефисы, а не одно из зарезервированных имен",
  "InvalidFileType": "сбой: {path} не может обработать тип файла",
  "InvalidFilename": "Имя файла не может содержать недопустимые символы {value}, но использовалось имя {path}",
  "InvalidFloatingPointConst": "Недопустимые константы с плавающей точкой: {count}",
  "InvalidFormatString": "Недопустимая строка формата: {actual}",
  "InvalidHexDigit": "Недопустимая шестнадцатеричная цифра в escape-коде Юникода",
  "InvalidIntegerConst": "Недопустимая целая константа: {count}",
  "InvalidLibraryMissingLinkerMembers": "Недопустимая библиотека: не удалось найти элемент компоновщика.",
  "InvalidLinkage": "Недопустимый тип связи {system_name}: [{value}]",
  "InvalidLogicExpressionUnexpectedCharacter": "недопустимое логическое выражение, непредвиденный символ",
  "InvalidLogicExpressionUsePipe": "недопустимое логическое выражение, используйте \"|\", а не \"или\"",
  "InvalidOptionForRemove": "\"remove\" принимает библиотеки или \"--outdated\"",
  "InvalidPortVersonName": "Обнаружено недопустимое имя файла версии порта: \"{path}\".",
  "InvalidSha512": "недопустимый хэш SHA-512: {sha}\nХэш SHA-512 должен содержать 128 символов и содержать только шестнадцатеричные цифры",
  "InvalidSharpInVersion": "недопустимый символ \"#\" в тексте версии",
  "InvalidSharpInVersionDidYouMean": "недопустимый символ \"#\" в тексте версии. Вы имели в виду \"port-version\": {value}?",
  "InvalidString": "Недопустимый utf8 передается значению Value::string(std::string)",
  "InvalidToolOSValue": "Недопустимая операционная система средства: {value}. Ожидается одно из следующих: {expected}",
  "InvalidToolVersion": "Недопустимая версия средства; требуется строка, содержащая подстроку от 1 до 3 чисел, разделенных точками.",
  "InvalidTriplet": "Недопустимая триада: {triplet}",
  "InvalidUri": "не удалось проанализировать URI: {value}",
  "InvalidValueHashAdditionalFiles": "Переменная VCPKG_HASH_ADDITIONAL_FILES содержит недопустимый путь к файлу: \"{path}\". Значение должно быть абсолютным путем к существующему файлу.",
  "InvalidValuePostPortfileIncludes": "Переменная VCPKG_POST_PORTFILE_INCLUDES содержит недопустимый путь к файлу: \"{path}\". Значение должно быть абсолютным путем к существующему файлу cmake.",
  "IrregularFile": "путь не является обычным файлом: {path}",
  "JsonErrorMustBeAnObject": "Ожидается, что \"{path}\" будет объектом.",
  "JsonFieldNotObject": "значение [\"{json_field}\"] должно быть объектом",
  "JsonFieldNotString": "значение [\"{json_field}\"] должно быть строкой",
  "JsonFileMissingExtension": "файл JSON {path} должен иметь расширение .json (все строчные буквы)",
  "JsonSwitch": "Печатает JSON вместо обычного текста",
  "JsonValueNotArray": "значение json не является массивом",
  "JsonValueNotObject": "Значение JSON не является объектом",
  "JsonValueNotString": "значение json не является строкой",
  "LaunchingProgramFailed": "Запуск средства {tool_name}:",
  "LibraryArchiveMemberTooSmall": "Архивный элемент библиотеки был слишком мал, чтобы содержать ожидаемый тип данных.",
  "LibraryFirstLinkerMemberMissing": "Не удалось найти имя первого элемента компоновщика.",
  "LicenseExpressionContainsExtraPlus": "Выражение лицензии SPDX содержит дополнительный знак \"+\". Они разрешены только непосредственно после идентификатора лицензии.",
  "LicenseExpressionContainsInvalidCharacter": "Выражение лицензии SPDX содержит недопустимый символ (0x{value:02X} '{value}').",
  "LicenseExpressionContainsUnicode": "Выражение лицензии SPDX содержит символ Юникода (U+{value:04X} '{pretty_value}'), но эти выражения предназначены только для ASCII.",
  "LicenseExpressionDocumentRefUnsupported": "Текущая реализация не поддерживает ссылки DocumentRef-SPDX.",
  "LicenseExpressionExpectCompoundFoundParen": "Ожидался составной элемент или конец строки, обнаружена круглая скобка.",
  "LicenseExpressionExpectCompoundFoundWith": "Ожидается либо AND, либо OR, найдено WITH (WITH допускается только после имен лицензий, а не выражений в скобках).",
  "LicenseExpressionExpectCompoundFoundWord": "Ожидается операция AND или OR, обнаружена лицензия или имя исключения: \"{value}\".",
  "LicenseExpressionExpectCompoundOrWithFoundWord": "Ожидается операция AND, OR или WITH, обнаружена лицензия или имя исключения: \"{value}\".",
  "LicenseExpressionExpectExceptionFoundCompound": "Ожидалось имя исключения, обнаружено составное {value}.",
  "LicenseExpressionExpectExceptionFoundEof": "Ожидалось имя исключения, обнаружен конец строки.",
  "LicenseExpressionExpectExceptionFoundParen": "Ожидалось имя исключения, обнаружена скобка.",
  "LicenseExpressionExpectLicenseFoundCompound": "Ожидалось имя лицензии, обнаружено составное {value}.",
  "LicenseExpressionExpectLicenseFoundEof": "Ожидалось имя лицензии, обнаружен конец строки.",
  "LicenseExpressionImbalancedParens": "Закрывающая круглая скобка без открывающей скобки.",
  "LicenseExpressionString": "<license string>",
  "LicenseExpressionUnknownException": "Неизвестный идентификатор исключения лицензии \"{value}\". Известные значения перечислены по ссылке https://spdx.org/licenses/exceptions-index.html",
  "LicenseExpressionUnknownLicense": "Неизвестный идентификатор лицензии \"{value}\". Известные значения перечислены по адресу https://spdx.org/licenses/",
  "LinkageDynamicDebug": "Динамическая отладка (/MDD)",
  "LinkageDynamicRelease": "Динамический выпуск (/MD)",
  "LinkageStaticDebug": "Статическая отладка (/MTd)",
  "LinkageStaticRelease": "Статический выпуск (/MT)",
  "ListHelp": "Перечисляет установленные библиотеки",
  "LoadedCommunityTriplet": "загружен отсюда триплет сообщества. Триплеты сообщества не встроены в курируемый реестр, поэтому вероятность их беспроблемной работы несколько ниже.",
  "LoadedOverlayTriplet": "загружен отсюда триплет наложения",
  "LoadingDependencyInformation": "Загрузка сведений о зависимостях для пакетов {count}...",
  "LocalPortfileVersion": "Использование локальных версий порта. Чтобы обновить локальные порты, используйте \"git pull\".",
  "ManifestConflict2": "Обнаружен файл манифеста и файл CONTROL. Переименуйте один из них",
  "ManifestFormatCompleted": "Файлы манифеста отформатированы успешно.",
  "ManifestHere": "файл манифеста находится здесь",
  "MismatchedBinParagraphs": "Абзац сериализованного двоичного файла отличался от абзаца исходного двоичного файла. Откройте проблему на странице https://github.com/microsoft/vcpkg со следующими выходными данными:",
  "MismatchedFiles": "файл для хранения не соответствует хэшу",
  "MismatchedManifestAfterReserialize": "Сериализованный манифест отличался от исходного манифеста. Откройте проблему на странице https://github.com/microsoft/vcpkg со следующими выходными данными:",
  "MismatchedNames": "имя порта, объявленное в файле метаданных, не соответствует каталогу. Ожидался порт с именем {package_name}, но файл объявляет {actual}.",
  "MismatchedSpec": "Несоответствие спецификации в порту {path}: ожидается {expected}, фактический {actual}",
  "MismatchedType": "{json_field}: несоответствующий тип: ожидается {json_type}",
  "Missing7zHeader": "Не удалось найти заголовок 7z.",
  "MissingArgFormatManifest": "манифест формата был передан --convert-control без '--all'.\nЭто ничего не делает: явно переданные управляющие файлы преобразуются автоматически.",
  "MissingClosingParen": "отсутствует закрывающая скобка )",
  "MissingDependency": "Пакет {spec} установлен, но зависимость {package_name} не установлена.",
  "MissingExtension": "Отсутствует расширение \"{extension}\".",
  "MissingOption": "Для этой команды требуется --{option}",
  "MissingOrInvalidIdentifer": "идентификатор отсутствует или недопустим",
  "MissingPortSuggestPullRequest": "Если вашего порта нет в списке, откройте вопрос и рассмотрите возможность размещения запроса на вытягивание.",
  "MissingRequiredField": "отсутствует обязательное поле \"{json_field}\" ({json_type})",
  "MissingRequiredField2": "отсутствует обязательное поле \"{json_field}\"",
  "MissingShaVariable": "Если используются другие переменные, в шаблоне должна применяться переменная {{sha}}.",
  "MixingBooleanOperationsNotAllowed": "смешивание & и | не разрешено; используйте () для указания порядка операций",
  "MonoInstructions": "Это может быть вызвано неполной установкой Mono. Полная версия Mono доступна в некоторых системах по команде \"sudo apt install mono-complete\". Пользователям Ubuntu 18.04 может потребоваться более новая версия Mono, доступная по адресу https://www.mono-project.com/download/stable/",
  "MultiArch": "Значение Multi-Arch должно быть \"то же\", но было {option}",
  "MultipleFeatures": "{package_name} объявляет {feature} несколько раз. Убедитесь, что функции имеют уникальные имена",
  "MutuallyExclusiveOption": "--{value} не может использоваться с --{option}.",
  "MutuallyExclusivePorts": "--{option} нельзя использовать явно именованные порты.",
  "NewConfigurationAlreadyExists": "При создании манифеста файл vcpkg-configuration.json по адресу {path} будет перезаписан.",
  "NewManifestAlreadyExists": "Манифест уже присутствует в {path}.",
  "NewNameCannotBeEmpty": "--name не может быть пустым.",
  "NewOnlyOneVersionKind": "Можно указать только одно из --version-relaxed, --version-date или --version-string.",
  "NewSpecifyNameVersionOrApplication": "Чтобы указать, что манифест не предназначен для использования в качестве порта, определите --name и --version для создания манифеста, предназначенного для библиотек C++, или укажите --application.",
  "NewVersionCannotBeEmpty": "--version не может быть пустой.",
  "NoCoreFeatureAllowedInNonFailBaselineEntry": "\"core\" не допускается в списке функций, если запись относится к типу \"{value}\"",
  "NoEntryWithName": "Не найдена запись с именем \"{value}\" и URL-адресом.",
  "NoError": "нет ошибок",
  "NoInstalledPackages": "Нет установленных пакетов. Вы имели в виду \"search\"?",
  "NoInstalledPackagesLicenseReport": "Нет установленных пакетов, поэтому отсутствуют лицензии установленных пакетов. Нужно было сначала что-то установить?",
  "NoOutdatedPackages": "Нет устаревших пакетов.",
  "NoRegistryForPort": "Не настроен реестр для порта {package_name}.",
  "NoUrlsAndNoHashSpecified": "URL-адреса и хэш не указаны.",
  "NonExactlyArgs": "команда \"{command_name}\" требует ровно {expected} аргументов, но указано {actual}",
  "NonOneRemainingArgs": "команда \"{command_name}\" требует ровно один аргумент",
  "NonRangeArgs": "команда \"{command_name}\" требует от {lower} до {upper} аргументов включительно, но указано {actual}",
  "NonRangeArgsGreater": "команда \"{command_name}\" требует не менее {lower} аргументов, но указано {actual}",
  "NonZeroOrOneRemainingArgs": "команда \"{command_name}\" требует ноль аргументов или один аргумент",
  "NonZeroRemainingArgs": "команда \"{command_name}\" не принимает дополнительные аргументы",
  "NugetOutputNotCapturedBecauseInteractiveSpecified": "Не удалось выполнить команду NuGet, и выходные данные не записаны, поскольку указан параметр --interactive",
  "NugetPackageFileSucceededButCreationFailed": "Создание пакета NuGet выполнено успешно, но .nupkg не создан. Ожидается: \"{path}\"",
  "NugetTimeoutExpectsSinglePositiveInteger": "непредвиденные аргументы: двоичная конфигурация \"nugettimeout\" ожидает один положительный целочисленный аргумент",
  "OnlySupports": "{feature_spec} поддерживает только {supports_expression}",
  "OptionMustBeInteger": "Значение --{option} должно быть целым числом.",
  "OptionRequiresANonDashesValue": "параметр \"{option}\" требует значения; если вы хотели настроить для \"{option}\" значение \"{value}\", используйте вместо этого форму равенства: {actual}={value}",
  "OptionRequiresAValue": "параметр \"{option}\" требует значения",
  "OptionRequiresOption": "Для значения --{value} требуется --{option}",
  "OptionUsedMultipleTimes": "параметр \"{option}\" указан несколько раз",
  "Options": "Параметры",
  "OriginalBinParagraphHeader": "\nАбзац исходного двоичного файла",
  "OtherCommandsHeader": "Другое",
  "OverlayPatchDir": "Путь наложения \"{path}\" должен быть существующим каталогом.",
  "OverlayPortsHelp": "Каталоги наложения портов или каталоги, содержащие каталоги наложения портов (также: {env_var})",
  "OverlayTripletDirectoriesHelp": "Каталоги триплетов наложения (также: {env_var})",
  "OverlayTriplets": "Триплеты наложения из \"{path}\":",
  "OverwritingFile": "Файл {path} уже существует и будет перезаписан",
  "PECoffHeaderTooShort": "При синтаксическом анализе переносимого исполняемого файла {путь} размер заголовка COFF слишком мал для того, чтобы содержать действительный заголовок PE.",
  "PEConfigCrossesSectionBoundary": "При синтаксическом анализе переносимого исполняемого файла {path} каталог конфигурации образа пересекает границу раздела.",
  "PEImportCrossesSectionBoundary": "При синтаксическом анализе переносимого исполняемого файла {path} таблица импорта пересекает границу раздела.",
  "PEPlusTagInvalid": "При синтаксическом анализе Portable Executable {path} необязательный заголовок не был ни PE32, ни PE32+.",
  "PERvaNotFound": "При синтаксическом анализе Portable Executable {path} не удалось найти RVA {value:#X}.",
  "PackageAbi": "{spec} ABI пакета: {package_abi}",
  "PackageAlreadyRemoved": "не удается удалить {spec}: уже удалено",
  "PackageDiscoveryHeader": "Обнаружение пакета",
  "PackageFailedtWhileExtracting": "Сбой \"{value}\" при извлечении {path}.",
  "PackageInfoHelp": "Отобразить подробные сведения о пакетах",
  "PackageInstallationHeader": "Установка пакета",
  "PackageLicenseSpdx": "В установленных пакетах объявлены следующие лицензии:",
  "PackageLicenseSpdxThisInstall": "В пакетах, установленных в этой установке vcpkg, объявлены следующие лицензии:",
  "PackageLicenseUnknown": "В некоторых пакетах не объявлена лицензия SPDX. Для получения дополнительной информации о лицензировании проверьте файл \"copyright\" для каждого пакета.",
  "PackageLicenseWarning": "Установленные содержимое предоставляется вам по лицензии владельцами этого содержимого. Корпорация Майкрософт не несет ответственности за пакеты сторонних производителей и не предоставляет лицензии на такие пакеты.",
  "PackageManipulationHeader": "Обработка пакета",
  "PackageRootDir": "Каталог Packages (экспериментальная функция)",
  "PackagesToInstall": "Будут собраны и установлены следующие пакеты:",
  "PackagesToModify": "Дополнительные пакеты (*) будут изменены для завершения этой операции.",
  "PackagesToRebuild": "Будут повторно собраны следующие пакеты:",
  "PackagesToRebuildSuggestRecurse": "Если вы действительно хотите повторно собрать перечисленные выше пакеты, запустите команду с параметром --recurse.",
  "PackagesToRemove": "Будут удалены следующие пакеты:",
  "PackagesUpToDate": "Нет пакетов, которые требуется обновить.",
  "PackingVendorFailed": "Сбой упаковки {vendor}. Используйте --debug для получения дополнительной информации.",
  "PairedSurrogatesAreInvalid": "конечный суррогат, следующий за ведущим суррогатом (парные суррогаты недействительны)",
  "ParagraphDuplicateField": "повторяющееся поле",
  "ParagraphExactlyOne": "Должен быть только один абзац",
  "ParagraphExpectedColonAfterField": "требуется \":\" после имени поля",
  "ParagraphExpectedFieldName": "ожидаемое имя поля",
  "ParagraphUnexpectedEndOfLine": "непредвиденный конец строки, чтобы заполнить пустую строку, используйте \"  .\"",
  "ParseFeatureNameError": "\"{package_name}\" не является допустимым именем компонента. Имена функций должны состоять из строчных букв, цифр и дефисов и не быть зарезервированными (для получения дополнительной информации см. {url}).",
  "ParseIdentifierError": "\"{value}\" не является допустимым идентификатором. Идентификаторы должны содержать строчные буквы, цифры и дефисы и не должны быть зарезервированы (см. {url} для получения дополнительных сведений).",
  "ParsePackageNameError": "\"{package_name}\" не является допустимым именем пакета. Имена пакетов должны состоять из строчных букв, цифр и дефисов и не быть зарезервированными (для получения дополнительной информации см. {url}).",
  "ParsePackageNameNotEof": "ожидался конец ввода при анализе имени пакета; обычно это означает, что имя порта не может содержать указанный символ. Имена портов могут содержать только строчные буквы, цифры и дефисы и не должны быть зарезервированы (подробнее см. {url}).",
  "ParsePackagePatternError": "\"{package_name}\" не является допустимым шаблоном пакета. Шаблоны пакетов должны использовать только один подстановочный знак (*), который должен быть последним символом в шаблоне (см. {url} для получения дополнительных сведений).",
  "ParseQualifiedSpecifierNotEof": "ожидался конец ввода при анализе спецификации пакета; обычно это означает, что спецификация пакета не может содержать указанный символ. Имена портов, триплетов и функций могут содержать строчные буквы, цифры и дефисы.",
  "ParseQualifiedSpecifierNotEofSquareBracket": "ожидался конец ввода при анализе спецификации пакета; может быть, вы хотели вместо этого указать {version_spec}?",
  "ParseTripletNotEof": "Недопустимое имя триады. Все имена триад состоят из строчных букв, цифр и дефисов.",
  "PathMustBeAbsolute": "Значение переменной среды X_VCPKG_REGISTRIES_CACHE не является абсолютным: {path}",
  "PerformingPostBuildValidation": "Выполнение проверки после сборки",
  "PortBugBinDirExists": "${{CURRENT_PACKAGES_DIR}}/{path} существует, но не должен находиться в статической сборке. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_DLLS_IN_STATIC_LIBRARY enabled)",
  "PortBugDebugShareDir": "${{CURRENT_PACKAGES_DIR}}/debug/share не должно существовать. Переупорядочите все важные файлы, а затем удалите все оставшиеся, добавив \"file(REMOVE_RECURSE \"${{CURRENT_PACKAGES_DIR}}/debug/share\")\". Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_ALLOW_DEBUG_SHARE enabled)",
  "PortBugDllAppContainerBitNotSet": "Бит приложения-контейнера должен быть установлен для всех библиотек DLL в приложениях Windows Store и запросов триплетов, нацеленных на Windows Store, но следующие библиотеки DLL не созданы с установленным битом. Обычно это означает, что флажки компоновщика цепочки инструментов не распространяются должным образом или используемый компоновщик не поддерживает переход /APPCONTAINER. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_APPCONTAINER_CHECK enabled)",
  "PortBugDllInLibDir": "Следующие библиотеки DLL были найдены в ${{CURRENT_PACKAGES_DIR}}/lib или ${{CURRENT_PACKAGES_DIR}}/debug/lib. Переместите их в ${{CURRENT_PACKAGES_DIR}}/bin или ${{CURRENT_PACKAGES_DIR}}/debug/bin соответственно.",
  "PortBugDuplicateIncludeFiles": "${{CURRENT_PACKAGES_DIR}}/debug/include не должно существовать. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_ALLOW_DEBUG_INCLUDE enabled)",
  "PortBugDuplicateIncludeFilesFixIt": "Если этот каталог создан системой сборки, не позволяющей отключить установку заголовков в отладке, удалите дубликат каталога с file(REMOVE_RECURSE \"${{CURRENT_PACKAGES_DIR}}/debug/include\")",
  "PortBugFoundCopyrightFiles": "следующие файлы могут являться файлами авторских прав",
  "PortBugFoundDebugBinaries": "Ниже приведены двоичные файлы отладки:",
  "PortBugFoundDllInStaticBuild": "Хотя библиотеки DLL не должны присутствовать в статической сборке, найдены следующие библиотеки DLL. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_DLLS_IN_STATIC_LIBRARY enabled)",
  "PortBugFoundEmptyDirectories": "Не должно быть установленных пустых каталогов. Пустые каталоги не могут быть представлены нескольким поставщикам двоичного кэша, репозиториям Git и не считаются выходными данными семантической сборки. Следует создать обычный файл в каждом пустом каталоге или удалить их с помощью следующего CMake. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_ALLOW_EMPTY_FOLDERS enabled)",
  "PortBugFoundExeInBinDir": "Следующие исполняемые файлы найдены в ${{CURRENT_PACKAGES_DIR}}/bin or ${{CURRENT_PACKAGES_DIR}}/debug/bin. Исполняемые файлы не являются допустимыми целями распространения. Если эти исполняемые файлы являются инструментами сборки, рассмотрите возможность использования vcpkg_copy_tools. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_ALLOW_EXES_IN_BIN enabled)",
  "PortBugFoundReleaseBinaries": "Ниже приведены двоичные файлы выпуска:",
  "PortBugIncludeDirInCMakeHelperPort": "Папка ${{CURRENT_PACKAGES_DIR}}/include существует во вспомогательном порте CMake; это неправильно, поскольку следует устанавливать только файлы CMake. Чтобы скрыть это сообщение, удалите set(VCPKG_POLICY_CMAKE_HELPER_PORT enabled).",
  "PortBugInvalidCrtLinkageCrtGroup": "Следующие двоичные файлы должны связываться только с: {expected}",
  "PortBugInvalidCrtLinkageEntry": "{path} связывается с: {actual}",
  "PortBugInvalidCrtLinkageHeader": "двоичные файлы, созданные по этому порту с помощью C RunTimes (\"CRT\"), несовместимы с теми, которые запрошены триплетом и структурой развертывания. Если триплет предназначен для использования только версии CRT, следует добавить set(VCPKG_POLICY_ONLY_RELEASE_CRT enabled) в файл .cmake триплета. Чтобы полностью скрыть эту проверку, добавьте set(VCPKG_POLICY_SKIP_CRT_LINKAGE_CHECK enabled) к триплету .cmake, если он распространяется на весь триплет, или к portfile.cmake, если это специфично для порта. Вы можете проверить двоичные файлы с помощью: dumpbin.exe /directives mylibfile.lib.",
  "PortBugKernel32FromXbox": "Выбранный триплет нацелен на Xbox, но следующие библиотеки DLL связаны с kernel32. Эти библиотеки DLL нельзя загрузить на Xbox, где отсутствует kernel32. Обычно это вызвано связыванием с kernel32.lib, а не с подходящей зонтичной библиотекой, такой как onecore_apiset.lib или xgameplatform.lib. Зависимости DLL можно проверить с помощью \"dumpbin.exe/dependents mylibfile.dll\". Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_ALLOW_KERNEL32_FROM_XBOX enabled)",
  "PortBugMergeLibCMakeDir": "Этот порт создает ${{CURRENT_PACKAGES_DIR}}/lib/cmake или ${{CURRENT_PACKAGES_DIR}}/debug/lib/cmake, которые следует объединить и переместить в ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/cmake. Используйте вспомогательную функцию vcpkg_cmake_config_fixup() из порта vcpkg-cmake-config. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_LIB_CMAKE_MERGE_CHECK enabled)",
  "PortBugMismatchingNumberOfBinaries": "несоответствие числа двоичных файлов отладки и выпуска. Это часто указывает на неправильную обработку отладки или выпуска в portfile.cmake или системе сборки. Если намерение состоит в том, чтобы только создавать компоненты выпуска для этого триплета, этот триплет должен содержать set(VCPKG_BUILD_TYPE release) в файле .cmake. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_MISMATCHED_NUMBER_OF_BINARIES enabled)",
  "PortBugMisplacedCMakeFiles": "Этот порт устанавливает следующие файлы CMake в расположениях, где файлы CMake не ожидаются. Файлы CMake следует устанавливать в ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_MISPLACED_CMAKE_FILES_CHECK enabled)",
  "PortBugMisplacedFiles": "Следующие обычные файлы устанавливаются в расположения, в которых нельзя установить обычные файлы. Их нужно установить в подкаталог. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_MISPLACED_REGULAR_FILES_CHECK enabled)",
  "PortBugMisplacedPkgConfigFiles": "Установлены следующие неправильно расположенные каталоги pkgconfig. Неправильно расположенные файлы pkgconfig не будут корректно найдены с помощью pkgconf или pkg-config. каталоги pkgconfig должны быть ${{CURRENT_PACKAGES_DIR}}/share/pkgconfig (для агностических архитектур или только библиотеки заголовков), ${{CURRENT_PACKAGES_DIR}}/lib/pkgconfig (для зависимостей выпуска) или ${{CURRENT_PACKAGES_DIR}}/debug/lib/pkgconfig (для зависимостей отладки). Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_PKGCONFIG_CHECK enabled)",
  "PortBugMissingCMakeHelperPortFile": "Файл ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/vcpkg-port-config.cmake не существует. Этот файл должен существовать для вспомогательных портов CMake. Чтобы скрыть это сообщение, удалите set(VCPKG_POLICY_CMAKE_HELPER_PORT enabled)",
  "PortBugMissingDebugBinaries": "Двоичные файлы отладки не найдены.",
  "PortBugMissingImportedLibs": "Библиотеки импорта для установленных DLL отсутствуют. Если это так, добавьте set(VCPKG_POLICY_DLLS_WITHOUT_LIBS enabled)",
  "PortBugMissingIncludeDir": "Папка ${{CURRENT_PACKAGES_DIR}}/include пуста или отсутствует. Обычно это означает, что заголовки установлены неправильно. Если это дополнительный порт CMake, добавьте set(VCPKG_POLICY_CMAKE_HELPER_PORT enabled). Если это не вспомогательный порт CMake, но это сделано намеренно, добавьте set(VCPKG_POLICY_EMPTY_INCLUDE_FOLDER enabled), чтобы скрыть это сообщение.",
  "PortBugMissingLicense": "лицензия не установлена ​​в ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/copyright. Это можно исправить, добавив вызов vcpkg_install_copyright. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_COPYRIGHT_CHECK enabled)",
  "PortBugMissingLicenseFixIt": "Рассмотрите возможность добавления: {value}",
  "PortBugMissingProvidedUsage": "этот порт содержит файл с именем \"usage\", но он не установлен в ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/usage. Если этот файл не предназначен для использования в качестве текста, рассмотрите возможность выбора другого имени; в противном случае установите его. Чтобы скрыть это сообщение, добавьте set(VCPKG_POLICY_SKIP_USAGE_INSTALL_CHECK enabled)",
  "PortBugMissingReleaseBinaries": "Двоичные файлы выпуска не найдены.",
  "PortBugMovePkgConfigFiles": "Файлы pkgconfig можно перемещать с помощью таких команд:",
  "PortBugOutdatedCRT": "Установлены библиотеки DLL, связанные с устаревшими библиотеками DLL C RunTime (\"CRT\"). Установленные библиотеки DLL должны быть связаны с поддерживаемым CRT. Зависимости DLL можно проверить с помощью \"dumpbin.exe/dependents mylibfile.dll\". Если вы используете пользовательский триплет, ориентированный на старый CRT, добавьте set(VCPKG_POLICY_ALLOW_OBSOLETE_MSVCRT enabled) в файл .cmake триплета. Чтобы скрыть это сообщение для этого порта, добавьте set(VCPKG_POLICY_ALLOW_OBSOLETE_MSVCRT enabled)",
  "PortBugRemoveBinDir": "если создание этих каталогов невозможно отключить, вы можете добавить следующее в portfile.cmake, чтобы удалить их",
  "PortBugRemoveEmptyDirs": "file(REMOVE_RECURSE пустые каталоги, оставшиеся после операций переименования)",
  "PortBugRestrictedHeaderPaths": "Использование следующих ограниченных заголовков может помешать правильной компиляции основной среды выполнения C++ и других пакетов. Вместо этого их следует переименовать или сохранить в подкаталоге. В исключительных случаях это предупреждение можно отключить, добавив set(VCPKG_POLICY_ALLOW_RESTRICTED_HEADERS enabled)",
  "PortBugRestrictedHeaderPathsNote": "заголовки здесь относятся к ${{CURRENT_PACKAGES_DIR}}/include",
  "PortBugSetDllsWithoutExports": "следующие DLL собраны без экспорта. Библиотеки DLL без экспорта, скорее всего, являются ошибками в сценарии сборки. Если это так, добавьте set(VCPKG_POLICY_DLLS_WITHOUT_EXPORTS enabled)",
  "PortDeclaredHere": "{package_name} объявлен здесь",
  "PortDependencyConflict": "Порт {package_name} имеет следующие неподдерживаемые зависимости:",
  "PortDoesNotExist": "{package_name} не существует",
  "PortMissingManifest2": "Отсутствует манифест порта {package_name} (нет файла vcpkg.json или CONTROL)",
  "PortNotInBaseline": "В базовом плане нет записи для порта {package_name}.",
  "PortNotSupported": "{package_name} не поддерживается в {triplet}",
  "PortSupportsField": "(поддерживает: \"{supports_expression}\")",
  "PortVersionConflict": "Следующие пакеты отличаются от версий портов:",
  "PortVersionControlMustBeANonNegativeInteger": "\"Port-Version\" должно быть неотрицательным целым числом",
  "PortVersionMultipleSpecification": "\"port_version\" не может сочетаться с внедренным \"#\" в версии",
  "PortsAdded": "Добавлены следующие порты ({count}):",
  "PortsNoDiff": "Порты между двумя фиксациями не изменились.",
  "PortsRemoved": "Удалены следующие порты ({count}):",
  "PortsUpdated": "Обновлены следующие порты ({count}):",
  "PrebuiltPackages": "Существуют несобранные пакеты. Чтобы собрать их, выполните:",
  "PrecheckBinaryCache": "Проверка двоичного кэша...",
  "PreviousDeclarationWasHere": "здесь было предыдущее объявление",
  "PreviousIntegrationFileRemains": "Предыдущий файл интеграции не был удален.",
  "ProgramPathReturnedNonzeroExitCode": "сбой с кодом завершения {exit_code}",
  "ProgramReturnedNonzeroExitCode": "Сбой средства {tool_name} с кодом завершения {exit_code}.",
  "ProvideExportType": "Требуется хотя бы один из следующих параметров: --raw --nuget --zip --7zip.",
  "PushingVendorFailed": "Сбой отправки {vendor} в \"{path}\". Для получения дополнительных сведений, используйте --debug.",
  "RegeneratesArtifactRegistry": "Повторно создает реестр артефактов",
  "RegistryCreated": "Реестр успешно создан в {path}",
  "RegistryValueWrongType": "Значение реестра {path} имеет непредвиденный тип.",
  "RemoveDependencies": "Чтобы удалить зависимости в режиме манифеста, измените манифест (vcpkg.json) и выполните команду \"install\".",
  "RemovePackageConflict": "{spec} не установлено, но {package_name} установлено для {triplet}. Вы имели в виду {package_name}:{triplet}?",
  "RemovingPackage": "Выполняется удаление {action_index}/{count} {spec}",
  "ResponseFileCode": "@response_file",
  "RestoredPackagesFromAWS": "Восстановлено несколько ({count}) пакетов из AWS за {elapsed}. Используйте --debug, чтобы увидеть больше деталей.",
  "RestoredPackagesFromAZUPKG": "Восстановлено несколько ({count}) пакетов из Universal Packages за {elapsed}. Используйте --debug, чтобы увидеть больше деталей.",
  "RestoredPackagesFromAzureStorage": "Восстановлено несколько ({count}) пакетов из службы хранилища Azure за {elapsed}. Используйте --debug, чтобы увидеть больше подробностей.",
  "RestoredPackagesFromCOS": "Восстановлено несколько ({count}) пакетов из COS за {elapsed}. Используйте --debug, чтобы увидеть больше деталей.",
  "RestoredPackagesFromFiles": "Восстановлено несколько ({count}) пакетов из {path} за {elapsed}. Используйте --debug, чтобы увидеть больше деталей.",
  "RestoredPackagesFromGCS": "Восстановлено несколько ({count}) пакетов из GCS за {elapsed}. Используйте --debug, чтобы увидеть больше деталей.",
  "RestoredPackagesFromHTTP": "Восстановлено несколько ({count}) пакетов из HTTP-серверов за {elapsed}. Используйте --debug, чтобы увидеть больше деталей.",
  "RestoredPackagesFromNuGet": "Восстановлено несколько ({count}) пакетов из NuGet за {elapsed}. Используйте --debug, чтобы увидеть больше деталей.",
  "ResultsHeader": "РЕЗУЛЬТАТЫ",
  "ScriptAssetCacheRequiresScript": "ожидаемые аргументы: конфигурация ресурса \"x-script\" требует в качестве аргумента только шаблон exec",
  "SecretBanner": "*** СЕКРЕТ ***",
  "SeeURL": "Дополнительные сведения см. в {url}.",
  "SerializedBinParagraphHeader": "\nАбзац сериализованного двоичного файла",
  "SettingEnvVar": "-- Установка переменных среды \"{env_var}\" в \"{url}\".",
  "ShaPassedAsArgAndOption": "SHA512 передан как аргумент и как параметр. Передайте только один из этих вариантов.",
  "ShaPassedWithConflict": "Передано SHA512, но также передан параметр --skip-sha512. Выберите только один из этих вариантов.",
  "ShallowRepositoryDetected": "vcpkg клонирован как поверхностный репозиторий. Повторите попытку с полным клонированием vcpkg.",
  "SkipClearingInvalidDir": "Очистка содержимого {path} пропущена: это не каталог.",
  "SkipTestingOfPort": "Пропуск тестирования {feature_spec}, так как следующие зависимости не поддерживаются в {triplet}:",
  "SkipTestingOfPortAlreadyInBinaryCache": "Пропуск тестирования, так как хэш ABI {sha} уже находится в двоичном кэше.",
  "SkippingPostBuildValidationDueTo": "Пропуск проверки после сборки из-за {cmake_var}",
  "SourceFieldPortNameMismatch": "Поле \"Source\" в файле CONTROL или поле \"name\" в файле vcpkg.json содержит имя {package_name} и не соответствует каталогу порта {path}.",
  "SpecifiedFeatureTurnedOff": "Функция '{command_name}' специально отключена, но указан --{option}.",
  "SpecifyHostArch": "Триплет узла. См. \"vcpkg help triplet\" (по умолчанию: {env_var})",
  "SpecifyTargetArch": "Триплет целевого объекта. См. \"vcpkg help triplet\" (по умолчанию: {env_var})",
  "StartCodeUnitInContinue": "найдена единица начального кода в позиции продолжения",
  "StartingFeatureTest": "Тест функции [{value}] {feature_spec}",
  "StoreOptionMissingSha": "Параметр --store недопустим без sha512",
  "SubmittingBinaryCacheBackground": "Начинается отправка {spec} в {count} двоичных кэшах в фоновом режиме",
  "SubmittingBinaryCacheComplete": "Завершена отправка {spec} в {count} двоичных кэшах в {elapsed}",
  "SuggestGitPull": "Результат может быть устаревшим. Чтобы получить последние результаты, запустите \"git pull\".",
  "SuggestStartingBashShell": "Чтобы изменения вступили в силу, пожалуйста, проверьте, запустили ли вы новую оболочку bash,",
  "SupportedPort": "Порт {package_name} поддерживается.",
  "SwitchUsedMultipleTimes": "переключатель \"{option}\" указан несколько раз",
  "SynopsisHeader": "Описание:",
  "SystemApiErrorMessage": "Сбой вызова API {system_api} с кодом завершения {exit_code} ({error_msg})",
  "SystemTargetsInstallFailed": "не удалось установить файл целей построения в {path}",
  "ToRemovePackages": "Чтобы удалить только устаревшие пакеты, запустите команду\n{command_name} remove --outdated",
  "ToUpdatePackages": "Чтобы обновить эти пакеты и все зависимости, запустите команду обновления\n{command_name}",
  "ToolDataFileSchemaVersionNotSupported": "версия схемы {version} не поддерживается данной версией vcpkg",
  "ToolFetchFailed": "Не удалось получить {tool_name}.",
  "ToolHashMismatch": "{tool_name} уже скачан, но имеет неправильный хэш. Ожидалось {expected}, но {actual}",
  "ToolInWin10": "Эта служебная программа поставляется в комплекте с Windows 10 и более поздней версии.",
  "ToolOfVersionXNotFound": "Подходящая версия {tool_name} не найдена (требуется v{version}) и не может автоматически загрузить портативную версию. Установите более новую версию {tool_name}",
  "TotalInstallTime": "Общее время установки: {elapsed}",
  "TotalInstallTimeSuccess": "Все запрошенные установки успешно завершены за: {elapsed}",
  "TrailingCommaInArray": "Конечная запятая в массиве",
  "TrailingCommaInObj": "Конечная запятая в объекте",
  "TripletFileNotFound": "Файл Triplet {triplet}.cmake не найден",
  "TripletLabel": "Триплет:",
  "TwoFeatureFlagsSpecified": "И '{value}', и -'{value}' были указаны как флаги функций.",
  "UnableToClearPath": "не удается удалить {path}",
  "UnableToReadAppDatas": "%LOCALAPPDATA% и %APPDATA% нечитаемы",
  "UnableToReadEnvironmentVariable": "не удалось прочитать {env_var}",
  "UndeterminedToolChainForTriplet": "Не удалось определить использование цепочки инструментов для {triplet} с CMAKE_SYSTEM_NAME {system_name}. Вы хотели использовать VCPKG_CHAINLOAD_TOOLCHAIN_FILE?",
  "UnexpectedArgument": "непредвиденный аргумент: {option}",
  "UnexpectedAssetCacheProvider": "неизвестный тип поставщика ресурсов: допустимые типы источников: \"x-azurl\", \"x-script\", \"x-block-origin\" и \"clear\"",
  "UnexpectedByteSize": "Ожидалась запись: {expected}, записано: {actual}.",
  "UnexpectedCharExpectedCloseBrace": "Непредвиденный символ; требуется свойство или закрывающая фигурная скобка",
  "UnexpectedCharExpectedColon": "Непредвиденный символ; ожидается двоеточие",
  "UnexpectedCharExpectedName": "Непредвиденный символ; ожидается имя свойства",
  "UnexpectedCharExpectedValue": "Непредвиденный символ; ожидаемое значение",
  "UnexpectedCharMidArray": "Непредвиденный символ в середине массива",
  "UnexpectedCharMidKeyword": "Непредвиденный символ в середине ключевого слова",
  "UnexpectedDigitsAfterLeadingZero": "Непредвиденные цифры после начального нуля",
  "UnexpectedEOFAfterBacktick": "непредвиденный eof: конечные обратные кавычки без экранирования (`) не разрешены",
  "UnexpectedEOFAfterEscape": "Непредвиденный EOF после escape-символа",
  "UnexpectedEOFAfterMinus": "Непредвиденный EOF после знака минуса",
  "UnexpectedEOFExpectedChar": "Непредвиденный символ; ожидается EOF",
  "UnexpectedEOFExpectedCloseBrace": "Непредвиденный EOF; ожидается свойство или закрывающая фигурная скобка",
  "UnexpectedEOFExpectedColon": "Непредвиденный EOF; ожидается двоеточие",
  "UnexpectedEOFExpectedName": "Непредвиденный EOF; ожидается имя свойства",
  "UnexpectedEOFExpectedProp": "Непредвиденный EOF; ожидается свойство",
  "UnexpectedEOFExpectedValue": "Непредвиденный EOF; ожидаемое значение",
  "UnexpectedEOFMidArray": "Непредвиденный EOF в середине массива",
  "UnexpectedEOFMidKeyword": "Непредвиденный EOF в середине ключевого слова",
  "UnexpectedEOFMidString": "Непредвиденный EOF в середине строки",
  "UnexpectedEOFMidUnicodeEscape": "Непредвиденный конец файла в середине escape-кода Юникода",
  "UnexpectedEscapeSequence": "Непредвиденное продолжение escape-последовательности",
  "UnexpectedField": "неожиданное поле \"{json_field}\"",
  "UnexpectedFieldSuggest": "неожиданное поле \"{json_field}\", вы имели в виду \"{value}\"?",
  "UnexpectedFormat": "Ожидается формат [{expected}], а был [{actual}].",
  "UnexpectedOption": "непредвиденный параметр: {option}",
  "UnexpectedPortName": "порт {expected} объявлен как {actual} в {path}",
  "UnexpectedPortversion": "неожиданный параметр \"port-version\" без поля управления версиями",
  "UnexpectedStateCascade": "В {feature_spec} произошла непредвиденная каскадная ошибка из-за недоступности следующих зависимостей:",
  "UnexpectedStateCascadePortNote": "рассмотрите возможность замены этого на =cascade",
  "UnexpectedStateFailedCascade": "сборка {feature_spec} завершилась сбоем, хотя ожидался каскадный сбой",
  "UnexpectedStateFailedNoteConsiderSkippingPort": "рассмотрите возможность добавления \"{package_name}=fail\", \"{spec}=fail\" или эквивалентных пропусков",
  "UnexpectedStateFailedNoteConsiderSkippingPortOrCombination": "рассмотрите возможность добавления \"{package_name}=fail\", \"{spec}=fail\", \"{feature_spec}=combination-fails\" или эквивалентных пропусков или пометки взаимоисключающих функций в качестве параметров",
  "UnexpectedStateFailedNoteFeatureMarkedCascade": "рассмотрите возможность замены этого \"=cascade\" на \"=feature-fails\" и/или одного или нескольких \"=combination-fails\"",
  "UnexpectedStateFailedNoteMoreFeaturesRequired": "если некоторые функции необходимы, рассмотрите возможность постоянного включения этих частей в файле portfile.cmake для {package_name} или добавьте \"{package_name}[required-feature]=options\", чтобы включить \"required-feature\" во все тесты",
  "UnexpectedStateFailedNotePortMarkedCascade": "рассмотрите возможность замены этого \"=cascade\" на \"=fail\"",
  "UnexpectedStateFailedNoteSeparateCombinationFails": "если {feature} проходит при сборке с другими функциями, но не в одиночку, рассмотрите возможность добавления \"{feature_spec}=combination-fails\"",
  "UnexpectedStateFailedNoteSeparateFeatureFails": "если {feature} всегда завершается сбоем, рассмотрите возможность добавления \"{feature_spec}=feature-fails\", что пометит этот тест как неудачный и исключит {feature} из комбинированного тестирования функций",
  "UnexpectedStateFailedPass": "сборка {feature_spec} завершилась сбоем, хотя ожидалось успешное выполнение",
  "UnexpectedStatePassFeatureMarkedCascade": "{feature_spec} прошла, но {feature} помечена как ожидаемый каскадный сбой",
  "UnexpectedStatePassFeatureMarkedFail": "{feature_spec} прошла, хотя {feature} помечена как ожидаемая неудача",
  "UnexpectedStatePassPortMarkedCascade": "{feature_spec} прошла, но была помечена как ожидаемая каскадная неудача",
  "UnexpectedStatePassPortMarkedFail": "{feature_spec} прошла, хотя ожидался сбой",
  "UnexpectedSwitch": "непредвиденный переключатель: {option}",
  "UnexpectedToolOutput": "Средство {tool_name} ({path}) отобразило непредвиденные выходные данные при попытке определить версию:",
  "UnexpectedWindowsArchitecture": "неожиданная архитектура узла Windows: {actual}",
  "UnknownBaselineFileContent": "Базовая запись не распознана; ожидалось \"port:triplet=(fail|skip|pass)\".",
  "UnknownBinaryProviderType": "неизвестный тип бинарного провайдера: допустимыми провайдерами являются \"clear\", \"default\", \"nuget\", \"nugetconfig\", \"nugettimeout\", \"interactive\", \"x-azblob\", \"x-gcs\", \"x-aws\", \"x-aws-config\", \"http\" и \"files\"",
  "UnknownBooleanSetting": "неизвестная логическая настройка для {option}: \"{value}\". Допустимые значения: '', \"1\", \"0\", \"ВКЛ\", \"ВЫКЛ\", \"ИСТИНА\" и \"ЛОЖЬ\".",
  "UnknownParameterForIntegrate": "Неизвестный параметр \"{value}\" для интеграции.",
  "UnknownPolicySetting": "Неизвестный параметр {cmake_var}: {value}. Допустимые значения политики: \"\", \"disabled\" и \"enabled\".",
  "UnknownSettingForBuildType": "Неизвестный параметр для VCPKG_BUILD_TYPE {опция}. Допустимые параметры: '', 'debug', и 'release'.",
  "UnknownTool": "vcpkg не имеет определения этого инструмента для этой платформы.",
  "UnknownTopic": "неизвестная тема {value}",
  "UnknownVariablesInTemplate": "Недопустимый аргумент. URL-шаблон \"{value}\" содержит неизвестные переменные: {list}.",
  "UnrecognizedConfigField": "конфигурация содержит следующие нераспознанные поля:",
  "UnrecognizedIdentifier": "Нераспознанное имя идентификатора {value}. Добавьте в список переопределений в файле триады.",
  "UnsupportedFeature": "компонент {feature} передан, но он не является компонентом, поддерживаемым {package_name}.",
  "UnsupportedFeatureSupportsExpression": "{feature_spec} поддерживается только в \"{supports_expression}\", что не соответствует {triplet}. Обычно это означает, что при сборке других платформ возникают известные сбои сборки или проблемы во время выполнения. Чтобы игнорировать это и попытаться выполнить сборку {package_name}, перезапустите vcpkg с параметром \"--allow-unsupported\".",
  "UnsupportedFeatureSupportsExpressionWarning": "{feature_spec} поддерживается только в \"{supports_expression}\", что не соответствует {triplet}. Обычно это означает, что при сборке других платформ возникают известные сбои сборки или проблемы во время выполнения. В любом случае выполняется продолжение из-за параметра \"--allow-unsupported\".",
  "UnsupportedPort": "Порт {package_name} не поддерживается.",
  "UnsupportedPortDependency": "- зависимость {value} не поддерживается.",
  "UnsupportedSyntaxInCDATA": "]]> не поддерживается в блоке CDATA",
  "UnsupportedSystemName": "Не удалось сопоставить VCPKG_CMAKE_SYSTEM_NAME \"{system_name}\" с платформой vcvarsall. Поддерживаемые имена систем: \"\", \"Windows\" и \"WindowsStore\".",
  "UnsupportedToolchain": "в триплете {triplet}: Не удалось найти допустимую цепочку инструментов для запрошенной целевой архитектуры {arch}.\nВыбранный экземпляр Visual Studio находится в: {path}\nДоступные сочетания наборов инструментов: {list}",
  "UnsupportedUpdateCMD": "команда обновления сейчас не поддерживает режим манифеста. Вместо этого измените vcpkg.json и запустите установку.",
  "UpdateBaselineAddBaselineNoManifest": "ключ --{option} передан, но нет файла манифеста, в который можно было бы добавить поле \"builtin-baseline\".",
  "UpdateBaselineLocalGitError": "сбой GIT при попытке анализа HEAD локального реестра vcpkg в \"{path}\"",
  "UpdateBaselineNoConfiguration": "невозможно обновить \"vcpkg.json\" или \"vcpkg-configuration.json\": файлы не существуют.",
  "UpdateBaselineNoExistingBuiltinBaseline": "файл манифеста в настоящее время не содержит поле \"builtin-baseline\"; чтобы добавить его, передайте ключ --{option}.",
  "UpdateBaselineNoUpdate": "реестр \"{url}\" не обновлен: \"{value}\"",
  "UpdateBaselineRemoteGitError": "GIT не удалось получить удаленный репозиторий \"{url}\"",
  "UpdateBaselineUpdatedBaseline": "обновленный реестр \"{url}\": базовый план \"{old_value}\" -> \"{new_value}\"",
  "UpgradeInManifest": "Обновление обновляет установку в классическом режиме и поэтому не поддерживает режим манифеста. Попробуйте обновить зависимости, обновив базовый план до текущего значения с помощью vcpkg x-update-baseline и запустив установку vcpkg.",
  "UpgradeRunWithNoDryRun": "Если вы действительно хотите повторно собрать перечисленные выше пакеты, запустите эту команду с параметром --no-dry-run.",
  "UploadingBinariesToVendor": "Отправка двоичных файлов для {spec} в {vendor} из {path}",
  "UsageInstallInstructions": "файл использования можно установить с помощью следующего CMake",
  "UsageTextHere": "файл использования находится здесь",
  "UseEnvVar": "-- Использование {env_var} в переменных окружения.",
  "UserWideIntegrationDeleted": "Общепользовательская интеграция не установлена.",
  "UserWideIntegrationRemoved": "Общепользовательская интеграция удалена.",
  "UsingManifestAt": "Использование файла манифеста в {path}.",
  "Utf8ConversionFailed": "Не удалось преобразовать в UTF-8",
  "VSExaminedInstances": "Рассмотрены следующие экземпляры Visual Studio:",
  "VSExaminedPaths": "Следующие пути проверены на наличие экземпляров Visual Studio:",
  "VSNoInstances": "Не удалось найти полный экземпляр Visual Studio",
  "VcpkgCeIsExperimental": "Функция vcpkg-artifacts является экспериментальной и может измениться в любое время.",
  "VcpkgCompletion": "Завершение vcpkg {value} уже импортировано в ваш файл \"{path}\".\nНайдены следующие записи:",
  "VcpkgDisallowedClassicMode": "Не удалось найти манифест (vcpkg.json) над текущим рабочим каталогом.\nЭто распределение vcpkg не имеет экземпляра классического режима.",
  "VcpkgHasCrashed": "Сбой vcpkg. Пожалуйста, создайте проблему на https://github.com/microsoft/vcpkg, содержащую краткую сводку о том, что вы пытались сделать, и следующую информацию.",
  "VcpkgInVsPrompt": "Похоже, vcpkg находится в запросе Visual Studio, предназначенном для {value}, но устанавливается для {triplet}. Попробуйте использовать --triplet {value}-windows или --triplet {value}-uwp.",
  "VcpkgInvalidCommand": "недопустимая команда: {command_name}",
  "VcpkgRegistriesCacheIsNotDirectory": "Значение переменной среды X_VCPKG_REGISTRIES_CACHE не является каталогом: {path}",
  "VcpkgRootRequired": "Для изолированной начальной загрузки необходимо настроить VCPKG_ROOT.",
  "VcpkgRootsDir": "Корневой каталог vcpkg (по умолчанию: {env_var})",
  "VcpkgSendMetricsButDisabled": "передан --sendmetrics, но метрики отключены.",
  "VcpkgUsage": "использование: vcpkg <команда> [--переключатели] [--параметры=значения] [аргументы] @файл_ответа",
  "VcvarsRunFailed": "не удалось запустить vcvarsall.bat для получения среды Visual Studio",
  "VcvarsRunFailedExitCode": "при попытке получить среду Visual Studio vcvarsall.bat вернул {exit_code}",
  "VersionBaselineMatch": "{version_spec} соответствует текущему базовому плану",
  "VersionBaselineMismatch": "Для {package_name} назначено {actual}, но локальный порт: {expected}",
  "VersionBuiltinPortTreeEntryMissing": "отсутствует запись базы данных версий для {package_name} в {expected}; с использованием извлеченной версией дерева портов ({actual}).",
  "VersionCommandHeader": "Версия программы управления пакетами vcpkg {version}\n\nСм. LICENSE.txt для получения сведений о лицензии.",
  "VersionConstraintNotInDatabase1": "ограничение \"version>=\" версии {version} имен {package_name}, которая не существует в базе данных версий. Все версии должны существовать в базе данных версий для интерпретации с помощью vcpkg.",
  "VersionConstraintNotInDatabase2": "рассмотрите возможность удалить ограничение версии или выбрать значение, объявленное здесь",
  "VersionConstraintOk": "все ограничения версий согласованы с базой данных версий",
  "VersionConstraintPortVersionMustBePositiveInteger": "port-version (после \"#\") в \"version>=\" должен быть неотрицательным целым числом",
  "VersionConstraintViolated": "ожидалось, что версия зависимости {spec} будет не менее {expected_version}, но текущая версия — {actual_version}.",
  "VersionDatabaseEntryMissing": "отсутствует запись версии для {package_name} в {version}.",
  "VersionDatabaseFileMissing": "этого порта нет в базе данных версий",
  "VersionDatabaseFileMissing2": "файл базы данных версий должен находиться здесь",
  "VersionDatabaseFileMissing3": "выполните команду \"{command_line}\", чтобы создать файл базы данных версий",
  "VersionGitEntryMissing": "отсутствует запись базы данных версий для {package_name} в {version}.\nДоступные версии:",
  "VersionInDeclarationDoesNotMatch": "{git_tree_sha} объявлено как содержащее {expected}, но, по-видимому, содержит {actual}",
  "VersionIncomparable1": "конфликт версий {spec}: для {constraint_origin} требуется {expected}, что невозможно сравнить с базовой версией {actual}.",
  "VersionIncomparable2": "{version_spec} использует схему {new_scheme}",
  "VersionIncomparable3": "Это можно устранить, добавив явное переопределение в предпочитаемую версию. Например:",
  "VersionIncomparable4": "Дополнительные сведения см. в разделе \"управление версиями справки vcpkg\" или по адресу {url}.",
  "VersionIncomparableSchemeString": "Обе версии используют строку схемы, но разный основной текст.",
  "VersionIncomparableSchemes": "Версии используют несовместимые схемы:",
  "VersionInvalidDate": "\"{version}\" не является допустимой версией даты. Даты должны быть в формате ГГГГ-ММ-ДД, а неоднозначные значения должны быть положительными целыми числами с разделителями-точками без начальных нулей.",
  "VersionInvalidRelaxed": "\"{version}\" не является допустимой нестрогой версией (semver с произвольным количеством числовых элементов).",
  "VersionInvalidSemver": "\"{version}\" не является допустимой семантической версией, см. <https://semver.org>.",
  "VersionMissing": "ожидается поле управления версиями (один из вариантов: version, version-date, version-semver или version-string)",
  "VersionMissingRequiredFeature": "{version_spec} не содержит обязательного компонента {feature}, необходимого для {constraint_origin}",
  "VersionNotFoundInVersionsFile2": "{version_spec} не найдено в базе данных версий",
  "VersionNotFoundInVersionsFile3": "версия должна находиться в этом файле",
  "VersionNotFoundInVersionsFile4": "выполните команду \"{command_line}\", чтобы добавить новую версию порта",
  "VersionOverrideNotInVersionDatabase": "в базе данных версий нет переопределения версии {package_name}. Существует ли этот порт?",
  "VersionOverrideVersionNotInVersionDatabase1": "переопределение версии {version} имен {package_name}, которая не существует в базе данных версий. Установка этого порта на верхнем уровне приведет к сбою, так как эта версия будет неразрешимой.",
  "VersionOverrideVersionNotInVersionDatabase2": "рассмотрите возможность удалить переопределение версии или выбрать значение, объявленное здесь",
  "VersionOverwriteVersion": "вы можете перезаписать {version_spec} с правильными локальными значениями, выполнив команду:",
  "VersionRejectedDueToBaselineMissing": "Путь {path} отклонен, поскольку в нем используется \"{json_field}\" и отсутствует \"builtin-baseline\". Чтобы исправить эту ошибку, удалите все вхождения \"{json_field}\" или добавьте \"builtin-baseline\".\nДля получения дополнительных сведений см. \"vcpkg help versioning\".",
  "VersionRejectedDueToFeatureFlagOff": "Путь {path} отклонен, поскольку в нем используется \"{json_field}\", а флаг функции \"versions\" отключен. Чтобы исправить эту ошибку, удалите \"{json_field}\" или включите флаг функции \"versions\".\nДля получения дополнительных сведений см. \"vcpkg help versioning\".",
  "VersionSchemeMismatch1": "{version} объявлено как {expected}, но {package_name} объявлен с {actual}",
  "VersionSchemeMismatch1Old": "{version} объявлено как {expected}, но {package_name}@{git_tree_sha} объявлен с {actual}",
  "VersionSchemeMismatch2": "версии должны быть уникальными, даже если они объявлены с разными схемами",
  "VersionShaMismatch1": "{version_spec} дерева Git {git_tree_sha} не соответствует каталогу порта",
  "VersionShaMismatch2": "каталог порта содержит дерево Git {git_tree_sha}",
  "VersionShaMismatch3": "если {version_spec} уже опубликовано, обновите этот файл, используя новую версию или версию порта, зафиксируйте его, а затем добавьте новую версию, выполнив команду:",
  "VersionShaMismatch4": "если {version_spec} еще не опубликовано, перезапишите предыдущее дерево Git, выполнив команду:",
  "VersionSharpMustBeFollowedByPortVersion": "после \"#\" в тексте версии должна следовать версия порта",
  "VersionSharpMustBeFollowedByPortVersionNonNegativeInteger": "после \"#\" в тексте версии должна следовать версия порта (неотрицательное целое число)",
  "VersionSpecMismatch": "Не удалось загрузить порт, так как версии не согласованы. Файл \"{path}\" содержит версию {actual_version}, но база данных версий указывает, что она должна быть {expected_version}.",
  "VersionVerifiedOK": "параметр {version_spec} правильно указан в базе данных версий ({git_tree_sha})",
  "WaitUntilPackagesUploaded": "Ожидание {count} отправки двоичного кэша...",
  "WaitingForChildrenToExit": "Ожидание завершения дочерних процессов...",
  "WaitingToTakeFilesystemLock": "ожидание блокировки файловой системы в {path}...",
  "WarningsTreatedAsErrors": "предыдущие предупреждения, интерпретируемые как ошибки",
  "WhileCheckingOutBaseline": "при извлечении базовых показателей {commit_sha}",
  "WhileCheckingOutPortTreeIsh": "при проверке порта {package_name} с деревом Git {git_tree_sha}",
  "WhileGettingLocalTreeIshObjectsForPorts": "при получении локальных древовидных объектов для портов",
  "WhileLoadingBaselineVersionForPort": "при загрузке базовой версии для {package_name}",
  "WhileLoadingPortVersion": "при загрузке {version_spec}",
  "WhileLookingForSpec": "при поиске {spec}:",
  "WhileParsingVersionsForPort": "при анализе версий для {package_name} из {path}",
  "WhileRunningAssetCacheScriptCommandLine": "при выполнении командной строки сценария кэша ресурсов",
  "WhileValidatingVersion": "при проверке версии: {version}",
  "WindowsEnvMustAlwaysBePresent": "Ожидалось, что {env_var} всегда будет настроено в Windows.",
  "WindowsOnlyCommand": "Эта команда поддерживает только Windows.",
  "WroteNuGetPkgConfInfo": "Сведения о конфигурации пакета NuGet записаны в {path}",
  "FatalTheRootFolder$CannotBeCreated": "Неустранимая ошибка: не удается создать корневую папку \"${p0}\"",
  "FatalTheGlobalConfigurationFile$CannotBeCreated": "Неустранимая ошибка: не удается создать глобальный файл конфигурации \"${p0}\".",
  "VCPKGCOMMANDWasNotSet": "VCPKG_COMMAND не настроена",
  "RunningVcpkgInternallyReturnedANonzeroExitCode$": "Запуск vcpkg внутренне вернул ненулевой код выхода: ${p0}",
  "failedToDownloadFrom$": "не удалось скачать из ${p0}",
  "failedToDownload$FromAnySource": "не удалось скачать ${p0} из источника",
  "ErrorParsingConditionalDemand$$": "Ошибка анализа условного запроса \"${p0}\"- ${p1}",
  "MissingIdentity$": "Отсутствует удостоверение \"${p0}\"",
  "infoidShouldBeOfTypestringFound$": "Параметр info.id должен иметь тип \"string\", обнаружено \"${p0}\"",
  "MissingVersion$": "Отсутствует версия \"${p0}\"",
  "infoversionShouldBeOfTypestringFound$": "Параметр info.version должен иметь тип \"string\", обнаружено \"${p0}\"",
  "infosummaryShouldBeOfTypestringFound$": "Параметр info.summary должен иметь тип \"string\", обнаружено \"${p0}\"",
  "infodescriptionShouldBeOfTypestringFound$": "Параметр info.description должен иметь тип \"string\", обнаружено \"${p0}\"",
  "infooptionsShouldBeASequenceFound$": "Параметр info.options должен быть последовательностью, обнаружено \"${p0}\"",
  "TheInfoBlockIsDeprecatedForConsistencyWithVcpkgjsonMoveInfoMembersToTheOutside": "Информационный блок не рекомендуется для согласованности с vcpkg.json. Переместите элементы сведений во внешнюю среду.",
  "idShouldBeOfTypestringFound$": "Параметр id должен иметь тип \"string\", обнаружено \"${p0}\"",
  "versionShouldBeOfTypestringFound$": "Параметр version должен иметь тип \"string\", обнаружено \"${p0}\"",
  "summaryShouldBeOfTypestringFound$": "Параметр summary должен иметь тип \"string\", обнаружено \"${p0}\"",
  "descriptionShouldBeOfTypestringFound$": "Параметр description должен иметь тип \"string\", обнаружено \"${p0}\"",
  "optionsShouldBeASequenceFound$": "Параметр options должен быть последовательностью, обнаружено \"${p0}\"",
  "DuplicateKeysDetectedInManifest$": "В манифесте обнаружены повторяющиеся ключи: \"${p0}\"",
  "noPostscriptFileRunVcpkgshellWithTheSameArguments": "нет postscript-файла: запустите команду \\\"vcpkg-shell\\\" с теми же аргументами",
  "DuplicateDefine$DuringActivationNewValueWillReplaceOld": "Дублировать определение ${p0} во время активации. Новое значение заменит старое.",
  "DuplicateToolDeclared$DuringActivationNewValueWillReplaceOld": "Во время активации объявлено дублирующее средство ${p0}. Новое значение заменит старое.",
  "DuplicateAliasDeclared$DuringActivationNewValueWillReplaceOld": "Во время активации объявлен дублирующий псевдоним ${p0}. Новое значение заменит старое.",
  "DuplicateLocationDeclared$DuringActivationNewValueWillReplaceOld": "Во время активации было объявлено дублирующее расположение ${p0}. Новое значение заменит старое.",
  "CircularVariableReferenceDetected$": "Обнаружена циклическая ссылка на переменную: ${p0}",
  "CircularVariableReferenceDetected$$": "Обнаружена циклическая ссылка на переменную: ${p0} - ${p1}",
  "VariableReferenceFound$$$ThatIsReferencingAnUnknownBaseObject": "Обнаружена ссылка на переменную \"$${p0}.${p1}\", которая указывает на неизвестный базовый объект.",
  "UnresolvedVariableReferenceFound$$$DuringVariableSubstitution": "Обнаружена неразрешенная ссылка на переменную ($${p0}.${p1}) во время подстановки переменных.",
  "InvalidPathDoesNotExist$": "Недопустимый путь — не существует: ${p0}",
  "Activating$": "Активация: ${p0}",
  "Deactivating$": "Отключение: ${p0}",
  "nothingIsActivatedNoChangesHaveBeenMade": "ничего не активировано, изменения не внесены",
  "InvalidArtifactId$": "Недопустимый идентификатор артефакта \"${p0}\"",
  "UnknownInstallerType$": "Неизвестный тип установщика ${p0}",
  "WhileResolvingDependenciesOf$$In$CouldNotBeResolvedToARegistry": "Когда выполнялось разрешение зависимостей ${p0}, ${p1} в ${p2} не удалось разрешить в реестр.",
  "WhileResolvingDependenciesOfTheProjectFile$$DidNotSpecifyARegistry": "Когда выполнялось разрешение зависимостей файла проекта ${p0}, ${p1} не указал реестр.",
  "UnableToResolveDependency$In$": "Не удается разрешить зависимость ${p0} в ${p1}.",
  "Artifact": "Артефакт",
  "Version": "Версия",
  "Status": "Состояние",
  "Dependency": "Зависимость",
  "Summary": "Сводка",
  "progressUnknown": "(ход выполнения неизвестен)",
  "verifying": "проверка",
  "downloading$$": "скачивание ${p0} -> ${p1}",
  "unpacking$": "распаковка ${p0}",
  "Installing$": "Установка ${p0}...",
  "$AlreadyInstalled": "Уже установлено: ${p0}",
  "Downloading$": "Скачивание ${p0}...",
  "Unpacking$": "Распаковка ${p0}...",
  "ErrorInstalling$$": "Ошибка при установке ${p0} - ${p1}",
  "error": "ошибка:",
  "warning": "предупреждение:",
  "ExpectedASingleValueFor$FoundMultiple": "Ожидалось одиночное значение для ${p0} — найдено несколько",
  "ExpectedASingleValueFor$": "Ожидалось одиночное значение для \"--${p0}\".",
  "Assuming$IsCorrectSupplyAHashInTheArtifactMetadataToSuppressThisMessage": "Предполагается, что \"${p0}\" правильный; предоставьте хэш в метаданных артефакта, чтобы подавить это сообщение.",
  "DownloadedFile$DidNotHaveTheCorrectHash$$": "Скачанный файл \"${p0}\" не содержит правильного хэша (${p1}: ${p2}) ",
  "packageReference$IsNotAValidNugetPackageReferencenameversion": "ссылка на пакет \"${p0}\" не является допустимой ссылкой на пакет NuGet ({name}/{version})",
  "statsMayNotBeUndefined": "статистика не может быть неопределенной",
  "CannotRenameFilesAcrossFilesystems": "Не удается переименовать файлы в разных файловых системах",
  "CopyFailedSource$IsAFolderTarget$IsAFile": "Сбой копирования: источник (${p0}) является папкой, целевой объект (${p1}) является файлом",
  "UriMayNotBeEmpty": "URI не может быть пустым",
  "scheme$AlreadyRegistered": "схема \"${p0}\" уже зарегистрирована",
  "uri$HasNoScheme": "URI ${p0} не содержит схемы",
  "scheme$HasNoFilesystemAssociatedWithIt": "со схемой ${p0} не связана файловая система",
  "mayNotRenameAcrossFilesystems": "не может переименовывать в файловых системах",
  "CouldNotActivateEspidfPythonWasNotFound": "Не удалось активировать esp-idf: Python не найден.",
  "GitIsNotInstalled": "Git не установлен",
  "InitializingRepositoryFolder": "Инициализация папки репозитория",
  "FailedToInitializeGitRepositoryFolder$": "Не удалось инициализировать папку репозитория Git (${p0})",
  "AddingRemote$ToGitRepositoryFolder": "Добавление удаленного ${p0} в папку репозитория Git",
  "FailedToSetGitOrigin$InFolder$": "Не удалось установить источник Git (${p0}) в папке (${p1})",
  "FetchingRemote$ForGitRepositoryFolder": "Извлечение удаленного ${p0} для папки репозитория Git",
  "UnableToFetchGitDataFor$InFolder$": "Не удается получить данные Git для (${p0}) в папке (${p1})",
  "CheckingOutCommit$For$ToGitRepositoryFolder": "Проверка фиксации ${p0} для ${p1} в папке репозитория Git",
  "UnableToCheckoutDataFor$InFolder$": "Не удается извлечь данные для (${p0}) в папке (${p1})",
  "UpdatingSubmodulesForRepository$InTheGitRepositoryFolder": "Обновление подмодулей для репозитория ${p0} в папке репозитория Git",
  "UnableToSetSubmoduleShallowDataFor$InFolder$": "Не удается задать поверхностные данные подмодуля для (${p0}) в папке (${p1})",
  "UnableUpdateSubmodulesFor$InFolder$": "Не удается обновить подмодули для (${p0}) в папке (${p1})",
  "ExpectedCommaFound$": "Ожидалась запятая, найдено ${p0}",
  "ExpectedOneOfNumberBooleanIdentifierStringFoundToken$": "Ожидается одно из {Number, Boolean, Identifier, String}, найден маркер ${p0}",
  "ExpressionSpecifiedNOTTwice": "Выражение указано НЕ дважды",
  "ExpectedCloseParenthesisForExpressionFound$": "Для выражения ожидалась закрывающая круглая скобка, обнаружено ${p0}",
  "ExpectedExpressionFound$": "Ожидаемое выражение, найдено ${p0}",
  "ParseErrorDigitExpected": "ParseError: ожидается цифра (0-9)",
  "ParseErrorHexDigitExpectedFf": "ParseError: ожидается шестнадцатеричная цифра (0-F, 0-f)",
  "ParseErrorBinaryDigitExpected": "ParseError: ожидается двоичная цифра (0,1)",
  "UnexpectedEndOfFileWhileSearchingFor$": "Непредвиденный конец файла при поиске \"${p0}\"",
  "InvalidEscapeSequence": "Недопустимая escape-последовательность",
  "FailedToDeserializeIndex$": "Не удалось десериализовать индекс ${p0}",
  "$MatchedMoreThanOneResult$": "\"${p0}\" соответствует более чем одному результату (${p1}).",
  "UnsupportedRegistryScheme$": "Неподдерживаемая схема реестра \"${p0}\"",
  "TriedToAdd$As$But$IsAlready$": "Попытка добавить ${p0} как ${p1}, но ${p2} уже ${p3}.",
  "UnknownRegistry$in$TheFollowingAreKnown$": "Неизвестный реестр ${p0} (в ${p1}). Известно следующее: ${p2}",
  "UpdatingRegistryDataFrom$": "Обновление данных реестра из ${p0}",
  "$MustBeAString": "${p0} должен быть строкой",
  "$MustBeABool": "${p0} должно быть логическим",
  "$MustBeAnArrayOfStringsOrUnset": "${p0} должен быть массивом строк или не задан",
  "FoundAMismatched$In$ForALiteral$Use$$Instead": "Обнаружено несоответствие ${p0} в \"${p1}\". Вместо этого для литерала ${p2} используйте ${p3}${p4}.",
  "CouldNotFindAValueFor$In$ToWriteTheLiteralValueUse$Instead": "Не удалось найти значение для {${p0}} в \"${p1}\". Чтобы записать литерал, используйте вместо этого \"{{${p2}}}\".",
  "MatchedMoreThanOneInstallBlock$": "Соответствует более чем одному блоку установки [${p0}]",
  "UnableToFindProjectInFolderorParentFoldersFor$": "Не удается найти проект в папке (или родительских папках) для ${p0}",
  "UnableToAcquireProject": "Не удается получить проект",
  "NoArtifactsSpecified": "Артефакты не указаны",
  "NoArtifactsAreAcquired": "Артефакты не приобретены",
  "AllArtifactsAreAlreadyInstalled": "Все артефакты уже установлены",
  "$ArtifactsInstalledSuccessfully": "Артефакты ${p0} успешно установлены",
  "InstallationFailedStopping": "Сбой установки — остановка",
  "MultipleArtifactsSpecifiedButNotAnEqualNumberOf$Switches": "Указано несколько артефактов, но не равное число переключателей ${p0}",
  "TriedToAddAnArtifact$$ButCouldNotDetermineTheRegistryToUse": "Попытка добавить артефакт [${p0}]:${p1}, но не удалось определить используемый реестр.",
  "TriedToAddRegistry$As$ButItWasAlready$PleaseAdd$ToThisProjectManuallyAndReattempt": "Попытка добавить реестр ${p0} как ${p1}, но он уже был ${p2}. Добавьте ${p3} в этот проект вручную и повторите попытку.",
  "RunvcpkgshellActivateToApplyToTheCurrentTerminal": "Запустите команду \\\"vcpkg-shell activate\\\", чтобы применить к текущему терминалу",
  "DownloadsFolderCleared$": "Папка загрузок очищена (${p0}) ",
  "InstalledArtifactFolderCleared$": "Папка с установленными артефактами очищена (${p0}) ",
  "CacheFolderCleared$": "Папка кэша очищена (${p0}) ",
  "DeletingArtifact$From$": "Удаление артефакта ${p0} из ${p1}",
  "NoArtifactsFoundMatchingCriteria$": "Не найдены артефакты, соответствующие критериям: ${p0}",
  "UnableToActivateProject": "Не удается активировать проект",
  "RegeneratingIndexFor$": "Повторное индексирование для ${p0}",
  "RegenerationCompleteIndexContains$MetadataFiles": "Восстановление завершено. Индекс содержит файлы метаданных ${p0}",
  "Registry$ContainsNoArtifacts": "Реестр: \"${p0}\" не содержит артефактов.",
  "error$": "ошибка ${p0}: ",
  "Removing$FromProjectManifest": "Удаление ${p0} из манифеста проекта",
  "unableToFindArtifact$InTheProjectManifest": "не удается найти артефакт ${p0} в манифесте проекта",
  "Updated$ItContains$MetadataFiles": "Обновлено ${p0}. Он содержит файлы метаданных ${p1}.",
  "UnableToDownload$": "Не удалось скачать ${p0}.",
  "$CouldNotBeUpdatedItCouldBeMalformed": "${p0} не удалось обновить. Он может быть неправильно сформирован.",
  "TheXupdateregistryCommandDownloadsNewRegistryInformationAndThusCannotBeUsedWithLocalRegistriesDidYouMeanXregenerate$": "Команда x-update-registry загружает новую информацию реестра и поэтому не может использоваться с локальными реестрами. Вы имели в виду x-regenerate ${p0}?",
  "UnableToFindRegistry$": "Не удается найти реестр ${p0}.",
  "NoArtifactsAreBeingAcquired": "Артефакты не приобретаются",
  "UnableToFindProjectEnvironment$": "Не удается найти среду проекта ${p0}"
}