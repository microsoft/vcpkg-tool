{
  "ABaseline": "基线",
  "ABaselineObject": "基对象",
  "ABoolean": "布尔值",
  "ABuiltinRegistry": "内置注册表",
  "AConfigurationObject": "配置对象",
  "ACpuArchitecture": "CPU 体系结构",
  "ADateVersionString": "日期版本字符串",
  "ADefaultFeature": "默认功能",
  "ADemandObject": "请求对象",
  "ADependency": "依赖项",
  "ADependencyFeature": "依赖项的功能",
  "ADictionaryOfContacts": "联系人字典",
  "AFeature": "功能",
  "AFeatureName": "功能名称",
  "AFilesystemRegistry": "文件系统注册表",
  "AGitObjectSha": "git 对象 SHA",
  "AGitReference": "git 引用(例如分支)",
  "AGitRegistry": "git 注册表",
  "AGitRepositoryUrl": "git 存储库 URL",
  "AManifest": "清单",
  "AMaximumOfOneAssetReadUrlCanBeSpecified": "最多可以指定一个资产读取 URL。",
  "AMaximumOfOneAssetWriteUrlCanBeSpecified": "最多可以指定一个资产写入 URL。",
  "ANonNegativeInteger": "非负整数",
  "APackageName": "包名称",
  "APackagePattern": "包模式",
  "APackagePatternArray": "包模式数组",
  "APath": "路径",
  "APlatformExpression": "平台表达式",
  "ARegistry": "注册表",
  "ARegistryImplementationKind": "注册表实现类型",
  "ARegistryPath": "注册表路径",
  "ARegistryPathMustBeDelimitedWithForwardSlashes": "注册表路径必须使用单个正斜杠作为路径分隔符。",
  "ARegistryPathMustNotHaveDots": "注册表路径不得具有 \"dot\" 或 \"dot dot\" 路径元素。",
  "ARegistryPathMustStartWithDollar": "注册表路径必须以 \"$\" 开头，以表示注册表根目录; 例如 `$/foo/bar`。",
  "ARelaxedVersionString": "宽松的版本字符串",
  "ASemanticVersionString": "语义版本字符串",
  "ASetOfFeatures": "一组功能",
  "ASha512": "SHA-512 哈希",
  "AString": "字符串",
  "AStringOrArrayOfStrings": "字符串或字符串数组",
  "AStringStringDictionary": "\"string\": \"string\" 字典",
  "AToolDataArray": "工具元数据的数组",
  "AToolDataFile": "工具数据文件",
  "AToolDataOS": "工具数据操作系统",
  "AToolDataObject": "工具元数据",
  "AToolDataVersion": "工具数据版本",
  "AUrl": "URL",
  "AVcpkgRepositoryCommit": "vcpkg 存储库提交",
  "AVersionConstraint": "版本约束",
  "AVersionDatabaseEntry": "版本数据库条目",
  "AVersionObject": "版本对象",
  "AVersionOfAnyType": "任何类型的版本",
  "AddArtifactOnlyOne": "“{command_line}” 一次只能添加一个项目。",
  "AddCommandFirstArg": "要添加的第一个参数必须是 “artifact” 或 “port”。",
  "AddPortRequiresManifest": "“{command_line}”需要活动清单文件。",
  "AddPortSucceeded": "已成功将端口添加到 vcpkg.json 文件。",
  "AddRecurseOption": "如果确定要移除它们，请使用 --recurse 选项运行命令。",
  "AddTripletExpressionNotAllowed": "此处不允许使用三元表达式。你可能想要将 `{package_name}:{triplet}` 更改为 `{package_name}`。",
  "AddVersionAddedVersionToFile": "已将版本 {version} 添加到 {path}",
  "AddVersionArtifactsOnly": "--version 仅适用于项目，不能与 vcpkg 添加端口一起使用",
  "AddVersionCommitChangesReminder": "是否记得提交更改?",
  "AddVersionFileNotFound": "找不到所需的文件 {path}",
  "AddVersionFormatPortSuggestion": "运行 `{command_line}` 以设置文件格式",
  "AddVersionIgnoringOptionAll": "忽略 --{option}，因为已提供端口名称参数",
  "AddVersionInstructions": "你可以运行以下命令来自动添加 {package_name} 的当前版本:",
  "AddVersionNewFile": "(新建文件)",
  "AddVersionNewShaIs": "新 SHA: {commit_sha}",
  "AddVersionNoFilesUpdated": "未更新任何文件",
  "AddVersionNoFilesUpdatedForPort": "没有更新 {package_name} 的文件",
  "AddVersionOldShaIs": "旧 SHA: {commit_sha}",
  "AddVersionOverwriteOptionSuggestion": "使用 --{option} 绕过此检查",
  "AddVersionPortFilesShaChanged": "{package_name} 的已签入文件已更改，但版本未更新",
  "AddVersionPortFilesShaUnchanged": "{package_name} 的已签入文件与版本 {version} 没有更改",
  "AddVersionPortHasImproperFormat": "{package_name} 格式不正确",
  "AddVersionPortVersionShouldBeGone": "在 {package_name} 中，{version} 是全新的版本，因此不应有 \"port-version\"。请移除 \"port-version\"，然后重试。若要跳过此检查，请使用 --skip-version-format-check 重新运行。",
  "AddVersionPortVersionShouldBeOneMore": "在 {package_name} 中，{version} 的当前 \"port-version\" 为 {count}，因此新 \"port-version\" 应为 {expected_version}，但端口声明为 \"port-version\" {actual_version}。请将 \"port-version\" 更改为 {expected_version}，然后重试。若要跳过此检查，请使用 --skip-version-format-check 重新运行。",
  "AddVersionSuggestVersionDate": "“{package_name}”的版本格式使用了 “version-string”，但可以接受该格式作为 “version-date”。如果此格式实际上旨在表示 ISO 8601 日期，请将格式更改为 “version-date”，然后重新运行此命令。否则，请通过重新运行此命令并添加 --skip-version-format-check 来禁用此检查。",
  "AddVersionSuggestVersionRelaxed": "“{package_name}”的版本格式使用了 “version-string”，但可以接受该格式作为 “version”。如果此端口的版本可使用宽松版本规则进行排序，请将格式更改为 “version”，然后重新运行此命令。宽松版本规则按每个数字组件对版本进行排序。然后，带有短划线后缀的版本按字典顺序排序（排在其他版本之前）。加号内部版本标记将被忽略。示例:\n1.0 < 1.1-alpha < 1.1-b < 1.1 < 1.1.1 < 1.2+内部版本 = 1.2 < 2.0\n请特别注意，短划线后缀排在 *前面*，而不是后面。1.0-任何内容 < 1.0\n请注意，此排序顺序与语义版本控制中选择的排序顺序相同(请参阅 https://semver.org)，即使语义部分实际上并不适用。\n如果此端口的版本未按这些规则排序，请通过重新运行此命令并添加 --skip-version-format-check 来禁用此检查。",
  "AddVersionUpdateVersionReminder": "是否记得更新版本或端口版本?",
  "AddVersionUseOptionAll": "没有参数的 {command_name} 需要传递 --{option} 才能一次性更新所有端口版本",
  "AddVersionVersionAlreadyInFile": "版本 {version} 已在 {path} 中",
  "AddVersionVersionIs": "版本: {version}",
  "AddingCompletionEntry": "正在将 vcpkg 完成项添加到 {path}。",
  "AdditionalPackagesToExport": "需要导出其他包(*)才能完成此操作。",
  "AdditionalPackagesToRemove": "需要移除其他包(*)才能完成此操作。",
  "AllFeatureTestsPassed": "已通过所有功能测试。",
  "AllFormatArgsRawArgument": "格式字符串 \"{value}\" 包含原始格式参数",
  "AllFormatArgsUnbalancedBraces": "格式字符串中的不均衡大括号 \"{value}\"",
  "AllPackagesAreUpdated": "未执行任何操作，因为所有已安装的包都是最新的。",
  "AllShasValid": "所有已检查的 sha 均有效。",
  "AlreadyInstalled": "已安装 {spec}",
  "AmbiguousConfig": "清单和配置文件均提供的 vcpkg 配置不明确。通过删除此文件或从清单文件中删除 “{json_field}” 来选择一个文件。",
  "AnArrayOfDefaultFeatures": "默认功能的数组",
  "AnArrayOfDependencies": "依赖项数组",
  "AnArrayOfDependencyOverrides": "依赖项重写的数组",
  "AnArrayOfFeatures": "一个功能数组",
  "AnArrayOfIdentifers": "标识符数组",
  "AnArrayOfOverlayPaths": "覆盖路径数组",
  "AnArrayOfOverlayTripletsPaths": "覆盖三元组路径的数组",
  "AnArrayOfRegistries": "注册表数组",
  "AnArrayOfVersions": "版本数组",
  "AnArtifactsGitRegistryUrl": "项目 git 注册表 URL",
  "AnArtifactsRegistry": "项目注册表",
  "AnExactVersionString": "确切的版本字符串",
  "AnIdentifer": "标识符",
  "AnObjectContainingVcpkgArtifactsMetadata": "包含 vcpkg-artifacts 元数据的对象",
  "AnOverlayPath": "覆盖路径",
  "AnOverlayTripletsPath": "三元路径",
  "AnOverride": "替代",
  "AnSpdxLicenseExpression": "SPDX 许可证表达式",
  "AnotherInstallationInProgress": "计算机上正在进行另一个安装，重试前休眠 6 秒。",
  "AppliedUserIntegration": "已为此 vcpkg 根应用用户范围的集成。",
  "ApplocalProcessing": "正在部署依赖项",
  "ArtifactsBootstrapFailed": "vcpkg-artifacts 未安装，无法启动。",
  "ArtifactsOptionIncompatibility": "--{option} 对查找项目没有影响。",
  "ArtifactsOptionJson": "记录环境变量和其他属性的 JSON 文件的完整路径",
  "ArtifactsOptionMSBuildProps": "将写入 MSBuild 属性的文件的完整路径",
  "ArtifactsOptionVersion": "要匹配的版本或版本范围; 仅对项目有效",
  "ArtifactsOptionVersionMismatch": "--version 开关的数目必须与命名项目数匹配",
  "ArtifactsSwitchARM": "获取项目时强制对 ARM 进行主机检测",
  "ArtifactsSwitchARM64": "获取项目时强制对 ARM64 进行主机检测",
  "ArtifactsSwitchAllLanguages": "获取项目时获取所有语言文件",
  "ArtifactsSwitchForce": "如果已获取项目，则强制重新查询",
  "ArtifactsSwitchFreebsd": "获取项目时强制对 FreeBSD 进行主机检测",
  "ArtifactsSwitchLinux": "获取项目时强制对 Linux 进行主机检测",
  "ArtifactsSwitchOnlyOneHostPlatform": "只能设置一个主机平台 (--x64, --x86, --arm, --arm64)。",
  "ArtifactsSwitchOnlyOneOperatingSystem": "只能设置一个操作系统 (--windows, --osx, --linux, --freebsd)。",
  "ArtifactsSwitchOnlyOneTargetPlatform": "只能设置一个目标平台 (--target:x64, --target:x86, --target:arm, --target:arm64)。",
  "ArtifactsSwitchOsx": "获取项目时强制对 MacOS 进行主机检测",
  "ArtifactsSwitchTargetARM": "获取项目时将目标检测设置为 ARM",
  "ArtifactsSwitchTargetARM64": "获取项目时将目标检测设置为 ARM64",
  "ArtifactsSwitchTargetX64": "获取项目时将目标检测设置为 x64",
  "ArtifactsSwitchTargetX86": "获取项目时将目标设置为 x86",
  "ArtifactsSwitchWindows": "获取项目时强制对 Windows 进行主机检测",
  "ArtifactsSwitchX64": "获取项目时强制对 x64 进行主机检测",
  "ArtifactsSwitchX86": "获取项目时强制对 x86 进行主机检测",
  "AssetCacheConsult": "正在尝试使用资产缓存 {url} 下载 {path}",
  "AssetCacheConsultScript": "正在尝试使用资产缓存脚本下载 {path}",
  "AssetCacheHit": "下载成功！资产缓存命中。",
  "AssetCacheHitUrl": "下载成功！资产缓存命中，未尝试权威源 {url}",
  "AssetCacheMiss": "资产缓存未命中;正在尝试权威源 {url}",
  "AssetCacheMissBlockOrigin": "没有资产缓存命中，以及尝试权威源 {url} 的 x 块原点块",
  "AssetCacheMissNoUrls": "资产缓存缺少查找 {sha}，并且没有已知的权威 URL",
  "AssetCacheProviderAcceptsNoArguments": "意外参数:“{value}”不接受参数",
  "AssetCacheScriptBadVariable": "脚本模板 {value} 包含未知的替换 {list}",
  "AssetCacheScriptBadVariableHint": "如果希望在文本命令行上使用此项，请使用 {{list}}}}}",
  "AssetCacheScriptCommandLine": "完整脚本命令行是",
  "AssetCacheScriptFailed": "资产缓存脚本返回非零退出代码 {exit_code}",
  "AssetCacheScriptFailedToWriteCorrectHash": "资产缓存脚本返回成功，但生成的文件具有意外的哈希",
  "AssetCacheScriptFailedToWriteFile": "资产缓存脚本返回成功，但未创建预期结果文件",
  "AssetCacheScriptNeedsSha": "脚本模板 {value} 需要 SHA，但已知没有 SHA 尝试下载 {url}",
  "AssetCacheScriptNeedsUrl": "脚本模板 {value} 需要 URL，但是没有 URL 可用于尝试下载 {sha}",
  "AssetSourcesArg": "缓存添加源。请参阅“vcpkg 帮助 assetcaching”。",
  "AttemptingToSetBuiltInBaseline": "尝试在 vcpkg.json 中设置内置基线，同时重写 vcpkg-configuration.json 中的 default-registry。\n系统将使用 vcpkg-configuration.json 中的 default-registry。",
  "AuthenticationMayRequireManualAction": "一个或多个 {vendor} 凭据提供程序请求手动操作。添加二进制源 “interactive” 以允许交互。",
  "AutoSettingEnvVar": "-- 正在将 {env_var} 环境变量自动设置为“{url}”。",
  "AutomaticLinkingForMSBuildProjects": "所有 MSBuild C++ 项目现在可以包含(#include)任何已安装的库。系统将自动处理链接。安装新库将使它们立即可用。",
  "AutomaticLinkingForVS2017AndLater": "Visual Studio 2017 及更高版本现在可包含(#include)任何已安装的库。系统将自动处理链接。安装新库将使它们立即可用。",
  "AvailableHelpTopics": "可用的帮助主题:",
  "AzUrlAssetCacheRequiresBaseUrl": "意外参数: 资产配置“azurl”需要基 URL",
  "AzUrlAssetCacheRequiresLessThanFour": "意外参数: 资产配置 \"azurl\" 需要的参数少于 4 个",
  "AzcopyFailedToPutBlob": "azcopy 未能将文件上传到 {url}，退出代码为 {exit_code}，http 代码为 {value}。",
  "BaselineConflict": "在清单文件中指定 vcpkg-configuration.default-registry 的操作与内置基线冲突。\n请删除其中一个冲突设置。",
  "BaselineGitShowFailed": "提交 '{commit_sha}' 签出基线时，无法“git show”版本/基线.json。可以通过使用“git fetch”提取提交来修复此问题。",
  "BaselineMissing": "{package_name} 未分配版本",
  "BaselineOnlyPlatformExpressionOrTriplet": "无法指定平台表达式和三元组",
  "BinariesRelativeToThePackageDirectoryHere": "二进制文件相对于此处的 ${{CURRENT_PACKAGES_DIR}}",
  "BinarySourcesArg": "二进制缓存源。请参阅“vcpkg 帮助 binarycaching”。",
  "BinaryWithInvalidArchitecture": "{path} 专为 {arch} 生成",
  "BuildAlreadyInstalled": "已安装{spec}；请在尝试生成之前先删除{spec}。",
  "BuildDependenciesMissing": "内部版本命令要求已安装所有依赖项。\n缺少以下依赖项:",
  "BuildResultBuildFailed": "BUILD_FAILED",
  "BuildResultCacheMissing": "CACHE_MISSING",
  "BuildResultCascadeDueToMissingDependencies": "CASCADED_DUE_TO_MISSING_DEPENDENCIES",
  "BuildResultDownloaded": "已下载",
  "BuildResultExcluded": "已排除",
  "BuildResultFileConflicts": "FILE_CONFLICTS",
  "BuildResultPostBuildChecksFailed": "POST_BUILD_CHECKS_FAILED",
  "BuildResultRemoved": "已删除",
  "BuildResultSucceeded": "成功",
  "BuildResultSummaryHeader": "{triplet} 的摘要",
  "BuildResultSummaryLine": "{build_result}: {count} 个",
  "BuildTreesRootDir": "Buildtrees 目录(实验性)",
  "BuildTroubleshootingMessage1": "请确保使用具有“git pull” 和 “vcpkg update”的最新端口文件。\n然后，在以下位置查看已知问题:",
  "BuildTroubleshootingMessage2": "可在以下位置提交新问题:",
  "BuildTroubleshootingMessage3": "在 Bug 报告标题中包含“[{package_name}] 内部版本错误”，bug 描述中的以下版本信息，并从上面附加任何相关的失败日志。",
  "BuildTroubleshootingMessageGH": "还可通过运行来提交问题(必须安装 GitHub CLI):",
  "BuildingFromHead": "正在从 HEAD 生成 {spec}...",
  "BuildingPackage": "正在生成 {spec}...",
  "BuildingPackageFailed": "生成 {spec} 失败，结果为: {build_result}",
  "BuildingPackageFailedDueToMissingDeps": "由于缺少以下依赖项:",
  "BuiltInTriplets": "内置三元组:",
  "BuiltWithIncorrectArchitecture": "三元组要求为 {arch} 生成二进制文件，但以下二进制文件是为其他体系结构生成的。这通常表示工具链信息未正确传递给二进制文件的生成系统。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_ARCHITECTURE_CHECK enabled)",
  "CISettingsOptCIBase": "ci.baseline.txt 文件的路径。用于跳过端口和检测回归。",
  "CISettingsOptExclude": "要跳过的端口的列表(端口间以逗号分隔)",
  "CISettingsOptFailureLogs": "将故障日志复制到的目录",
  "CISettingsOptHostExclude": "主机三元组要跳过的端口列表(端口间以逗号分隔)",
  "CISettingsOptKnownFailuresFrom": "已知包生成失败的文件的路径",
  "CISettingsOptOutputHashes": "用于输出所有已确定的包哈希的文件",
  "CISettingsOptParentHashes": "用于读取父 CI 状态的包哈希的文件，可减少已更改的包集",
  "CISettingsOptXUnit": "用于以 XUnit 格式输出结果的文件",
  "CISettingsVerifyGitTree": "验证每个 git 树对象是否与其声明的版本匹配(速度非常慢)",
  "CISettingsVerifyVersion": "打印每个端口的结果，而不是仅打印错误",
  "CISkipInstallation": "以下包已安装，将不再生成:",
  "CISwitchOptAllowUnexpectedPassing": "取消显示“传递，从失败列表中删除”结果",
  "CISwitchOptDryRun": "打印出计划而不执行",
  "CISwitchOptRandomize": "实现安装顺序的随机化",
  "CISwitchOptSkipFailures": "跳过 ci.baseline.txt 中标记为“=fail”的端口",
  "CISwitchOptXUnitAll": "报告 XUnit 输出中未更改的端口",
  "CMakePkgConfigTargetsUsage": "{package_name} 提供 pkg-config 模块:",
  "CMakeTargetsUsage": "{package_name} 提供 CMake 目标:",
  "CMakeTargetsUsageHeuristicMessage": "# 这是启发式生成的，并且可能不正确",
  "CMakeToolChainFile": "CMake 项目应使用:“-DCMAKE_TOOLCHAIN_FILE={path}”",
  "CMakeUsingExportedLibs": "要在 CMake 项目中使用导出的库，请将 {value} 添加到 CMake 命令行。",
  "ChecksFailedCheck": "vcpkg 已崩溃；没有其他详细信息可用。",
  "ChecksUnreachableCode": "已访问无法访问的代码",
  "ChecksUpdateVcpkg": "通过重新运行 bootstrap-vcpkg 更新 vcpkg 可能会解决此故障。",
  "CiBaselineAllowUnexpectedPassingRequiresBaseline": "只有当通过 --ci-baseline 提供基线时才能使用 --allow-unexpected-passing。",
  "CiBaselineDisallowedCascade": "回归: {spec} 已级联，但需要它才能通过。({path})。",
  "CiBaselineIndependentRegression": "REGRESSION: 独立 {spec} 失败，出现 {build_result}。",
  "CiBaselineRegression": "REGRESSION: {spec} 失败，结果为 {build_result}。如果在预期之内，则添加 {spec}=fail to {path}。",
  "CiBaselineRegressionHeader": "回归测试:",
  "CiBaselineRegressionNoPath": "REGRESSION: {spec} 失败，结果为 {build_result}。",
  "CiBaselineUnexpectedFail": "REGRESSION: {spec} 被标记为失败，但 {triplet} 不支持。",
  "CiBaselineUnexpectedFailCascade": "REGRESSION: {spec} 被标记为失败，但 {triplet} 不支持一个依赖项。",
  "CiBaselineUnexpectedPass": "正在通过，从失败列表中删除: {spec} ({path})。",
  "ClearingContents": "正在清除 {path} 的内容",
  "CmakeTargetsExcluded": "未显示其他 {count} 个目标。",
  "CmdAcquireExample1": "vcpkg 获取 <artifact>",
  "CmdAcquireProjectSynopsis": "获取清单引用的所有项目",
  "CmdAcquireSynopsis": "获取命名的项目",
  "CmdActivateSynopsis": "从清单激活项目",
  "CmdAddExample1": "vcpkg 添加端口 <port name>",
  "CmdAddExample2": "vcpkg 添加项目 <artifact name>",
  "CmdAddSynopsis": "将依赖项添加到清单",
  "CmdAddVersionExample1": "vcpkg x-add-version <port name>",
  "CmdAddVersionOptAll": "处理所有端口的版本",
  "CmdAddVersionOptOverwriteVersion": "覆盖现有版本的 git 树",
  "CmdAddVersionOptSkipFormatChk": "跳过 vcpkg.json 文件的格式检查",
  "CmdAddVersionOptSkipVersionFormatChk": "跳过版本格式检查",
  "CmdAddVersionOptVerbose": "打印成功消息，而不是仅打印错误",
  "CmdAddVersionSynopsis": "将版本添加到版本数据库",
  "CmdBootstrapStandaloneSynopsis": "仅从 vcpkg 二进制文件启动 vcpkg 根",
  "CmdBuildExample1": "vcpkg 生成 <port spec>",
  "CmdBuildExternalExample1": "vcpkg build-external <port name> <source path>",
  "CmdBuildExternalExample2": "vcpkg build-external zlib2 C:\\path\\to\\dir\\with\\vcpkg.json",
  "CmdBuildExternalSynopsis": "从路径生成端口",
  "CmdBuildSynopsis": "生成端口",
  "CmdCheckSupportExample1": "vcpkg x-check-support <port name>",
  "CmdCheckSupportSynopsis": "测试在不生成端口的情况下是否支持端口",
  "CmdCheckToolsShaSwitchFix": "修复给定文件中的 sha 条目",
  "CmdCheckToolsShaSwitchOnlyWithName": "仅检查具有给定名称的条目",
  "CmdCheckToolsShaSynopsis": "通过下载所有条目并计算哈希来检查工具数据文件中的 sha512 条目",
  "CmdCiCleanSynopsis": "清除所有文件以准备 CI 运行",
  "CmdCiSynopsis": "尝试生成用于 CI 测试的所有端口",
  "CmdCiVerifyVersionsSynopsis": "检查版本数据库的完整性",
  "CmdCreateExample1": "vcpkg 创建 <port name> <uri>",
  "CmdCreateExample2": "vcpkg 创建 my-fancy-port https://example.com/sources.zip",
  "CmdCreateExample3": "vcpkg 创建 <port name> <uri> <downloaded filename>",
  "CmdDeactivateSynopsis": "从当前 shell 中删除所有项目激活",
  "CmdDependInfoExample1": "vcpkg depend-info <port name>",
  "CmdDependInfoFormatConflict": "指定的格式冲突。只接受 --format、--dgml 或 --dot 中的一个。",
  "CmdDependInfoFormatHelp": "选择输出格式，从 `list`、`tree`、 `mermaid`、`dot` 或 `dgml` 中选择一个",
  "CmdDependInfoFormatInvalid": "--format={value} 不是可识别的格式。--format 必须是 `list`、`tree`、 `mermaid`、`dot` 或 `dgml` 中的一个。",
  "CmdDependInfoOptDepth": "在 `list` 输出中显示递归深度",
  "CmdDependInfoOptMaxRecurse": "设置最大递归深度。默认值没有限制",
  "CmdDependInfoOptSort": "选择 `list` 格式的排序顺序，从 `lexicographical`、`topological` (默认) 和 `reverse` 中选择一个",
  "CmdDependInfoShowDepthFormatMismatch": "--show-depth 只能与 `list` 和 `tree` 格式一起使用。",
  "CmdDependInfoXtreeTree": "--sort=x-tree 不能与 tree 以外的格式一起使用",
  "CmdDownloadExample1": "vcpkg x-download <filepath> <sha512> --url=https://...",
  "CmdDownloadExample2": "vcpkg x-download <filepath> --sha512=<sha512> --url=https://...",
  "CmdDownloadExample3": "vcpkg x-download <filepath> --skip-sha512 --url=https://...",
  "CmdDownloadSynopsis": "下载文件",
  "CmdEditExample1": "vcpkg 编辑<port name>",
  "CmdEditOptAll": "打开编辑器以进入端口以及特定于端口的生成树子文件夹",
  "CmdEditOptBuildTrees": "打开编辑器以进入特定于端口的生成树子文件夹",
  "CmdEnvOptions": "将安装的 {path} 添加到 {env_var}",
  "CmdExportEmptyPlan": "拒绝创建零包导出。在导出之前安装包。",
  "CmdExportExample1": "vcpkg export <port names> [--nuget] [--output-dir=out_dir]",
  "CmdExportOpt7Zip": "导出为 7zip (.7z)文件",
  "CmdExportOptDereferenceSymlinks": "将符号链接复制为导出结果中的常规文件和目录",
  "CmdExportOptDryRun": "不实际导出",
  "CmdExportOptInstalled": "导出所有安装的包",
  "CmdExportOptNuget": "导出 NuGet 包",
  "CmdExportOptRaw": "导出到未压缩的目录",
  "CmdExportOptZip": "导出为 zip 文件",
  "CmdExportSettingNugetDesc": "导出的 NuGet 包的说明",
  "CmdExportSettingNugetID": "导出的 NuGet 包的 ID (替代 --output)",
  "CmdExportSettingNugetVersion": "导出的 NuGet 包的版本",
  "CmdExportSettingOutput": "输出名称(用于构造文件名)",
  "CmdExportSettingOutputDir": "生成项目的输出目录",
  "CmdExportSynopsis": "创建已安装端口的独立部署",
  "CmdFetchOptXStderrStatus": "将状态/下载消息打印到 stderr 而不是 stdout。(错误/失败仍会转到 stdout)",
  "CmdFetchSynopsis": "从系统或 Internet 提取内容",
  "CmdFindExample1": "vcpkg 查找端口 <port name>",
  "CmdFindExample2": "vcpkg 查找项目 <artifact name>",
  "CmdFindSynopsis": "查找可能已安装或激活的端口或项目",
  "CmdFormatFeatureBaselineExample": "vcpkg format-feature-baseline <ci.feature.baseline.txt path>",
  "CmdFormatFeatureBaselineSynopsis": "设置功能基线文件的格式",
  "CmdFormatManifestExample1": "vcpkg format-manifest <vcpkg.json path>",
  "CmdFormatManifestOptAll": "设置所有端口的清单文件的格式",
  "CmdFormatManifestOptConvertControl": "将 CONTROL 文件转换为清单文件",
  "CmdFormatManifestSynopsis": "Prettyfies vcpkg.json",
  "CmdGenerateMSBuildPropsExample1": "vcpkg generate-msbuild-props --msbuild-props <path>",
  "CmdGenerateMSBuildPropsExample2": "vcpkg generate-msbuild-props --msbuild-props out.props",
  "CmdGenerateMSBuildPropsSynopsis": "生成 msbuild .props 文件(就像激活清单的项目依赖项一样)，而不获取它们",
  "CmdGenerateMessageMapOptNoOutputComments": "生成消息映射时，排除注释(可用于生成英语本地化文件)",
  "CmdHashExample1": "vcpkg 哈希 <path>",
  "CmdHashExample2": "vcpkg 哈希 <path> SHA256",
  "CmdHashSynopsis": "获取文件的 SHA256 或 SHA512",
  "CmdHelpCommandSynopsis": "显示 <command> 的帮助详细信息",
  "CmdHelpCommands": "帮助 <command>",
  "CmdHelpCommandsSynopsis": "显示命令的完整列表，包括此处未列出的罕见命令",
  "CmdHelpTopic": "帮助 <topic>",
  "CmdInfoOptInstalled": "(实验性)报告安装的包，而不是可用的包",
  "CmdInfoOptTransitive": "(实验性)另请报告已安装包的依赖项",
  "CmdInitRegistryExample1": "vcpkg x-init-registry <path>",
  "CmdInitRegistrySynopsis": "创建空白 GIT 注册表",
  "CmdInstallExample1": "vcpkg 安装 <port name> <port name>...",
  "CmdIntegrateSynopsis": "将 vcpkg 与计算机、项目或 shell 集成",
  "CmdLicenseReportSynopsis": "显示已安装树中所有端口的声明许可证",
  "CmdListExample2": "vcpkg 列表 <filter>",
  "CmdNewExample1": "vcpkg new --name=example --version=1.0",
  "CmdNewOptApplication": "创建应用程序清单(不需要名称或版本)",
  "CmdNewOptSingleFile": "将 vcpkg-configuration.json 嵌入 vcpkg.json",
  "CmdNewOptVersionDate": "将 --version 解释为 ISO 8601 日期。(YYYY-MM-DD)",
  "CmdNewOptVersionRelaxed": "将 --version 解释为宽松的数字版本(非负数且以点分隔)",
  "CmdNewOptVersionString": "将 --version 解释为没有排序行为的字符串",
  "CmdNewSettingName": "新清单的名称",
  "CmdNewSettingVersion": "新清单的版本",
  "CmdNewSynposis": "新建清单",
  "CmdOptForMergeWith": "用于与此 git 引用合并的测试端口",
  "CmdOwnsExample1": "vcpkg 拥有 <pattern>",
  "CmdPackageInfoExample1": "vcpkg x-package-info <package name>...",
  "CmdPortsdiffExample1": "vcpkg portsdiff <branch name>",
  "CmdPortsdiffExample2": "vcpkg portsdiff <from> <to>",
  "CmdPortsdiffSynopsis": "区分提交之间端口版本中的更改",
  "CmdRegenerateOptDryRun": "不实际执行操作，仅显示将要执行的操作",
  "CmdRegenerateOptForce": "继续执行(可能具有危险的)操作而不进行确认",
  "CmdRegenerateOptNormalize": "应用任何弃用修补程序",
  "CmdRemoveExample1": "vcpkg 删除 <package name>...",
  "CmdRemoveOptDryRun": "打印要移除的包，但不要移除它们",
  "CmdRemoveOptOutdated": "删除版本与内置注册表不匹配的的所有包",
  "CmdRemoveOptRecurse": "允许删除未显式指定的从属包",
  "CmdSearchExample1": "vcpkg 搜索 <pattern>",
  "CmdSetInstalledExample1": "vcpkg x-set-installed <package name> <package name>...",
  "CmdSetInstalledOptDryRun": "不实际生成或安装",
  "CmdSetInstalledOptNoUsage": "不要在安装后打印 CMake 使用情况信息",
  "CmdSetInstalledOptWritePkgConfig": "写入 NuGet packages.config 格式的文件以用于外部二进制缓存。有关详细信息，请参阅 `vcpkg help binarycaching`。",
  "CmdSetInstalledSynopsis": "安装、升级或删除包，以便包与提供的包完全匹配",
  "CmdSettingCopiedFilesLog": "要创建的复制文件日志的路径",
  "CmdSettingInstalledDir": "要使用的已安装树的路径",
  "CmdSettingTLogFile": "要创建的 tlog 文件的路径",
  "CmdSettingTargetBin": "要分析的二进制文件的路径",
  "CmdTestCIFeatureBaseline": "ci.feature.baseline.txt 文件的路径。用于跳过已知的失败测试端口并检测回归",
  "CmdTestFeaturesAll": "对所有端口运行测试",
  "CmdTestFeaturesFailingAbis": "将写入所有失败的 ABI 哈希的文件的路径",
  "CmdTestFeaturesNoCombined": "跳过对每个已启用功能的测试",
  "CmdTestFeaturesNoCore": "仅在启用 ‘core’ 功能时跳过测试",
  "CmdTestFeaturesNoSeparated": "跳过单独测试每个功能",
  "CmdTestFeaturesSynopsis": "测试端口的功能",
  "CmdUpdateBaselineOptDryRun": "打印出计划而不执行",
  "CmdUpdateBaselineOptInitial": "将 `builtin-baseline` 添加到尚无该命令的 vcpkg.json",
  "CmdUpdateBaselineSynopsis": "将清单中 git 注册表的基线更新为这些注册表的 HEAD提交",
  "CmdUpdateRegistryAll": "更新所有已知项目注册表",
  "CmdUpdateRegistryAllExcludesTargets": "更新注册表 --不能与项目注册表列表一起使用全部",
  "CmdUpdateRegistryAllOrTargets": "更新注册表需要项目注册表名称列表或要更新的 URiI 或 --全部。",
  "CmdUpdateRegistryExample3": "vcpkg x-update-registry <artifact registry name>",
  "CmdUpdateRegistrySynopsis": "重新下载项目注册表",
  "CmdUpgradeOptNoDryRun": "实际升级",
  "CmdUpgradeOptNoKeepGoing": "失败时停止安装包",
  "CmdUseExample1": "vcpkg 使用 <artifact name>",
  "CmdUseSynopsis": "激活此 shell 中的单个项目",
  "CmdVSInstancesSynopsis": "列出检测到的 Visual Studio 实例",
  "CmdXDownloadOptHeader": "从 URL 提取时要使用的其他标头",
  "CmdXDownloadOptSha": "要下载的文件的哈希",
  "CmdXDownloadOptSkipSha": "跳过对已下载文件的 SHA512 的检查",
  "CmdXDownloadOptStore": "存储文件应比提取文件更重要",
  "CmdXDownloadOptUrl": "要下载和存储的 URL (如果缓存中缺失)",
  "CmdZApplocalSynopsis": "将二进制文件的依赖项从安装的树复制到该二进制文件的位置以进行应用本地部署",
  "CmdZExtractExample1": "vcpkg z-extract <archive path> <output directory>",
  "CmdZExtractExample2": "vcpkg z-extract source.zip source_dir --strip 2",
  "CmdZExtractOptStrip": "要从所有路径中去除的前导目录数",
  "CommandEnvExample2": "vcpkg env \"ninja -C <path>\" --triplet x64-windows",
  "CommandFailed": "命令:\n{command_line}\n失败，输出如下:",
  "CommunityTriplets": "社区三元组:",
  "CompilerPath": "已找到编译器: {path}",
  "ComputeAllAbis": "正在计算所有 ABI 哈希...",
  "ComputeInstallPlans": "正在计算 {count} 个安装计划...",
  "ComputingInstallPlan": "正在计算安装计划...",
  "ConfigurationErrorRegistriesWithoutBaseline": "{path} 中定义的配置无效。\n\n使用注册表需要为默认注册表设置基线，或者默认注册表为 null。\n\n有关更多详细信息，请参阅 {url}。",
  "ConfigurationNestedDemands": "[\"{json_field}\"] 包含嵌套的'需求'对象(嵌套的'需求'不起作用)",
  "ConflictingEmbeddedConfiguration": "只能使用 {{\"configuration\", \"vcpkg-configuration\"}} 之一",
  "ConflictingFiles": "以下文件已安装在 {path} 中，并与 {spec} 发生冲突",
  "ConsideredVersions": "考虑了以下可执行文件，但由于 {version} 的版本要求而被放弃:",
  "ConstraintViolation": "发现约束冲突:",
  "ContinueCodeUnitInStart": "在“开始”位置找到了继续码位",
  "ControlCharacterInString": "字符串中的控件字符",
  "ControlSupportsMustBeAPlatformExpression": "“Supports”必须是平台表达式",
  "CopyrightIsDir": "此端口将 ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/copyright 设置为目录，但它应该是一个文件。请考虑使用 vcpkg_install_copyright 将单独的 copyright 文件组合成一个文件。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_COPYRIGHT_CHECK enabled)",
  "CorruptedDatabase": "vcpkg 的安装数据库已损坏。这可能是 vcpkg 中的 bug，也可能是其他内容以意外方式修改了“已安装”目录的内容。可以通过删除“已安装”目录并重新安装要使用的内容来解决此问题。如果此问题持续发生，请在 https://github.com/microsoft/vcpkg 提交 bug。",
  "CouldNotDeduceNugetIdAndVersion": "无法从文件名推导出 nuget ID 和版本: {path}",
  "CouldNotFindBaselineInCommit": "在 {url} 的 {commit_sha} 中找不到 {package_name} 的基线。",
  "CouldNotFindGitTreeAtCommit": "在提交 {commit_sha} 的存储库 {package_name} 中找不到 `versions` 的 git 树",
  "CouldNotFindVersionDatabaseFile": "找不到版本数据库文件: {path}",
  "CreateFailureLogsDir": "正在创建失败日志输出目录 {path}。",
  "CreatedNuGetPackage": "已创建 nupkg: {path}",
  "Creating7ZipArchive": "正在创建 7zip 存档...",
  "CreatingNugetPackage": "正在创建 NuGet 包...",
  "CreatingZipArchive": "正在创建 zip 存档...",
  "CreationFailed": "创建 {path} 失败。",
  "CurlFailedGeneric": "curl 操作失败，错误代码 {exit_code}。",
  "CurlFailedToPut": "curl 无法将文件放入 {url}，退出代码为 {exit_code}。",
  "CurlFailedToPutHttp": "curl 无法将文件放入 {url}，退出代码为 {exit_code}，http 代码为 {value}。",
  "CurlFailedToReturnExpectedNumberOfExitCodes": "curl 未能返回预期数量的退出代码;如果某些内容在卷曲完成之前终止，则可能会发生这种情况。curl 已退出，{exit_code} 这通常是上一个操作的结果代码，但可能是故障的结果。命令行已 {command_line}，并且所有输出如下：",
  "CurrentCommitBaseline": "可以将当前提交用作基线，即:\n\t\"builtin-baseline\": \"{commit_sha}\"",
  "CycleDetectedDuring": "在 {spec} 期间检测到循环:",
  "DefaultBinaryCachePlatformCacheRequiresAbsolutePath": "环境变量 VCPKG_DEFAULT_BINARY_CACHE 必须是目录(曾为: {path})",
  "DefaultBinaryCacheRequiresAbsolutePath": "环境变量 VCPKG_DEFAULT_BINARY_CACHE 必须是绝对(曾为: {path})",
  "DefaultBinaryCacheRequiresDirectory": "环境变量 VCPKG_DEFAULT_BINARY_CACHE 必须是目录(曾为: {path})",
  "DefaultFeatureCore": "功能“核心”关闭默认功能，因此不能位于默认功能列表中",
  "DefaultFeatureDefault": "功能“default”引用默认功能集，因此不能位于默认功能列表中",
  "DefaultFeatureIdentifier": "默认功能的名称必须是标识符",
  "DefaultFlag": "默认为 --{option} 处于打开状态。",
  "DefaultRegistryIsArtifact": "默认注册表不能是项目注册表。",
  "DependencyFeatureCore": "功能“核心”不能位于依赖项的功能列表中。要关闭默认功能，请改为添加 \"default-features\": false。",
  "DependencyFeatureDefault": "功能“默认”不能位于依赖项的功能列表中。要打开默认功能，请改为添加“default-features”: true。",
  "DependencyGraphCalculation": "已启用依赖项关系图提交。",
  "DependencyGraphFailure": "依赖项关系图提交失败。",
  "DependencyGraphSuccess": "依赖项关系图提交成功。",
  "DependencyInFeature": "依赖项位于名为 {feature} 的功能中",
  "DependencyNotInVersionDatabase": "版本数据库中不存在依赖项 {package_name}；该端口是否存在?",
  "DependencyWillFail": "依赖项 {feature_spec} 将不会生成 => 级联",
  "DetectCompilerHash": "正在检测三元组 {triplet} 的编译器哈希...",
  "DirectoriesRelativeToThePackageDirectoryHere": "目录相对于此处的 ${{CURRENT_PACKAGES_DIR}}",
  "DllsRelativeToThePackageDirectoryHere": "DLL 相对于此处的 ${{CURRENT_PACKAGES_DIR}}",
  "DocumentedFieldsSuggestUpdate": "如果这些是应识别的文档字段，请尝试更新 vcpkg 工具。",
  "DownloadAvailable": "此工具的可下载副本可用，可通过取消设置 {env_var} 使用它。",
  "DownloadFailedHashMismatch": "下载自 {url} 具有意外的哈希",
  "DownloadFailedHashMismatchActualHash": "实际： {sha}",
  "DownloadFailedHashMismatchExpectedHash": "应为： {sha}",
  "DownloadFailedHashMismatchZero": "下载失败，因为预期的 SHA512 全部为零，请将预期 SHA512 更改为： {sha}",
  "DownloadFailedProxySettings": "如果使用的是代理，请确保代理设置正确无误。\n可能的原因为:\n1. 实际上使用的是 HTTP 代理，但 HTTPS_PROXY 变量设置为 `https//address:port`。\n这是不正确的，因为 `https://` 前缀声明了代理是 HTTPS 代理，而你的代理(v2ray、shadowsocksr 等)是 HTTP 代理。\n请尝试改为将 `http://address:port` 设置为 HTTP_PROXY 和 HTTPS_PROXY。\n2. 如果使用的是 Windows，则 vcpkg 将自动使用代理软件设置的 Windows IE 代理设置。请参阅: https://github.com/microsoft/vcpkg-tool/pull/77\n代理设置的值可能错误，或者出现相同的 `https://` 前缀问题。\n3. 代理的远程服务器已停止服务。\n如果认为这不是临时下载服务器故障，并且需要更改 vcpkg 才能从其他位置下载此文件，请向 https://github.com/Microsoft/vcpkg/issues 提交问题",
  "DownloadFailedRetrying": "下载 {url} 失败 - 将在 {value} 毫秒后重试",
  "DownloadFailedStatusCode": "{url}: 失败: 状态代码为 {value}",
  "DownloadOrUrl": "或 {url}",
  "DownloadRootsDir": "下载目录(默认值: {env_var})",
  "DownloadSuccesful": "已成功下载 {path}",
  "DownloadSuccesfulUploading": "已成功下载 {path}，存储到 {url}",
  "DownloadTryingAuthoritativeSource": "正在尝试 {url}",
  "DownloadWinHttpError": "{url}: {system_api} 失败，退出代码为 {exit_code}。",
  "DownloadedSources": "已下载的 {spec} 源",
  "DownloadingAssetShaToFile": "正在下载资产缓存项 {sha} -> {path}",
  "DownloadingAssetShaWithoutAssetCache": "已请求下载资产缓存条目 {sha} -> {path}，但未配置任何资产缓存",
  "DownloadingFile": "正在下载 {path}",
  "DownloadingFileFirstAuthoritativeSource": "正在下载 {path}，正在尝试 {url}",
  "DownloadingPortableToolVersionX": "找不到合适的 {tool_name} 版本(所需的 v{version})。",
  "DownloadingTools": "正在下载 {count} 个工具",
  "DownloadingUrlToFile": "正在下载 {url} -> {path}",
  "DownloadingVcpkgStandaloneBundle": "正在下载独立捆绑包 {version}。",
  "DownloadingVcpkgStandaloneBundleLatest": "正在下载最新的独立捆绑包。",
  "DuplicateDependencyOverride": "{package_name} 已有替代",
  "DuplicatePackagePattern": "包“{package_name}”重复。",
  "DuplicatePackagePatternFirstOcurrence": "首次声明位置:",
  "DuplicatePackagePatternIgnoredLocations": "系统将忽略以下重新声明:",
  "DuplicatePackagePatternLocation": "位置: {path}",
  "DuplicatePackagePatternRegistry": "注册表: {url}",
  "DuplicatedKeyInObj": "重复的密钥 \"{value}\" 在对象中",
  "ElapsedForPackage": "处理 {spec} 所用时间: {elapsed}",
  "ElapsedTimeForChecks": "确定通过/失败所用的时间: {elapsed}",
  "EmailVcpkgTeam": "向 {url} 发送电子邮件并提供任何反馈。",
  "EmptyLicenseExpression": "SPDX 许可证表达式为空。",
  "EndOfStringInCodeUnit": "在码位中间找到了字符串结尾",
  "EnvInvalidMaxConcurrency": "{env_var} 为 {value}，必须为 >0",
  "EnvPlatformNotSupported": "此平台不支持生成环境命令",
  "EnvStrFailedToExtract": "无法展开环境字符串:",
  "EnvVarMustBeAbsolutePath": "{env_var} ({path}) 不是绝对路径",
  "ErrorDetectingCompilerInfo": "检测编译器信息时: \n“{path}”下的日志文件内容为:",
  "ErrorIndividualPackagesUnsupported": "在清单模式下，`vcpkg install` 不支持单个包参数。\n要安装其他包，请编辑 vcpkg.json，然后在没有任何包参数的情况下运行 `vcpkg install`。",
  "ErrorInvalidClassicModeOption": "在经典模式下不支持选项 --{option}，并且未找到任何清单。",
  "ErrorInvalidExtractOption": "--{option} 必须设置为非负整数或 \"AUTO\"。",
  "ErrorInvalidManifestModeOption": "清单模式下不支持选项 --{option}。",
  "ErrorManifestMustDifferFromOverlay": "清单目录 ({path}) 不能与覆盖端口中配置的目录相同。",
  "ErrorManifestMustDifferFromOverlayDot": "清单目录不能与在覆盖端口中配置的目录相同，因此“覆盖端口”值不能为“.”。",
  "ErrorMissingVcpkgRoot": "无法检测 vcpkg-root。如果尝试使用已生成的 vcpkg 的副本，则必须定义 VCPKG_ROOT 环境变量，以指向 https://github.com/Microsoft/vcpkg 的克隆副本。",
  "ErrorNoVSInstance": "在三元组 {triplet} 中: 无法找到有效的 Visual Studio 实例",
  "ErrorNoVSInstanceAt": "位于“{path}”",
  "ErrorNoVSInstanceFullVersion": "具有工具集版本前缀 {version}",
  "ErrorNoVSInstanceVersion": "具有工具集版本 {version}",
  "ErrorParsingBinaryParagraph": "分析 {spec} 的二进制段落时",
  "ErrorRequireBaseline": "此 vcpkg 实例需要具有指定基线的清单才能与端口交互。请将 “builtin-baseline” 添加到清单或添加 “vcpkg-configuration.json”，以重新定义默认注册表。",
  "ErrorRequirePackagesList": "`vcpkg install` 需要在经典模式下安装包的列表。",
  "ErrorUnableToDetectCompilerInfo": "vcpkg 无法检测活动编译器的信息。请参阅上述有关 CMake 故障输出的信息。",
  "ErrorVcvarsUnsupported": "在三元组 {triplet} 中: 非 Windows 主机不支持使用 Visual Studio 的开发人员提示。\n在三元组文件中定义 “VCPKG_CMAKE_SYSTEM_NAME” 或 “VCPKG_CHAINLOAD_TOOLCHAIN_FILE”。",
  "ErrorVsCodeNotFound": "找不到 Visual Studio Code，并且未设置环境变量 {env_var} 或该变量无效。",
  "ErrorVsCodeNotFoundPathExamined": "已检查以下路径:",
  "ErrorWhileFetchingBaseline": "从存储库提取基线 `\"{value}\"` 时 {package_name}:",
  "ErrorWhileParsing": "分析 {path} 时出错。",
  "ErrorWhileWriting": "写入 {path} 时出错。",
  "ExamplesHeader": "示例:",
  "ExceededRecursionDepth": "已超过递归深度。",
  "ExcludedPackage": "已排除 {spec}",
  "ExcludedPackages": "已排除以下包:",
  "ExecutablesRelativeToThePackageDirectoryHere": "可执行文件相对于此处的 ${{CURRENT_PACKAGES_DIR}}",
  "ExpectedAnObject": "应为对象",
  "ExpectedAtMostOneSetOfTags": "在 block:\n{value} 中找到了 {count} 组 {old_value}.*{new_value} 集，但应最多为 1",
  "ExpectedCharacterHere": "此处应为“{expected}”",
  "ExpectedDefaultFeaturesList": "默认功能列表中应为 \",\" 或文本结尾",
  "ExpectedDependenciesList": "依赖项列表中应为 \",\" 或文本结尾",
  "ExpectedDigitsAfterDecimal": "小数点后的预期数字",
  "ExpectedExplicitTriplet": "应为显式三重",
  "ExpectedFailSkipOrPass": "此处应为“失败”、“跳过”或“通过”",
  "ExpectedFeatureBaselineState": "此处应为 'fail'、'skip'、'pass'、'cascade'、'no-separate-feature-test'、'options'、'feature-fails'、或 'combination-fails'",
  "ExpectedFeatureListTerminal": "功能列表中应为 \",\" 或 \"]\"",
  "ExpectedFeatureName": "应为功能名称(必须为小写、数字、\"-\")",
  "ExpectedInstallStateField": "应为“未安装”、“半安装”或“已安装”中的一个",
  "ExpectedOneSetOfTags": "在 block:\n{value} 中找到了 {count} 组 {old_value}.*{new_value} 集，但应恰好为 1",
  "ExpectedOneVersioningField": "应只有一个版本控制字段",
  "ExpectedPathToExist": "提取后应存在 {path}",
  "ExpectedPortName": "此处应为端口名称(必须为小写、数字、\"-\")",
  "ExpectedReadWriteReadWrite": "意外参数: 应为“read”、“readwrite”或“write”",
  "ExpectedStatusField": "状态段落中应为 “status” 字段",
  "ExpectedTextHere": "此处应为“{expected}”",
  "ExpectedTripletName": "此处应为三重名称(必须为小写、数字、\"-\")",
  "ExpectedWantField": "此处应为“安装”、“保持”、“卸载”或“清除”中的一个",
  "Exported7zipArchive": "7zip 存档导出位置: {path}",
  "ExportedZipArchive": "Zip 存档导出位置: {path}",
  "ExportingAlreadyBuiltPackages": "已生成并将导出以下包:",
  "ExportingPackage": "正在导出 {package_name}...",
  "ExtendedDocumentationAtUrl": "可在“{url}”上找到扩展文档。",
  "ExtractHelp": "提取存档。",
  "ExtractingTool": "正在提取{tool_name}...",
  "FailedPostBuildChecks": "发现 {count} 个生成后检查问题。这些通常是由 portfile.cmake 或上游生成系统中的 bug 引起的。请先更正这些内容，然后再将此端口提交到特选注册表。",
  "FailedToAcquireMutant": "无法获取变体 {path}",
  "FailedToCheckoutRepo": "未能从存储库 {package_name} 签出“版本”",
  "FailedToDeleteDueToFile": "由于 {path}，无法 remove_all({value}): ",
  "FailedToDeleteDueToFile2": "由于 {path}，无法移除",
  "FailedToDeleteInsideDueToFile": "由于 {path}，无法 remove_all_inside({value}): ",
  "FailedToDetermineCurrentCommit": "无法确定当前提交:",
  "FailedToExtract": "无法提取“{path}”:",
  "FailedToFetchRepo": "无法提取 {url}。",
  "FailedToFindPortFeature": "{package_name} 没有名为 {feature} 的功能。",
  "FailedToFormatMissingFile": "没有要设置格式的文件。\n请传递 --all 或要设置格式或转换的显式文件。",
  "FailedToLoadInstalledManifest": "由于以下错误，无法加载 {package_name} 的控制或清单文件。请删除 {package_name}，然后重试。",
  "FailedToLoadManifest": "未能从目录 {path} 加载清单",
  "FailedToLocateSpec": "未能在图形中定位规范: {spec}",
  "FailedToOpenAlgorithm": "无法打开 {value}",
  "FailedToParseBaseline": "无法分析基线: {path}",
  "FailedToParseCMakeConsoleOut": "未能分析 CMake 控制台输出以定位块开始/结束标记。",
  "FailedToParseConfig": "未能分析配置",
  "FailedToParseNoTopLevelObj": "无法分析 {path}，该路径应为顶级对象。",
  "FailedToParseNoVersionsArray": "无法分析 {path}，应为 \"versions\" 数组。",
  "FailedToParseSerializedBinParagraph": "[健全性检查]无法分析序列化二进制段落。\n请在 https://github.com/microsoft/vcpkg 提出问题，附加以下输出: \n{error_msg}\n序列化二进制段落:",
  "FailedToRunToolToDetermineVersion": "无法运行“{path}”以确定 {tool_name} 版本。",
  "FailedToStoreBackToMirror": "未能将 {path} 存储到 {url}。",
  "FailedToStoreBinaryCache": "无法存储二进制缓存 {path}",
  "FailedToTakeFileSystemLock": "未能获取文件系统锁",
  "FailedVendorAuthentication": "一个或多个 {vendor} 凭据提供程序无法进行身份验证。有关如何提供凭据的更多详细信息，请参阅“{url}”。",
  "FeatureBaselineEntryAlreadySpecified": "“{feature}”已声明为“{value}”",
  "FeatureBaselineExpectedFeatures": "使用“{value}”时，必须指定功能列表。",
  "FeatureBaselineFormatted": "已成功设置功能基线文件的格式。",
  "FeatureBaselineNoFeaturesForFail": "使用 ‘= fail’ 时，不允许使用功能列表。",
  "FeatureBaselineNoFeaturesForPass": "使用 '= pass' 时，不允许使用功能列表。",
  "FeatureTestProblems": "存在一些功能测试问题!",
  "FetchingBaselineInfo": "正在从 {package_name} 提取基线信息...",
  "FetchingRegistryInfo": "正在从 {url} ({value}) 提取注册表信息...",
  "FieldKindDidNotHaveExpectedValue": "\"kind\" 没有预期值: (应为以下值之一: {expected}; 找到的是 {actual})",
  "FileIsNotExecutable": "此文件似乎不是可执行文件",
  "FileNotFound": "未找到文件",
  "FileReadFailed": "未能从 {path} 的 {byte_offset} 偏移处读取 {count} 个字节。",
  "FileSeekFailed": "未能在 {path} 中找到位置 {byte_offset}。",
  "FilesContainAbsolutePath1": "安装的包中不得有绝对路径，如下所示。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_ABSOLUTE_PATHS_CHECK enabled)",
  "FilesContainAbsolutePath2": "在此找到绝对路径",
  "FilesContainAbsolutePathPkgconfigNote": "添加对 `vcpkg_fixup_pkgconfig()` 的调用可能会修复 .pc 文件中的绝对路径",
  "FilesExported": "文件导出位置: {path}",
  "FilesRelativeToTheBuildDirectoryHere": "文件相对于此处的生成目录",
  "FilesRelativeToThePackageDirectoryHere": "文件相对于此处的 ${{CURRENT_PACKAGES_DIR}}",
  "FindCommandFirstArg": "'find' 的第一个参数必须是 'artifact' 或 'port'。",
  "FindVersionArtifactsOnly": "--version 不能与 vcpkg 搜索或 vcpkg 查找端口一起使用",
  "FishCompletion": "已在“{path}”下添加 vcpkg fish 完成。",
  "FixedEntriesInFile": "修复了 {path} 中的 {count} 个条目。",
  "FloatingPointConstTooBig": "浮点常量太大: {count}",
  "FollowingPackagesMissingControl": "以下包没有有效的 CONTROL 或 vcpkg.json:",
  "FollowingPackagesNotInstalled": "未安装以下包:",
  "FollowingPackagesUpgraded": "以下包是最新的:",
  "ForMergeWithTestingTheFollowing": "--for-merge-with {value} 正在测试:",
  "ForMoreHelp": "有关更多帮助",
  "ForceClassicMode": "强制使用经典模式，即使可找到清单也是如此。",
  "ForceSystemBinariesOnWeirdPlatforms": "必须在 arm、s390x、ppc64le、riscv 平台上设置环境变量 VCPKG_FORCE_SYSTEM_BINARIES。",
  "FormattedParseMessageExpressionPrefix": "表达式:",
  "GetParseFailureInfo": "使用 “--debug” 获取有关分析失败的详细信息。",
  "GhaBinaryCacheDeprecated": "已移除 ‘x-gh’ 二进制缓存后端。请考虑改用基于 NuGet 的二进制缓存提供程序，请参阅 {url} 中的扩展文档。",
  "GitCommandFailed": "执行 {command_line} 失败",
  "GitCommitUpdateVersionDatabase": "git commit -m \"更新版本数据库\"",
  "GitFailedToFetch": "无法从存储库 {url} 中提取引用 {value}",
  "GitFailedToInitializeLocalRepository": "初始化本地存储库 {path} 失败",
  "GitRegistryMustHaveBaseline": "git 注册表 \"{url}\" 必须具有“baseline”字段，该字段是有效的 git 提交 SHA (40 个十六进制字符)。\n若要使用当前最新版本，请将基线设置为该存储库的 HEAD，\"{commit_sha}\"。",
  "GitUnexpectedCommandOutputCmd": "git 在运行 {command_line} 时生成了意外输出",
  "GraphCycleDetected": "在 {package_name} 的图形中检测到循环:",
  "HashPortManyFiles": "{package_name} 包含 {count} 个文件。确定二进制缓存的 ABI 哈希时，对这些内容进行哈希处理可能需要较长时间。请考虑减少文件数。出现此问题的常见原因是，将源或生成文件意外签出到端口的目录。",
  "HeaderOnlyUsage": "{package_name} 是仅限标头的，可通过以下方式从 CMake 使用:",
  "HelpAssetCaching": "**试验性功能: 此功能可能会随时更改或删除**\n\nvcpkg 可以使用镜像来缓存下载的资产，确保即使原始源更改或消失，也能继续操作。\n\n可以通过将环境变量 X_VCPKG_ASSET_SOURCES 设置为以分号分隔的源列表或传递 --x-asset-sources=<source> 命令行选项序列来配置资产缓存。命令行源在环境源之后进行解释。可以使用反引号(`)转义逗号、分号和反引号。\n\n某些字符串的 <rw> 可选参数控制如何访问它们。可将其指定为 \"read、\"write\" 或 \"readwrite\"，默认为 \"read\"。\n\n有效源:",
  "HelpAssetCachingAzUrl": "添加 Azure Blob 存储源，可选择使用共享访问签名验证来添加。URL 应包含容器路径，并以尾随的 \"/\" 结束。<sas>如果已定义，应以 \"\" 作为前缀。如果非 Azure 服务器响应格式为 \"<url><sha512><sas>\" 的 GET 和 PUT 请求，则它们也将起作用。",
  "HelpAssetCachingBlockOrigin": "如果镜像没有可用的文件，则禁用对原始 URL 的回退。",
  "HelpAssetCachingScript": "调度到外部工具以提取资产。在模板中，\"{{url}}\" 将替换为原始 URL，\"{{sha512}}\" 将替换为 SHA512 值，\"{{dst}}\" 替换为要保存到的输出路径。这些替换将全部正确转义 shell，因此示例模板为: \"curl -L {{url}} --output {{dst}}\"。\"{{{{\" 将替换为 \"}}\"，\"}}}}\" 将替换为 \"}}\" 以避免扩展。请注意，这将在生成环境中执行，因此 PATH 和其他环境变量将被三元组修改。",
  "HelpBinaryCaching": "vcpkg 可以缓存已编译的包，以便在单台计算机上或跨网络加速还原。默认情况下，vcpkg 会将生成保存到本地计算机缓存。可以通过在命令行上传递 \"--binarysource=clear\" 作为最后一个选项来禁用此功能。\n\n可以通过将 \"--binarysource=<source>\" 选项传递给每个命令行或将 \"VCPKG_BINARY_SOURCES\" 环境变量设置为一组源(示例: \"<source>;<source>;...\")来进一步配置二进制缓存。命令行源在环境源之后进行解释。\n\n某些字符串的 \"<rw>\" 可选参数控制是否将查阅它们以下载二进制文件以及是否将按需版本上传到该远程。可将其指定为 \"read\"、\"write\" 或 \"readwrite\"。\n\n常规源:",
  "HelpBinaryCachingAws": "**试验性: 将在不发出警告的情况下更改或删除**\n添加 AWS S3 源。使用 aws CLI 进行上传和下载。前缀应包含 s3:// 方案，并带有 \"/\" 后缀。",
  "HelpBinaryCachingAwsConfig": "**试验性: 将在不发出警告的情况下更改或删除**\n添加 AWS S3 源。添加 AWS 配置; 目前仅支持与 AWS CLI 的 --no-sign-request 参数等效的 \"no-sign-request\" 参数。",
  "HelpBinaryCachingAwsHeader": "Azure Web 服务源",
  "HelpBinaryCachingAzBlob": "**试验性: 将在不发出警告的情况下更改或删除**\n添加 Azure Blob 存储源。使用共享访问签名验证。<url>应包含容器路径。<sas>必须以 \"?\" 为前缀。",
  "HelpBinaryCachingAzUpkg": "**实验性：将更改或删除而不发出警告**\n添加通用包 Azure Artifacts 源。使用 Azure CLI (Az 项目) 进行上传和下载。",
  "HelpBinaryCachingCos": "**试验性: 将在不发出警告的情况下更改或删除**\n添加 COS 源。使用 cos CLI 进行上传和下载。<prefix>应包括方案 \"cos://\"，后缀为 \"/\"。",
  "HelpBinaryCachingDefaults": "添加默认的基于文件的位置。根据系统设置，存储二进制文件的默认路径为 \"{path}\"。这会在 Windows 上咨询 %LOCALAPPDATA%/%APPDATA%，在其他平台上咨询 $XDG_CACHE_HOME 或 $HOME。",
  "HelpBinaryCachingDefaultsError": "添加默认的基于文件的位置。",
  "HelpBinaryCachingFiles": "添加基于文件的自定义位置。",
  "HelpBinaryCachingGcs": "**试验性: 将在不发出警告的情况下更改或删除**\n添加 Google 云存储(GCS)源。使用 gsutil CLI 进行上传和下载。前缀应包含 gs:// 方案，并带有 \"/\" 后缀。",
  "HelpBinaryCachingHttp": "添加基于 http 的自定义位置。GET、HEAD 和 PUT 请求已完成，可下载、检查和上传二进制文件。可以使用变量 {{name}}、{{version}}、{{sha}} 和 {{triplet}}。示例 URL 为 \"https: //cache.example.com/{{triplet}}/{{name}}/{{version}}/{{sha}}\"。通过标头字段，可以设置自定义标头以传递授权令牌。",
  "HelpBinaryCachingNuGet": "添加基于 NuGet 的源; 等效于 NuGet CLI 的 \"-Source\" 参数。",
  "HelpBinaryCachingNuGetConfig": "添加基于 NuGet-config-file 的源; 等效于 NuGet CLI 的 \"-Config\" 参数。此配置应为上传指定 \"defaultPushSource\"。",
  "HelpBinaryCachingNuGetFooter": "默认情况下不使用 NuGet 的缓存。若要将其用于基于 NuGet 的每个源，请将环境变量 \"VCPKG_USE_NUGET_CACHE\" 设为 \"true\" (不区分大小写)或 \"1\"。\n\"nuget\" 和 \"nugetconfig\" 源提供程序在生成 NuGet 包时尊重某些环境变量。如果定义了适当的环境变量且该变量为非空，则将像以下示例之一样生成 \"metadata.repository\" 字段:",
  "HelpBinaryCachingNuGetHeader": "NuGet 源",
  "HelpBinaryCachingNuGetInteractive": "启用 NuGet 交互式凭据管理; 与 NuGet CLI 中的 \"-NonInteractive\" 参数相反。",
  "HelpBinaryCachingNuGetTimeout": "指定 NuGet 网络操作的 NuGet 超时; 等效于 NuGet CLI 的 \"-Timeout\" 参数。",
  "HelpBuiltinBase": "基线引用 vcpkg 存储库中针对图中每个依赖项建立最低版本的提交。例如，如果未指定其他约束(直接或以可传递方式)，则版本将解析为顶级清单的基线。将忽略可传递依赖项的基线。",
  "HelpCachingClear": "删除所有以前的源，包括默认值。",
  "HelpContactCommand": "显示联系人信息以发送反馈",
  "HelpCreateCommand": "新建端口",
  "HelpDependInfoCommand": "显示端口的依赖项列表",
  "HelpEditCommand": "编辑端口，可以选择使用 {env_var}，默认为“代码”",
  "HelpEnvCommand": "创建用于开发或编译的干净 shell 环境",
  "HelpExampleCommand": "有关更多帮助(包括示例)，请参阅 https://learn.microsoft.com/vcpkg",
  "HelpExampleManifest": "示例清单:",
  "HelpInstallCommand": "安装包",
  "HelpManifestConstraints": "清单可以对所使用的版本施加三种约束",
  "HelpMinVersion": "Vcpkg 将选择找到的与所有适用约束匹配的最低版本，包括在顶级指定的基线中的版本以及图中的任何 “version>=” 约束。",
  "HelpOverrides": "当用作顶级清单(例如在目录中运行 `vcpkg install` 时)，替代允许清单短路依赖项解析，并精确指定要使用的版本。可将这些用于处理版本冲突，例如使用 `version-string` 依赖项。如果以可传递方式以来它们，则将不会考虑它们。",
  "HelpOwnsCommand": "在安装的包中搜索文件的所有者",
  "HelpPackagePublisher": "此外，包发布者可以使用 “version>=” 约束，以确保使用者至少使用某个特定最低版本的给定依赖项。例如，如果库需要在 1.70 中将 API 添加到 boost-asio，则 “version>=” 约束将确保可传递用户使用足够的版本，即使在单独的版本替代或跨注册表引用的情况下也是如此。",
  "HelpPortVersionScheme": "此外，每个版本还有一个非负整数的“端口版本”。在呈现为文本时，端口版本(如果非零)将作为后缀添加到由哈希(#)分隔的主版本文本中。端口版本在主版本文本后按字母顺序排序，例如:\n1.0.0 < 1.0.0#1 < 1.0.1 < 1.0.1#5 < 2.0.0",
  "HelpRemoveCommand": "卸载包",
  "HelpResponseFileCommand": "在该位置展开的每行包含一个参数",
  "HelpSearchCommand": "搜索可生成的包",
  "HelpTextOptFullDesc": "不要截断长文本。",
  "HelpTopicCommand": "显示特定帮助主题",
  "HelpTopicsCommand": "显示帮助主题的完整列表",
  "HelpTxtOptAllowUnsupportedPort": "继续对不受支持的端口发出警告，而不是失败",
  "HelpTxtOptCleanAfterBuild": "生成每个包后清理生成树、包和下载内容",
  "HelpTxtOptCleanBuildTreesAfterBuild": "生成每个包后清理生成树",
  "HelpTxtOptCleanDownloadsAfterBuild": "生成每个包后清理下载内容",
  "HelpTxtOptCleanPkgAfterBuild": "生成每个包后清理包",
  "HelpTxtOptDryRun": "不实际生成或安装",
  "HelpTxtOptEditable": "对命令行上的库禁用源重新提取和二进制缓存(经典模式)",
  "HelpTxtOptEnforcePortChecks": "如果端口检测到问题或尝试使用已弃用的功能，则安装失败",
  "HelpTxtOptKeepGoing": "失败时继续安装包",
  "HelpTxtOptManifestFeature": "要安装的顶级清单中的其他功能(清单模式)",
  "HelpTxtOptManifestNoDefault": "不要从顶级清单(清单模式)安装默认功能",
  "HelpTxtOptNoDownloads": "不下载新源",
  "HelpTxtOptNoUsage": "不要在安装后打印 CMake 使用情况信息",
  "HelpTxtOptOnlyBinCache": "如果缓存的二进制文件不可用，则失败",
  "HelpTxtOptOnlyDownloads": "尽量尝试在不生成的情况下下载源",
  "HelpTxtOptRecurse": "允许在安装过程中移除包",
  "HelpTxtOptUseHeadVersion": "使用最新的上游源在命令行上安装库(经典模式)",
  "HelpTxtOptWritePkgConfig": "写入 NuGet packages.config 格式的文件以用于外部二进制缓存。有关详细信息，请参阅 `vcpkg help binarycaching`。",
  "HelpUpdateBaseline": "使库保持最新的最佳方法是更新基线引用。这将确保更新所有包 (包括可传递包)。但是，如果需要单独更新包，则可以使用“version>=”约束。",
  "HelpUpdateCommand": "列出可升级的包",
  "HelpUpgradeCommand": "重新生成所有过时的包",
  "HelpVersionCommand": "显示版本信息",
  "HelpVersionDateScheme": "日期(2021-01-01.5)",
  "HelpVersionGreater": "在“依赖项”字段中，每个依赖项可以列出最小约束。如果这些最小约束以可传递方式依赖于此库，则将使用这些最小约束。此外，还可以使用 “#” 后缀指定最低端口版本。",
  "HelpVersionScheme": "以点分隔的数字序列(1.2.3.4)",
  "HelpVersionSchemes": "已接受以下版本控制方案。",
  "HelpVersionSemverScheme": "语义版本 2.0 (2.1.0-rc2)",
  "HelpVersionStringScheme": "精确、不兼容的版本(Vista)",
  "HelpVersioning": "使用版本控制，可以从清单文件中确定性地控制项目所用依赖项的精确修订。",
  "IgnoringVcpkgRootEnvironment": "vcpkg {value} 正在使用检测到的 vcpkg 根 {actual} 并忽略不匹配的 VCPKG_ROOT 环境值 {path}。要抑制此消息，请取消设置环境变量或使用 --vcpkg-root 命令行开关。",
  "IllegalFeatures": "在此上下文中不允许使用功能列表",
  "IllegalPlatformSpec": "此上下文中不允许使用平台限定符",
  "ImproperShaLength": "SHA512 必须是 128 个十六进制字符: {value}",
  "IncorrectArchiveFileSignature": "存档文件签名不正确",
  "InfoSetEnvVar": "还可以将 {env_var} 设置为所选编辑器。",
  "InitRegistryFailedNoRepo": "无法在 {path} 下创建注册表，因为这不是 git 存储库根路径。\n请使用“git init {command_line}”在此文件夹中创建 git 存储库。",
  "InstallCopiedFile": "{path_source} -> {path_destination} 已完成",
  "InstallFailed": "失败: {path}: {error_msg}",
  "InstallPackageInstruction": "打开项目后，转到“工具”>“NuGet 包管理器”>“包管理器控制台”并粘贴:\n 安装包“{value}”- 源“{path}”",
  "InstallRootDir": "安装的目录(实验性)",
  "InstallSkippedUpToDateFile": "{path_source} -> {path_destination} 已跳过，为最新",
  "InstallWithSystemManager": "可以通过系统包管理器安装此工具。",
  "InstallWithSystemManagerMono": "Ubuntu 18.04 用户可能需要较新版本的 mono，可通过 {url} 获得。",
  "InstallWithSystemManagerPkg": "可以通过系统包管理器({command_line})安装此工具。",
  "InstalledBy": "已由 {path} 安装",
  "InstalledPackages": "已安装以下包:",
  "InstalledPackagesHead": "以下包已安装，但请求的是 --head 版本。不会更改其已安装的内容。要获取更新后的版本，请先移除这些包:",
  "InstalledRequestedPackages": "当前已安装所有请求的包。",
  "InstallingFromFilesystemRegistry": "从此处的文件系统注册表安装",
  "InstallingFromGitRegistry": "从 Git 注册表安装",
  "InstallingOverlayPort": "正在从此处安装覆盖端口",
  "InstallingPackage": "正在安装 {action_index}/{count} 个 {spec}...",
  "IntegrateBashHelp": "启用 bash Tab-completion。仅限非 Windows",
  "IntegrateFishHelp": "启用 fish 选项卡补全。仅限非 Windows",
  "IntegrateInstallHelpLinux": "使已安装的包在用户范围内可用",
  "IntegrateInstallHelpWindows": "使已安装的包在用户范围内可用。首次使用时需要管理员权限",
  "IntegrateNonWindowsOnly": "{command_line} 仅限非 Windows，在此系统上不受支持。",
  "IntegratePowerShellHelp": "启用 PowerShell 选项卡补全。仅限 Windows",
  "IntegrateProjectHelp": "为单个 Visual Studio 项目使用生成引用 NuGet 包。仅限 Windows",
  "IntegrateRemoveHelp": "删除用户范围内的集成",
  "IntegrateWindowsOnly": "{command_line} 仅限 Windows，在此系统上不受支持。",
  "IntegrateZshHelp": "启用 zsh Tab-completion。仅限非 Windows",
  "IntegrationFailedVS2015": "集成未应用于 Visual Studio 2015。",
  "InternalCICommand": "vcpkg ci 是一个内部命令，它将发生不兼容更改或随时被删除。",
  "InternalErrorMessageContact": "请在 https://github.com/microsoft/vcpkg/issues/new?template=other-type-of-bug-report.md&labels=category:vcpkg-bug 打开一个包含重现问题的详细步骤的问题。",
  "InvalidArchitectureValue": "体系结构无效： {value}。应为其中之一： {expected}",
  "InvalidArgument": "参数无效",
  "InvalidArgumentRequiresAbsolutePath": "参数无效: 二进制配置字符串的二进制配置“{binary_source}”路径参数必须是绝对参数",
  "InvalidArgumentRequiresBaseUrl": "参数无效: 二进制配置“{binary_source}”要求将 {base_url} 基 URL 作为第一个参数",
  "InvalidArgumentRequiresBaseUrlAndToken": "参数无效: 二进制配置“{binary_source}”至少需要一个基 URL 和一个 SAS 令牌",
  "InvalidArgumentRequiresFourOrFiveArguments": "参数无效: 二进制配置“{binary_source}”需要 4 或 5 个参数",
  "InvalidArgumentRequiresNoWildcards": "无法修复包含通配符的路径的 Windows 路径大小写: {path}",
  "InvalidArgumentRequiresNoneArguments": "参数无效: 二进制配置“{binary_source}”不接受参数",
  "InvalidArgumentRequiresOneOrTwoArguments": "参数无效: 二进制配置“{binary_source}”需要 1 或 2 个参数",
  "InvalidArgumentRequiresPathArgument": "参数无效: 二进制配置“{binary_source}”至少需要一个路径参数",
  "InvalidArgumentRequiresPrefix": "参数无效: 二进制配置“{binary_source}”至少需要一个前缀",
  "InvalidArgumentRequiresSingleArgument": "参数参数无效: 二进制配置“{binary_source}”不接受多个参数",
  "InvalidArgumentRequiresSingleStringArgument": "参数无效: 二进制配置“{binary_source}”需要单个字符串参数",
  "InvalidArgumentRequiresSourceArgument": "参数无效: 二进制配置“{binary_source}”至少需要一个源参数",
  "InvalidArgumentRequiresTwoOrThreeArguments": "参数无效: 二进制配置“{binary_source}”需要 2 或 3 个参数",
  "InvalidArgumentRequiresValidToken": "参数无效: 二进制配置“{binary_source}”需要 SAS 令牌，不需要将前面的“?”作为第二个参数",
  "InvalidBuildInfo": "包的 BUILD_INFO 文件无效: {error_msg}",
  "InvalidBuiltInBaseline": "顶级内置基线({value})不是有效的提交 sha: 应为 40 个十六进制字符。",
  "InvalidBundleDefinition": "捆绑包定义无效。",
  "InvalidCharacterInFeatureList": "功能名称中的字符无效(必须为小写、数字、\"-\" 或 \"*\")",
  "InvalidCharacterInFeatureName": "功能名称中的字符无效(必须为小写、数字、\"-\")",
  "InvalidCharacterInPortName": "端口名称中的字符无效(必须为小写、数字、\"-\")",
  "InvalidCodePoint": "传递给 utf8_encoded_code_point_count 的码位无效",
  "InvalidCodeUnit": "代码单元无效",
  "InvalidCommandArgSort": "--sort 的值必须是 “lexicographical”、“topological”、“reverse” 之一。",
  "InvalidCommentStyle": "vcpkg 不支持 c 样式注释，但大多数对象允许将 $ 前缀字段用作注释。",
  "InvalidCommitId": "提交 ID 无效: {commit_sha}",
  "InvalidDefaultFeatureName": "\"default\" 是保留的功能名称",
  "InvalidFeature": "特征必须是小写字母数字+连字符，而不是保留名称之一",
  "InvalidFileType": "失败: {path} 无法处理文件类型",
  "InvalidFilename": "文件名不能包含无效字符 {value}，但为 {path}",
  "InvalidFloatingPointConst": "无效的浮点常量: {count}",
  "InvalidFormatString": "格式字符串无效: {actual}",
  "InvalidHexDigit": "unicode 转义中的十六进制数字无效",
  "InvalidIntegerConst": "无效的整数常量: {count}",
  "InvalidLibraryMissingLinkerMembers": "库无效: 找不到链接器成员。",
  "InvalidLinkage": "{system_name} 链接类型无效: [{value}]",
  "InvalidLogicExpressionUnexpectedCharacter": "逻辑表达式无效，意外字符",
  "InvalidLogicExpressionUsePipe": "逻辑表达式无效，请使用 \"|\" 而不是 \"or\"",
  "InvalidOptionForRemove": "“remove” 接受库或 “--outdated”",
  "InvalidPortVersonName": "找到无效的端口版本文件名: `{path}`。",
  "InvalidSha512": "SHA-512 哈希无效： {sha}\nSHA-512 哈希的长度必须为 128 个字符，并且只能包含十六进制数字",
  "InvalidSharpInVersion": "版本文本中的字符 \"#\" 无效",
  "InvalidSharpInVersionDidYouMean": "版本文本中的字符 \"#\" 无效。你的意思是 \"port-version\": {value} 吗?",
  "InvalidString": "传递给 Value::string(std::string) 的 utf8 无效",
  "InvalidToolOSValue": "工具操作系统无效： {value}。应为其中之一： {expected}",
  "InvalidToolVersion": "工具版本无效;应为包含由点分隔的介于 1 到 3 个数字之间的子字符串的字符串。",
  "InvalidTriplet": "三元组 {triplet} 无效",
  "InvalidUri": "无法分析 URI: {value}",
  "InvalidValueHashAdditionalFiles": "变量 VCPKG_HASH_ADDITIONAL_FILES 包含无效的文件路径:“{path}”。该值必须是已存在文件的绝对路径。",
  "InvalidValuePostPortfileIncludes": "变量 VCPKG_POST_PORTFILE_INCLUDES 包含无效的文件路径: '{path}'。此值必须是指向现有 cmake 文件的绝对路径。",
  "IrregularFile": "路径不是常规文件: {path}",
  "JsonErrorMustBeAnObject": "预期的“{path}”应为对象。",
  "JsonFieldNotObject": "[\"{json_field}\"] 的值必须是对象",
  "JsonFieldNotString": "[\"{json_field}\"] 的值必须是字符串",
  "JsonFileMissingExtension": "JSON 文件 {path} 必须具有 .json (全小写)扩展名",
  "JsonSwitch": "打印 JSON 而不是纯文本",
  "JsonValueNotArray": "json 值不是数组",
  "JsonValueNotObject": "json 值不是对象",
  "JsonValueNotString": "json 值不是字符串",
  "LaunchingProgramFailed": "正在启动 {tool_name}:",
  "LibraryArchiveMemberTooSmall": "库存档成员太小，无法包含预期的数据类型。",
  "LibraryFirstLinkerMemberMissing": "找不到第一个链接器成员名称。",
  "LicenseExpressionContainsExtraPlus": "SPDX 许可证表达式包含额外的 \"+\"。只有在许可证标识符之后才允许使用这些标识符。",
  "LicenseExpressionContainsInvalidCharacter": "SPDX 许可证表达式包含无效字符 (0x{value:02X} '{value}')。",
  "LicenseExpressionContainsUnicode": "SPDX 许可证表达式包含 unicode 字符(U+{value: 04X}\"{pretty_value}\")，但这些表达式仅限 ASCII。",
  "LicenseExpressionDocumentRefUnsupported": "当前实现不支持 DocumentRef- SPDX 引用。",
  "LicenseExpressionExpectCompoundFoundParen": "应为复合或字符串末尾，找到了一个括号。",
  "LicenseExpressionExpectCompoundFoundWith": "应为 AND 或 OR，找到 WITH (仅允许在许可证名称后使用 WITH，而不允许使用带圆括号表达式)。",
  "LicenseExpressionExpectCompoundFoundWord": "应为 AND 或 OR，找到许可证或异常名称: \"{value}\"。",
  "LicenseExpressionExpectCompoundOrWithFoundWord": "应为 AND、OR 或 WITH，找到许可证或异常名称: \"{value}\"。",
  "LicenseExpressionExpectExceptionFoundCompound": "应为异常名称，找到了复合项 {value}。",
  "LicenseExpressionExpectExceptionFoundEof": "应为异常名称，找到了字符串的末尾。",
  "LicenseExpressionExpectExceptionFoundParen": "应为异常名称，找到了一个括号。",
  "LicenseExpressionExpectLicenseFoundCompound": "应为许可证名称，找到了复合项 {value}。",
  "LicenseExpressionExpectLicenseFoundEof": "应为许可证名称，找到了字符串的末尾。",
  "LicenseExpressionImbalancedParens": "有一个不带左括号的右括号。",
  "LicenseExpressionString": "<许可证字符串>",
  "LicenseExpressionUnknownException": "未知的许可证异常标识符 \"{value}\"。已知值列在 https://spdx.org/licenses/exceptions-index.html 中",
  "LicenseExpressionUnknownLicense": "未知的许可证标识符 \"{value}\"。已知值列在 https://spdx.org/licenses/ 中",
  "LinkageDynamicDebug": "动态调试(/MDd)",
  "LinkageDynamicRelease": "动态发布(/MD)",
  "LinkageStaticDebug": "静态调试(/MTd)",
  "LinkageStaticRelease": "静态发布(/MT)",
  "ListHelp": "列出安装的库",
  "LoadedCommunityTriplet": "已从此处加载社区三元组。社区三元组未内置在特选注册表中，因此不太可能成功。",
  "LoadedOverlayTriplet": "已从此处加载覆盖三元组。",
  "LoadingDependencyInformation": "正在加载 {count} 个包的依赖项信息...",
  "LocalPortfileVersion": "正在使用本地端口版本。若要更新本地端口，请使用 `git pull`。",
  "ManifestConflict2": "同时找到了一个清单和一个 CONTROL 文件；请重命名其中一个",
  "ManifestFormatCompleted": "已成功设置清单文件的格式。",
  "ManifestHere": "清单文件位于此处",
  "MismatchedBinParagraphs": "序列化二进制段落不同于原始二进制段落。请在 https://github.com/microsoft/vcpkg 提出问题，附加以下输出:",
  "MismatchedFiles": "要存储的文件与哈希不匹配",
  "MismatchedManifestAfterReserialize": "序列化清单不同于原始清单。请在 https://github.com/microsoft/vcpkg 打开一个问题，输出如下:",
  "MismatchedNames": "元数据文件中声明的端口名称与目录不匹配。端口应命名 {package_name}，但文件声明 {actual}。",
  "MismatchedSpec": "端口 {path} 中的规范不匹配: 应为 {expected}，实际为 {actual}",
  "MismatchedType": "{json_field}: 类型不匹配: 应为 {json_type}",
  "Missing7zHeader": "找不到 7z 标头。",
  "MissingArgFormatManifest": "已传递 format-manifest --convert-control 而不使用 “--all”。\n这不执行任何操作: 显式传递的控件文件将自动转换。",
  "MissingClosingParen": "缺少右括号 )",
  "MissingDependency": "已安装包 {spec}，但未安装依赖项 {package_name}。",
  "MissingExtension": "缺少“{extension}”扩展名。",
  "MissingOption": "此命令需要 --{option}",
  "MissingOrInvalidIdentifer": "标识符缺失或无效",
  "MissingPortSuggestPullRequest": "如果未列出你的端口，请在发出和/或考虑发出拉取请求时开立问题。",
  "MissingRequiredField": "缺少必填字段 \"{json_field}\" ({json_type})",
  "MissingRequiredField2": "缺少必填字段 \"{json_field}\"",
  "MissingShaVariable": "如果使用其他变量，必须在模板中使用 {{sha}} 变量。",
  "MixingBooleanOperationsNotAllowed": "不允许使用混合的 & 和 |；使用 () 指定操作顺序",
  "MonoInstructions": "这可能是由于 mono 安装不完整所导致的。通过 `sudo apt install mono-complete` 可以在某些系统上完整的 mono。Ubuntu 18.04 用户可能需要较新版本的 mono。要获取该版本，请访问 https://www.mono-project.com/download/stable/",
  "MultiArch": "多体系结构必须“相同”，但此前为 {option}",
  "MultipleFeatures": "{package_name} 多次声明 {feature}；请确保功能具有不同的名称",
  "MutuallyExclusiveOption": "--{value} 不能与 --{option} 一起使用。",
  "MutuallyExclusivePorts": "--{option} 不能用于显式命名的端口。",
  "NewConfigurationAlreadyExists": "创建清单将覆盖位于 {path} 下的 vcpkg-configuration.json。",
  "NewManifestAlreadyExists": "{path} 下已存在清单。",
  "NewNameCannotBeEmpty": "--name 不能为空。",
  "NewOnlyOneVersionKind": "只能指定 --version-relaxed、--version-date 或 --version-string 中的一个。",
  "NewSpecifyNameVersionOrApplication": "指定 --name 和 --version 以生成用于 C++ 库的清单，或指定 --application 以指示不将清单用作端口。",
  "NewVersionCannotBeEmpty": "--version 不能为空。",
  "NoCoreFeatureAllowedInNonFailBaselineEntry": "如果项的类型为“{value}”，则功能列表中不允许使用 ‘core’",
  "NoEntryWithName": "找不到包含名称“{value}”和 URL 的条目。",
  "NoError": "无错误",
  "NoInstalledPackages": "未安装任何包。你指的是“search”吗?",
  "NoInstalledPackagesLicenseReport": "没有已安装的包，因此没有已安装包的许可证。是否想先安装一些内容？",
  "NoOutdatedPackages": "没有过时的包。",
  "NoRegistryForPort": "没有为端口 {package_name} 配置注册表",
  "NoUrlsAndNoHashSpecified": "未指定 URL 且未指定哈希。",
  "NonExactlyArgs": "命令“{command_name}”只需要 {expected} 个参数，但提供了 {actual} 个",
  "NonOneRemainingArgs": "命令“{command_name}”只需要一个参数",
  "NonRangeArgs": "命令“{command_name}”需要介于 {lower} 和 {upper} 个参数之间(含)，但提供了 {actual} 个",
  "NonRangeArgsGreater": "命令“{command_name}”只需要 {lower} 个参数，但提供了 {actual} 个",
  "NonZeroOrOneRemainingArgs": "命令“{command_name}”需要零个或一个参数",
  "NonZeroRemainingArgs": "命令“{command_name}”不接受任何其他参数",
  "NugetOutputNotCapturedBecauseInteractiveSpecified": "NuGet 命令失败，未捕获输出，因为指定为交互式的",
  "NugetPackageFileSucceededButCreationFailed": "NuGet 包创建成功，但未生成 .nupkg。预期为:“{path}”",
  "NugetTimeoutExpectsSinglePositiveInteger": "意外参数: 二进制配置“nugettimeout”需要单个正整数参数",
  "OnlySupports": "{feature_spec} 仅支持 {supports_expression}",
  "OptionMustBeInteger": "--{option} 的值必须是整数。",
  "OptionRequiresANonDashesValue": "选项“{option}”需要一个值；如果打算将“{option}”设置为“{value}”，请改用等号形式: {actual}={value}",
  "OptionRequiresAValue": "选项“{option}”需要一个值",
  "OptionRequiresOption": "--{value} 需要 --{option}",
  "OptionUsedMultipleTimes": "已多次指定选项“{option}”",
  "Options": "选项",
  "OriginalBinParagraphHeader": "\n原始二进制段落",
  "OtherCommandsHeader": "其他",
  "OverlayPatchDir": "覆盖路径 \"{path}\" 必须是现有目录。",
  "OverlayPortsHelp": "覆盖端口目录或包含覆盖端口目录的目录也 (： {env_var})",
  "OverlayTripletDirectoriesHelp": "覆盖三元组的目录(也是: {env_var})",
  "OverlayTriplets": "覆盖“{path}”中的三元组:",
  "OverwritingFile": "文件 {path} 已存在，并将被覆盖",
  "PECoffHeaderTooShort": "分析可移植可执行文件 {path} 时，COFF 标头的大小太小，无法包含有效的 PE 标头。",
  "PEConfigCrossesSectionBoundary": "分析可移植可执行文件 {path} 时，映像配置目录跨越了一个分区边界。",
  "PEImportCrossesSectionBoundary": "分析可移植可执行文件 {path} 时，导入表跨越了分区边界。",
  "PEPlusTagInvalid": "分析可移植可执行文件 {path} 时，可选标头既不是 PE32 也不是 PE32+。",
  "PERvaNotFound": "分析可移植可执行文件 {path} 时，找不到 RVA {value:#X}。",
  "PackageAbi": "{spec} 包 ABI: {package_abi}",
  "PackageAlreadyRemoved": "无法删除 {spec}: 已删除",
  "PackageDiscoveryHeader": "包发现",
  "PackageFailedtWhileExtracting": "提取 {path} 时“{value}”失败。",
  "PackageInfoHelp": "显示有关包的详细信息",
  "PackageInstallationHeader": "包安装",
  "PackageLicenseSpdx": "已安装的包声明以下许可证：",
  "PackageLicenseSpdxThisInstall": "此 vcpkg 安装中安装的包声明以下许可证：",
  "PackageLicenseUnknown": "某些包未声明 SPDX 许可证。有关其许可的详细信息，请检查每个程序包的“版权”文件。",
  "PackageLicenseWarning": "已安装的内容由所有者向你授予许可。Microsoft 既不对第三方包负责，也不授予其许可证。",
  "PackageManipulationHeader": "包操作",
  "PackageRootDir": "包目录(实验性)",
  "PackagesToInstall": "将生成并安装以下包:",
  "PackagesToModify": "将修改其他包(*)以完成此操作。",
  "PackagesToRebuild": "将重新生成以下包:",
  "PackagesToRebuildSuggestRecurse": "如果确实要重新生成上述包，请使用 --recurse 选项运行命令。",
  "PackagesToRemove": "将移除以下包:",
  "PackagesUpToDate": "没有需要更新的包。",
  "PackingVendorFailed": "打包 {vendor} 失败。有关详细信息，请使用 --debug。",
  "PairedSurrogatesAreInvalid": "跟随前导代理项的尾随代理项(配对代理项无效)",
  "ParagraphDuplicateField": "重复字段",
  "ParagraphExactlyOne": "应只有一个段落",
  "ParagraphExpectedColonAfterField": "字段名称后应为 \":\"",
  "ParagraphExpectedFieldName": "应为域名",
  "ParagraphUnexpectedEndOfLine": "意外行尾，要跨越空白行，请使用 \" .\"",
  "ParseFeatureNameError": "“{package_name}”不是有效的功能名称。功能名称必须为小写字母数字 + 连字符且不是保留内容(有关详细信息，请参阅 {url})。",
  "ParseIdentifierError": "“{value}”不是有效的标识符。标识符必须为小写字母数字 + 连字符且不是保留内容(有关详细信息，请参阅 {url})。",
  "ParsePackageNameError": "“{package_name}”不是有效的包名称。包名称必须为小写字母数字 + 连字符且不是保留内容(有关详细信息，请参阅 {url})。",
  "ParsePackageNameNotEof": "预期输入末尾分析包名称；这通常意味着端口名称中不允许使用所指字符。端口名称全部为小写字母数字 + 连字符且不是保留内容(有关详细信息，请参阅 {url})。",
  "ParsePackagePatternError": "“{package_name}”不是有效的包模式。包模式只能使用一个通配符(*)，并且它必须是模式中的最后一个字符(有关详细信息，请参阅 {url})。",
  "ParseQualifiedSpecifierNotEof": "预期输入末尾分析包规范；这通常意味着指示的字符不允许出现在包规范中。端口、三元组和功能名称均为小写字母数字 + 连字符。",
  "ParseQualifiedSpecifierNotEofSquareBracket": "预期输入末尾分析包规范；你是否指的是 {version_spec}?",
  "ParseTripletNotEof": "三元组名称无效。三元组名称均为小写字母数字 + 连字符。",
  "PathMustBeAbsolute": "环境变量 X_VCPKG_REGISTRIES_CACHE 的值不是绝对值: {path}",
  "PerformingPostBuildValidation": "正在执行生成后验证",
  "PortBugBinDirExists": "存在 ${{CURRENT_PACKAGES_DIR}}/{path}，但它不应在静态生成中。若要抑制此消息，请添加 set(VCPKG_POLICY_DLLS_IN_STATIC_LIBRARY enabled)",
  "PortBugDebugShareDir": "${{CURRENT_PACKAGES_DIR}}/debug/share 不应存在。请重新组织任何重要文件，然后通过添加 `file(REMOVE_RECURSE \"${{CURRENT_PACKAGES_DIR}}/debug/share\")` 来删除所有剩余文件。若要抑制此消息，请添加 set(VCPKG_POLICY_ALLOW_DEBUG_SHARE enabled)",
  "PortBugDllAppContainerBitNotSet": "必须为 Windows 应用商店应用中的所有 DLL 设置应用容器位，并且三元组要求面向 Windows 应用商店，但是以下 DLL 不是使用位集生成的。这通常表示工具链链接器标志未正确传播，或者正在使用的链接器不支持 /APPCONTAINER 开关。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_APPCONTAINER_CHECK enabled)",
  "PortBugDllInLibDir": "在 ${{CURRENT_PACKAGES_DIR}}/lib 或 ${{CURRENT_PACKAGES_DIR}}/debug/lib 中找到以下 DLL。请将它们分别移动到 {{CURRENT_PACKAGES_DIR}}/bin 或 ${{CURRENT_PACKAGES_DIR}}/debug/bin。",
  "PortBugDuplicateIncludeFiles": "${{CURRENT_PACKAGES_DIR}}/debug/include 不应存在。若要抑制此消息，请添加 set(VCPKG_POLICY_ALLOW_DEBUG_INCLUDE enabled)",
  "PortBugDuplicateIncludeFilesFixIt": "如果此目录是由不允许在要禁用的调试中安装标头的生成系统创建的，请使用 file(REMOVE_RECURSE \"${{CURRENT_PACKAGES_DIR}}/debug/include\") 删除重复目录",
  "PortBugFoundCopyrightFiles": "以下文件是可能的版权文件",
  "PortBugFoundDebugBinaries": "以下是调试二进制文件:",
  "PortBugFoundDllInStaticBuild": "静态生成中不应存在 DLL，但是发现了以下 DLL。若要抑制此消息，请添加 set(VCPKG_POLICY_DLLS_IN_STATIC_LIBRARY enabled)",
  "PortBugFoundEmptyDirectories": "不得有已安装的空目录。空目录对于一些二进制缓存提供程序和 Git 存储库是不可表示的，并且不被视为语义生成输出。应在每个空目录中创建常规文件，或者使用以下 CMake 删除它们。若要抑制此消息，请添加 set(VCPKG_POLICY_ALLOW_EMPTY_FOLDERS enabled)",
  "PortBugFoundExeInBinDir": "在 ${{CURRENT_PACKAGES_DIR}}/bin or ${{CURRENT_PACKAGES_DIR}}/debug/bin 中找到以下可执行文件。可执行文件不是有效的分发目标。如果这些可执行文件是生成工具，请考虑使用 `vcpkg_copy_tools`。若要抑制此消息，请添加 set(VCPKG_POLICY_ALLOW_EXES_IN_BIN enabled)",
  "PortBugFoundReleaseBinaries": "以下是发布二进制文件:",
  "PortBugIncludeDirInCMakeHelperPort": "CMake 帮助程序端口中存在 ${{CURRENT_PACKAGES_DIR}}/include 文件夹；这不正确，因为只应安装 CMake 文件。若要抑制此消息，请移除 set(VCPKG_POLICY_CMAKE_HELPER_PORT enabled)。",
  "PortBugInvalidCrtLinkageCrtGroup": "以下二进制文件应仅链接: {expected}",
  "PortBugInvalidCrtLinkageEntry": "{path} 与以下对象链接: {actual}",
  "PortBugInvalidCrtLinkageHeader": "此端口生成的二进制文件与 C 运行时(\"CRT\") 链接，这与三元组和部署结构请求的运行时不一致。如果三元组打算只使用发布 CRT，应将 set(VCPKG_POLICY_ONLY_RELEASE_CRT enabled) 添加到 triplet .cmake 文件中。若要完全取消此检查，请将 set(VCPKG_POLICY_SKIP_CRT_LINKAGE_CHECK enabled) 添加到 triplet .cmake (如果范围是三元组)，或者将其添加到 portfile.cmake (如果这特定于端口)。以使用以下方式检查二进制文件: dumpbin.exe/directives mylibfile.lib",
  "PortBugKernel32FromXbox": "所选三元组面向 Xbox，但以下 DLL 与 kernel32 链接。无法在没有 kernel32 的 Xbox 上加载这些 DLL。这通常是由于与 kernel32.lib 而不是适合的 umbrella 库(例如 onecore_apiset.lib 或 xgameplatform.lib)链接而导致的。可使用 `dumpbin.exe /dependents mylibfile.dll` 检查 DLL 的依赖项。若要抑制此消息，请添加 set(VCPKG_POLICY_ALLOW_KERNEL32_FROM_XBOX enabled)",
  "PortBugMergeLibCMakeDir": "此端口会创建 ${{CURRENT_PACKAGES_DIR}}/lib/cmake 和/或 ${{CURRENT_PACKAGES_DIR}}/debug/lib/cmake，这应会合并并移动到 ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/cmake。请使用 vcpkg-cmake-config 端口中的帮助程序函数 vcpkg_cmake_config_fixup()。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_LIB_CMAKE_MERGE_CHECK enabled)",
  "PortBugMismatchingNumberOfBinaries": "调试二进制文件和发布二进制文件数量不匹配。这通常表示 portfile.cmake 或生成系统中的调试或发布处理不正确。如果目的是仅为此三元组生成发布组件，则三元组应将 set(VCPKG_BUILD_TYPE release) 添加到其 .cmake 文件。若要抑制此消息，请添加 set(VCPKG_POLICY_MISMATCHED_NUMBER_OF_BINARIES enabled)",
  "PortBugMisplacedCMakeFiles": "此端口在不需要 CMake 文件的位置安装以下 CMake 文件。应在 ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}} 中安装 CMake 文件。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_MISPLACED_CMAKE_FILES_CHECK enabled)",
  "PortBugMisplacedFiles": "以下常规文件安装到可能没有安装常规文件的位置。这些文件应安装在子目录中。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_MISPLACED_REGULAR_FILES_CHECK enabled)",
  "PortBugMisplacedPkgConfigFiles": "已安装以下已放错位置的 pkgconfig 目录。pkgconf 或 pkg-config 无法正确找到错放的 pkgconfig 文件。pkgconfig 目录应为 ${{CURRENT_PACKAGES_DIR}}/share/pkgconfig (仅适用于与体系结构无关的库/仅限标头的库)、${{CURRENT_PACKAGES_DIR}}/lib/pkgconfig (适用于发布依赖项)或 ${{CURRENT_PACKAGES_DIR}}/debug/lib/pkgconfig (适用于调试依赖项)。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_PKGCONFIG_CHECK enabled)",
  "PortBugMissingCMakeHelperPortFile": "不存在 ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/vcpkg-port-config.cmake 文件。对于 CMake 帮助程序端口，必须存在此文件。若要抑制此消息，请移除 set(VCPKG_POLICY_CMAKE_HELPER_PORT enabled)",
  "PortBugMissingDebugBinaries": "找不到调试二进制文件。",
  "PortBugMissingImportedLibs": "似乎缺少已安装的 DLL 的导入库。如果是有意为之，则添加 set(VCPKG_POLICY_DLLS_WITHOUT_LIBS enabled)",
  "PortBugMissingIncludeDir": "${{CURRENT_PACKAGES_DIR}}/include 文件夹为空或不存在。这通常表示未正确安装标头。如果这是 CMake 帮助程序端口，请添加 set(VCPKG_POLICY_CMAKE_HELPER_PORT enabled)。如果这不是 CMake 帮助程序端口，但这是有意为之，请添加 set(VCPKG_POLICY_EMPTY_INCLUDE_FOLDER enabled) 以抑制此消息。",
  "PortBugMissingLicense": "该许可证未安装到 ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/copyright。可添加对 vcpkg_install_copyright 的调用来解决此问题。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_COPYRIGHT_CHECK enabled)",
  "PortBugMissingLicenseFixIt": "请考虑添加: {value}",
  "PortBugMissingProvidedUsage": "此端口包含名为 \"usage\" 的文件，但未将其安装到 ${{CURRENT_PACKAGES_DIR}}/share/${{PORT}}/usage。如果此文件不打算用作用法文本，请考虑选择其他名称；否则，请安装它。若要抑制此消息，请添加 set(VCPKG_POLICY_SKIP_USAGE_INSTALL_CHECK enabled)",
  "PortBugMissingReleaseBinaries": "找不到版本二进制文件。",
  "PortBugMovePkgConfigFiles": "可以使用类似于以下的命令移动 pkgconfig 文件:",
  "PortBugOutdatedCRT": "已安装与过时的 C 运行时(\"CRT\") DLL 链接的 DLL。已安装的 DLL 应与支持中的 CRT 链接。可使用 `dumpbin.exe /dependents mylibfile.dll` 检查 DLL 的依赖项。如果使用的是面向旧 CRT 的自定义三元组，请将 set(VCPKG_POLICY_ALLOW_OBSOLETE_MSVCRT enabled) 到三元组 .cmake 文件。若要抑制此端口的此消息，请添加 set(VCPKG_POLICY_ALLOW_OBSOLETE_MSVCRT enabled)",
  "PortBugRemoveBinDir": "如果无法禁用这些目录的创建，可在 portfile.cmake 中添加以下内容来移除它们",
  "PortBugRemoveEmptyDirs": "file(REMOVE_RECURSE 上述重命名留下的空目录)",
  "PortBugRestrictedHeaderPaths": "使用以下受限标头可能会阻止核心 C++ 运行时和其他包正确编译。应重命名它们或转而将其存储在子目录中。在特殊情况下，可通过添加 set(VCPKG_POLICY_ALLOW_RESTRICTED_HEADERS enabled) 来抑制此警告",
  "PortBugRestrictedHeaderPathsNote": "标头相对于此处的 ${{CURRENT_PACKAGES_DIR}}/include",
  "PortBugSetDllsWithoutExports": "在没有任何导出的情况下生成以下 DLL。没有导出的 DLL 可能是生成脚本中的 bug。如果是有意为之，则添加 set(VCPKG_POLICY_DLLS_WITHOUT_EXPORTS enabled)",
  "PortDeclaredHere": "{package_name} 已在此处声明",
  "PortDependencyConflict": "端口 {package_name} 具有以下不受支持的依赖项:",
  "PortDoesNotExist": "{package_name} 不存在",
  "PortMissingManifest2": "缺少 {package_name} 端口清单(无 vcpkg.json 或 CONTROL 文件)",
  "PortNotInBaseline": "基线不包含端口 {package_name} 的条目",
  "PortNotSupported": "{triplet} 不支持 {package_name}",
  "PortSupportsField": "(支持: “{supports_expression}”)",
  "PortVersionConflict": "以下包不同于其端口版本:",
  "PortVersionControlMustBeANonNegativeInteger": "“Port-Version”必须是非负整数",
  "PortVersionMultipleSpecification": "\"port_version\" 不能与版本中嵌入的 \"#\" 组合使用",
  "PortsAdded": "添加了以下 {count} 个端口:",
  "PortsNoDiff": "两次提交之间的端口没有变化。",
  "PortsRemoved": "删除了以下 {count} 个端口:",
  "PortsUpdated": "以下 {count} 个端口已更新:",
  "PrebuiltPackages": "存在尚未生成的包。如果要生成它们，请运行:",
  "PrecheckBinaryCache": "正在检查二进制缓存...",
  "PreviousDeclarationWasHere": "上一个声明在此处",
  "PreviousIntegrationFileRemains": "未删除以前的集成文件。",
  "ProgramPathReturnedNonzeroExitCode": "失败，退出代码为 {exit_code}",
  "ProgramReturnedNonzeroExitCode": "{tool_name} 失败，退出代码: {exit_code}。",
  "ProvideExportType": "至少需要以下其中一个选项: --raw --nuget --zip --7zip。",
  "PushingVendorFailed": "将 {vendor} 推送到“{path}”失败。请使用 --debug 获取详细信息。",
  "RegeneratesArtifactRegistry": "重新生成项目注册表",
  "RegistryCreated": "已在 {path} 下成功创建注册表",
  "RegistryValueWrongType": "注册表值 {path} 为意外类型。",
  "RemoveDependencies": "要在清单模式下移除依赖项，请编辑清单(vcpkg.json)并运行 “install”。",
  "RemovePackageConflict": "{spec} 未安装，但为 {triplet} 安装了 {package_name}。你是否指的是 {package_name}: {triplet}?",
  "RemovingPackage": "正在删除 {action_index}/{count} 个 {spec}",
  "ResponseFileCode": "@response_file",
  "RestoredPackagesFromAWS": "{elapsed} 后从 AWS 还原了 {count} 个包。使用 --debug 了解更多详细信息。",
  "RestoredPackagesFromAZUPKG": "{elapsed}内从 Universal Packages 还原了 {count} 个包。使用 --debug 了解更多详细信息。",
  "RestoredPackagesFromAzureStorage": "在 {elapsed} 内从 Azure 存储还原了 {count} 个包。使用 --debug 查看更多详细信息。",
  "RestoredPackagesFromCOS": "{elapsed} 后从 COS 还原了 {count} 个包。使用 --debug 了解更多详细信息。",
  "RestoredPackagesFromFiles": "{elapsed} 后从 {path} 还原了 {count} 个包。使用 --debug 了解更多详细信息。",
  "RestoredPackagesFromGCS": "{elapsed} 后从 GCS 还原了 {count} 个包。使用 --debug 了解更多详细信息。",
  "RestoredPackagesFromHTTP": "{elapsed} 后从 HTTP 服务器还原了 {count} 个包。使用 --debug 了解更多详细信息。",
  "RestoredPackagesFromNuGet": "{elapsed} 后从 NuGet 还原了 {count} 个包。使用 --debug 了解更多详细信息。",
  "ResultsHeader": "结果",
  "ScriptAssetCacheRequiresScript": "应为参数: 资产配置 \"x-script\" 要求将 exec 模板精确用作参数",
  "SecretBanner": "*** 机密 ***",
  "SeeURL": "有关详细信息，请参阅 {url}。",
  "SerializedBinParagraphHeader": "\n序列化二进制段落",
  "SettingEnvVar": "-- 正在将“{env_var}”环境变量设置为“{url}”。",
  "ShaPassedAsArgAndOption": "已将 SHA512 同时作为参数和选项传递。请仅传递其中一个。",
  "ShaPassedWithConflict": "已传递 SHA512，但也传递了 --skip-sha512；请仅执行两者其中之一。",
  "ShallowRepositoryDetected": "vcpkg 已克隆为浅层存储库。请使用完整的 vcpkg 克隆重试。",
  "SkipClearingInvalidDir": "正在跳过清除 {path} 的内容，因为它不是目录。",
  "SkipTestingOfPort": "正在跳过 {feature_spec} 的测试，因为 {triplet} 不支持以下依赖项:",
  "SkipTestingOfPortAlreadyInBinaryCache": "正在跳过测试，因为 ABI 哈希 {sha} 已在二进制缓存中。",
  "SkippingPostBuildValidationDueTo": "由于 {cmake_var}，正在跳过生成后验证",
  "SourceFieldPortNameMismatch": "CONTROL 文件中的“Source”字段或 vcpkg.json 文件中的“name”字段具有名称 {package_name}，并且与端口目录“{path}”不匹配。",
  "SpecifiedFeatureTurnedOff": "已专门禁用“{command_name}”功能，但已指定 --{option}。",
  "SpecifyHostArch": "主机三元组。请参阅“vcpkg 帮助三元组”(默认值:“{env_var}”)",
  "SpecifyTargetArch": "目标三元组。请参阅“vcpkg 帮助三元组”(默认值:“{env_var}”)",
  "StartCodeUnitInContinue": "在“继续”位置找到了起始代码单元",
  "StartingFeatureTest": "功能测试 [{value}] {feature_spec}",
  "StoreOptionMissingSha": "--store 选项无效，没有 sha512",
  "SubmittingBinaryCacheBackground": "正在开始将 {spec} 提交到后台 {count} 二进制缓存()",
  "SubmittingBinaryCacheComplete": "已完成向 {elapsed} 中的 {count} 二进制缓存() 提交 {spec}",
  "SuggestGitPull": "结果可能已过时。运行 `git pull` 以获取最新结果。",
  "SuggestStartingBashShell": "请确保已启动新的 bash shell 以使更改生效。",
  "SupportedPort": "支持端口 {package_name}。",
  "SwitchUsedMultipleTimes": "已多次指定开关“{option}”",
  "SynopsisHeader": "摘要:",
  "SystemApiErrorMessage": "调用 {system_api} 失败，{exit_code} ({error_msg})",
  "SystemTargetsInstallFailed": "无法将系统目标文件安装到 {path}",
  "ToRemovePackages": "若要仅删除过时的包，请运行\n{command_name} remove --outdated",
  "ToUpdatePackages": "若要更新这些包和所有依赖项，请运行\n{command_name} upgrade'",
  "ToolDataFileSchemaVersionNotSupported": "此版本的 vcpkg 不支持文档架构版本 {version}",
  "ToolFetchFailed": "无法提取 {tool_name}。",
  "ToolHashMismatch": "{tool_name} 似乎已下载，但哈希不正确。应为 {expected}，但已 {actual}",
  "ToolInWin10": "此实用工具与 Windows 10 或更高版本捆绑。",
  "ToolOfVersionXNotFound": "找不到合适的{tool_name}版本(所需版本为 {version})，而且无法自动下载可移植版本。请安装较新版本的{tool_name}",
  "TotalInstallTime": "总安装时间: {elapsed}",
  "TotalInstallTimeSuccess": "已在 {elapsed} 内成功完成所有请求的安装",
  "TrailingCommaInArray": "数组中的尾随逗号",
  "TrailingCommaInObj": "对象中的尾随逗号",
  "TripletFileNotFound": "找不到三重文件 {triplet}.cmake",
  "TripletLabel": "三元组:",
  "TwoFeatureFlagsSpecified": "“{value}”和-“{value}”均已指定为功能标志。",
  "UnableToClearPath": "无法删除 {path}",
  "UnableToReadAppDatas": "%LOCALAPPDATA% 和 %APPDATA% 均不可读",
  "UnableToReadEnvironmentVariable": "无法读取 {env_var}",
  "UndeterminedToolChainForTriplet": "无法确定具有 CMAKE_SYSTEM_NAME {system_name} 的 {triplet} 的工具链使用。是否打算使用 VCPKG_CHAINLOAD_TOOLCHAIN_FILE?",
  "UnexpectedArgument": "意外参数: {option}",
  "UnexpectedAssetCacheProvider": "未知资产提供程序类型: 有效的源类型为“x-azurl”、“x-script”、“x-block-origin”和“clear”",
  "UnexpectedByteSize": "应写入 {expected} 个字节，但已写入 {actual}。",
  "UnexpectedCharExpectedCloseBrace": "意外字符；应为属性或右大括号",
  "UnexpectedCharExpectedColon": "意外字符；应为冒号",
  "UnexpectedCharExpectedName": "意外字符；应为属性名称",
  "UnexpectedCharExpectedValue": "意外字符；预期值",
  "UnexpectedCharMidArray": "数组中间出现意外字符",
  "UnexpectedCharMidKeyword": "关键字中间出现意外字符",
  "UnexpectedDigitsAfterLeadingZero": "前导零后出现意外数字",
  "UnexpectedEOFAfterBacktick": "意外的 eof: 不允许尾随的未转义反引号 (`)",
  "UnexpectedEOFAfterEscape": "转义字符后出现意外的 EOF",
  "UnexpectedEOFAfterMinus": "减号后出现意外的 EOF",
  "UnexpectedEOFExpectedChar": "意外字符；应为 EOF",
  "UnexpectedEOFExpectedCloseBrace": "意外的 EOF；应为属性或右大括号",
  "UnexpectedEOFExpectedColon": "意外的 EOF；应为冒号",
  "UnexpectedEOFExpectedName": "意外的 EOF；应为属性名称",
  "UnexpectedEOFExpectedProp": "意外的 EOF；应为属性",
  "UnexpectedEOFExpectedValue": "意外的 EOF；预期值",
  "UnexpectedEOFMidArray": "数组中间出现意外的 EOF",
  "UnexpectedEOFMidKeyword": "关键字中间出现意外的 EOF",
  "UnexpectedEOFMidString": "字符串中间出现意外的 EOF",
  "UnexpectedEOFMidUnicodeEscape": "在 unicode 转义中间出现意外的文件结尾",
  "UnexpectedEscapeSequence": "意外的转义序列延续",
  "UnexpectedField": "意外字段 \"{json_field}\"",
  "UnexpectedFieldSuggest": "意外字段 \"{json_field}\"，你的意思是 \"{value}\" 吗?",
  "UnexpectedFormat": "预期格式为 [{expected}]，但实际为 [{actual}]。",
  "UnexpectedOption": "意外选项: {option}",
  "UnexpectedPortName": "端口 {expected} 在 {path} 中声明为 {actual}",
  "UnexpectedPortversion": "没有版本控制字段的意外 \"port-version\"",
  "UnexpectedStateCascade": "{feature_spec} 意外发生级联故障，因为以下依赖项不可用:",
  "UnexpectedStateCascadePortNote": "请考虑将此项更改为 =cascade",
  "UnexpectedStateFailedCascade": "{feature_spec} 生成失败，但应该是级联失效",
  "UnexpectedStateFailedNoteConsiderSkippingPort": "请考虑添加 `{package_name}=fail`、`{spec}=fail` 或等效的跳过选项",
  "UnexpectedStateFailedNoteConsiderSkippingPortOrCombination": "请考虑添加 `{package_name}=fail`、`{spec}=fail`、`{feature_spec}=combination-fails` 或等效的跳过选项，或者通过将互斥功能标记为选项来处理",
  "UnexpectedStateFailedNoteFeatureMarkedCascade": "请考虑将此 `=cascade` 更改为 `=feature-fails` 和/或一个或多个 `=combination-fails`",
  "UnexpectedStateFailedNoteMoreFeaturesRequired": "如果某些功能是必需的，请考虑在 portfile.cmake 中始终为 {package_name} 启用这些部分，或者考虑添加 `{package_name}[required-feature]=options` 以在所有测试中包含 'required-feature'",
  "UnexpectedStateFailedNotePortMarkedCascade": "请考虑将 `=cascade` 更改为 `=fail`",
  "UnexpectedStateFailedNoteSeparateCombinationFails": "如果 {feature} 在与其他功能一起构建时成功，但单独构建时失败，请考虑添加 `{feature_spec}=combination-fails`",
  "UnexpectedStateFailedNoteSeparateFeatureFails": "如果 {feature} 始终失败，请考虑添加 `{feature_spec}=feature-fails`，它将把此测试标记为失败，并从组合功能测试中删除 {feature}",
  "UnexpectedStateFailedPass": "{feature_spec} 生成失败，但预计会通过",
  "UnexpectedStatePassFeatureMarkedCascade": "{feature_spec} 通过了，但 {feature} 被标记为应为级联失效",
  "UnexpectedStatePassFeatureMarkedFail": "{feature_spec} 通过了，但 {feature} 被标记为应失败",
  "UnexpectedStatePassPortMarkedCascade": "{feature_spec} 通过了，但被标记为应为级联失效",
  "UnexpectedStatePassPortMarkedFail": "{feature_spec} 通过了，但被标记为应失败",
  "UnexpectedSwitch": "意外开关: {option}",
  "UnexpectedToolOutput": "{tool_name} ({path}) 在尝试确定版本时生成了意外输出:",
  "UnexpectedWindowsArchitecture": "意外的 Windows 主机体系结构: {actual}",
  "UnknownBaselineFileContent": "无法识别的基线条目；应为 “port:triplet=(fail|skip|pass)”",
  "UnknownBinaryProviderType": "未知的二进制提供程序类型: 有效提供程序为 “clear”、“default”、“nuget”、“nugetconfig”、“nugettimeout”、“\"interactive”、“x-azblob”、“x-gcs”、“x-aws”、“x-aws-config”、“http” 和 “files”",
  "UnknownBooleanSetting": "{option} 的布尔值设置未知: \"{value}\"。有效值为 \"\"、\"1\"、\"0\"、\"ON\"、\"OFF\"、\"TRUE\" 和 \"FALSE\"。",
  "UnknownParameterForIntegrate": "用于集成的参数“{value}”未知。",
  "UnknownPolicySetting": "{cmake_var} 的设置未知: {value}。有效的策略值为“已禁用”和“已启用”。",
  "UnknownSettingForBuildType": "VCPKG_BUILD_TYPE {option} 的设置未知。有效设置为 ''、“debug” 和 “release”。",
  "UnknownTool": "vcpkg 没有为适用于此平台的这一工具提供定义。",
  "UnknownTopic": "未知主题 {value}",
  "UnknownVariablesInTemplate": "参数无效: URL 模板“{value}”包含未知变量: {list}",
  "UnrecognizedConfigField": "配置包含以下无法识别的字段:",
  "UnrecognizedIdentifier": "标识符名称 {value} 无法识别。添加以覆盖三元组文件中的列表。",
  "UnsupportedFeature": "已传递功能 {feature}，但 {package_name} 支持不支持该功能。",
  "UnsupportedFeatureSupportsExpression": "{feature_spec} 仅在“{supports_expression}”上受支持，这与 {triplet} 不匹配。这通常意味着在生成其他平台时存在已知的生成失败或运行时问题。要忽略此项并且仍然尝试生成 {package_name}，请使用 `--allow-uns supported` 重新运行 vcpkg。",
  "UnsupportedFeatureSupportsExpressionWarning": "{feature_spec} 仅在“{supports_expression}”上受支持，这与 {triplet} 不匹配。这通常意味着在生成其他平台时存在已知的生成失败或运行时问题。但由于 `--allow-unsported`，请仍然继续操作。",
  "UnsupportedPort": "不支持端口 {package_name}。",
  "UnsupportedPortDependency": "- 不支持依赖项 {value}。",
  "UnsupportedSyntaxInCDATA": "]]> 在 CDATA 块中不受支持",
  "UnsupportedSystemName": "无法将 VCPKG_CMAKE_SYSTEM_NAME “{system_name}” 映射到 vcvarsall 平台。支持的系统名称为 ''、“Windows” 和 “WindowsStore”。",
  "UnsupportedToolchain": "在三元组 {triplet} 中: 无法为请求的目标体系结构 {arch} 找到有效的工具链。\n所选 Visual Studio 实例位于: {path}\n可用的工具链组合为 {list}",
  "UnsupportedUpdateCMD": "更新命令当前不支持清单模式。请改为修改 vcpkg.json 并运行安装命令。",
  "UpdateBaselineAddBaselineNoManifest": "已传递 --{option} 开关，但不存在要向其添加 `builtin-baseline` 字段的清单文件。",
  "UpdateBaselineLocalGitError": "git 无法分析位于“{path}”的本地 vcpkg 注册表的 HEAD",
  "UpdateBaselineNoConfiguration": "不存在要更新的 `vcpkg.json` 和 `vcpkg-configuration.json`。",
  "UpdateBaselineNoExistingBuiltinBaseline": "清单文件当前不包含 `builtin-baseline` 字段；如果要添加一个，请传递 --{option} 开关。",
  "UpdateBaselineNoUpdate": "注册表“{url}”未更新:“{value}”",
  "UpdateBaselineRemoteGitError": "git 无法提取远程存储库“{url}”",
  "UpdateBaselineUpdatedBaseline": "已更新注册表“{url}”: 基线“{old_value}”->“{new_value}”",
  "UpgradeInManifest": "升级 升级经典模式安装，因此不支持清单模式。请考虑通过使用 vcpkg x-update-baseline 将基线更新为当前值，并运行 vcpkg 安装来更新依赖项。",
  "UpgradeRunWithNoDryRun": "如果确实要重新生成上述包，请使用 --no-dry-run 选项运行此命令。",
  "UploadingBinariesToVendor": "正在将 {spec} 的二进制文件上传到 {path} {vendor}",
  "UsageInstallInstructions": "可使用以下 CMake 安装 usage 文件",
  "UsageTextHere": "usage 文件位于此处",
  "UseEnvVar": "-- 正在使用环境变量中的 {env_var}。",
  "UserWideIntegrationDeleted": "未安装用户范围的集成。",
  "UserWideIntegrationRemoved": "已删除用户范围的集成。",
  "UsingManifestAt": "正在 {path} 使用清单文件。",
  "Utf8ConversionFailed": "未能转换为 UTF-8",
  "VSExaminedInstances": "考虑了以下 Visual Studio 实例:",
  "VSExaminedPaths": "检查了 Visual Studio 实例的以下路径:",
  "VSNoInstances": "找不到完整的 Visual Studio 实例",
  "VcpkgCeIsExperimental": "vcpkg-artifact 是实验性的，可能会随时发生更改。",
  "VcpkgCompletion": "vcpkg {value}完成已导入到“{path}”文件。\n找到以下条目:",
  "VcpkgDisallowedClassicMode": "无法在当前工作目录之上找到清单(vcpkg.json)。\n此 vcpkg 分发没有经典模式实例。",
  "VcpkgHasCrashed": "vcpkg 已崩溃。请在 https://github.com/microsoft/vcpkg 创建一个问题，其中包含你尝试执行的操作的简短摘要以及以下信息。",
  "VcpkgInVsPrompt": "vcpkg 似乎位于面向 {value} 的 Visual Studio 提示中，但正在为 {triplet} 安装。请考虑使用 --triplet {value}-windows 或 --triplet {value}-uwp。",
  "VcpkgInvalidCommand": "无效命令: {command_name}",
  "VcpkgRegistriesCacheIsNotDirectory": "环境变量 X_VCPKG_REGISTRIES_CACHE 的值不是目录: {path}",
  "VcpkgRootRequired": "独立启动需要设置 VCPKG_ROOT。",
  "VcpkgRootsDir": "vcpkg 根目录(默认值:“{env_var}”)",
  "VcpkgSendMetricsButDisabled": "已传递 --sendmetrics，但指标已禁用。",
  "VcpkgUsage": "用法: vcpkg <command> [--switches] [--options=values] [arguments] @response_file",
  "VcvarsRunFailed": "无法运行 vcvarsall.bat 以获取 Visual Studio 环境",
  "VcvarsRunFailedExitCode": "尝试获取 Visual Studio 环境时，vcvarsall.bat 返回了 {exit_code}",
  "VersionBaselineMatch": "{version_spec} 与当前基线匹配",
  "VersionBaselineMismatch": "{package_name} 已分配 {actual}，但本地端口为 {expected}",
  "VersionBuiltinPortTreeEntryMissing": "{expected} 处没有 {package_name} 的版本数据库条目；使用签出的端口树版本 ({actual})。",
  "VersionCommandHeader": "vcpkg 包管理程序版本 {version}\n\n查看 LICENSE.txt 获取许可证信息。",
  "VersionConstraintNotInDatabase1": "版本数据库中不存在的 {package_name} 名称版本 {version} 的 \"version>=\" 约束。所有版本都必须存在于版本数据库中才能由 vcpkg 进行解释。",
  "VersionConstraintNotInDatabase2": "考虑移除版本约束或选择此处声明的值",
  "VersionConstraintOk": "所有版本约束都与版本数据库一致",
  "VersionConstraintPortVersionMustBePositiveInteger": "“version>=” 中的 port-version (在 “#” 之后)必须为负整数",
  "VersionConstraintViolated": "依赖项 {spec} 应至少为 {expected_version} 版本，但目前为 {actual_version}。",
  "VersionDatabaseEntryMissing": "{version} 处没有 {package_name} 的版本条目。",
  "VersionDatabaseFileMissing": "此端口不在版本数据库中",
  "VersionDatabaseFileMissing2": "版本数据库文件应在此处",
  "VersionDatabaseFileMissing3": "运行 \"{command_line}\" 以创建版本数据库文件",
  "VersionGitEntryMissing": "{version} 处没有 {package_name} 的版本数据库条目。\n可用版本:",
  "VersionInDeclarationDoesNotMatch": "{git_tree_sha} 已声明为包含 {expected}，但似乎包含的是 {actual}",
  "VersionIncomparable1": "{spec} 上的版本冲突:需要 {constraint_origin} {expected}，这无法与基线版本 {actual} 进行比较。",
  "VersionIncomparable2": "“{version_spec}”具有方案“{new_scheme}”",
  "VersionIncomparable3": "可以将显式替代添加到首选版本以解决此问题，例如:",
  "VersionIncomparable4": "有关详细信息，请参阅“vcpkg 帮助版本控制”或 {url}。",
  "VersionIncomparableSchemeString": "两个版本都有方案字符串，但主文本不同。",
  "VersionIncomparableSchemes": "这些版本具有不兼容的方案:",
  "VersionInvalidDate": "“{version}”不是有效的日期版本。日期必须采用 YYYY-MM-DD 格式，并且消歧因子必须是不带前导零的点分隔正整数值。",
  "VersionInvalidRelaxed": "“{version}”不是有效的宽松版本(具有任意数值元素计数的 semver)。",
  "VersionInvalidSemver": "“{version}”不是有效的语义版本，请参阅 <https://semver.org>。",
  "VersionMissing": "需要版本控制字段(版本、版本日期、版本-semver 或版本字符串)之一",
  "VersionMissingRequiredFeature": "“{version_spec}”没有“{constraint_origin}”所需的功能“{feature}”",
  "VersionNotFoundInVersionsFile2": "在版本数据库中找不到 {version_spec}",
  "VersionNotFoundInVersionsFile3": "该版本应在此文件中",
  "VersionNotFoundInVersionsFile4": "运行 \"{command_line}\" 以添加新的端口版本",
  "VersionOverrideNotInVersionDatabase": "版本数据库中不存在版本替代项 {package_name}；该端口是否存在?",
  "VersionOverrideVersionNotInVersionDatabase1": "版本数据库中不存在的 {package_name} 名称版本 {version} 的替代项。在顶层安装此端口将失败，因为该版本将无法解析。",
  "VersionOverrideVersionNotInVersionDatabase2": "考虑移除版本替代项或选择此处声明的值",
  "VersionOverwriteVersion": "你可以通过运行以下命令，来使用正确的本地值覆盖 {version_spec}:",
  "VersionRejectedDueToBaselineMissing": "{path} 被拒绝，因为它使用了 \"{json_field}\"，并且没有“内置基线”。可以通过停止使用 \"{json_field}\" 或添加“内置基线”来修复此问题。\n有关详细信息，请参阅 `vcpkg help versioning`。",
  "VersionRejectedDueToFeatureFlagOff": "{path} 被拒绝，因为它使用了 \"{json_field}\"，并且禁用了 `versions` 功能标志。可以通过停止使用 \"{json_field}\" 或启用 `versions` 功能标志来修复此问题。\n有关详细信息，请参阅 `vcpkg help versioning`。",
  "VersionSchemeMismatch1": "{version} 已声明为 {expected}，但 {package_name} 是使用 {actual} 声明的",
  "VersionSchemeMismatch1Old": "{version} 已声明为 {expected}，但 {package_name}@{git_tree_sha} 是使用 {actual} 声明的",
  "VersionSchemeMismatch2": "版本必须是唯一的，即使它们是使用不同的方案声明的",
  "VersionShaMismatch1": "{version_spec} git 树 {git_tree_sha} 与端口目录不匹配",
  "VersionShaMismatch2": "端口目录包含 git 树 {git_tree_sha}",
  "VersionShaMismatch3": "如果 {version_spec} 已发布，请使用新版本或端口版本更新此文件，提交该文件，然后通过运行以下命令来添加新版本:",
  "VersionShaMismatch4": "如果 {version_spec} 尚未发布，请通过运行以下命令来覆盖上一个 git 树:",
  "VersionSharpMustBeFollowedByPortVersion": "版本文本中的 \"#\" 必须后跟端口版本",
  "VersionSharpMustBeFollowedByPortVersionNonNegativeInteger": "版本文本中的 \"#\" 后面必须跟端口版本(非负整数)",
  "VersionSpecMismatch": "无法加载端口，因为版本不一致。文件“{path}”包含版本 {actual_version}，但版本数据库指示它应为 {expected_version}。",
  "VersionVerifiedOK": "{version_spec} 正确位于版本数据库({git_tree_sha})中",
  "WaitUntilPackagesUploaded": "正在等待剩余 {count} 二进制缓存提交...",
  "WaitingForChildrenToExit": "正在等待子进程退出...",
  "WaitingToTakeFilesystemLock": "正在等待锁定 {path} 上的文件系统...",
  "WarningsTreatedAsErrors": "以前被解释为错误的警告",
  "WhileCheckingOutBaseline": "签出基线 {commit_sha} 时",
  "WhileCheckingOutPortTreeIsh": "用 git 树 {git_tree_sha} 签出端口 {package_name} 时",
  "WhileGettingLocalTreeIshObjectsForPorts": "获取端口的本地树状对象时",
  "WhileLoadingBaselineVersionForPort": "加载 {package_name} 的基线版本期间",
  "WhileLoadingPortVersion": "加载 {version_spec} 时",
  "WhileLookingForSpec": "查找 {spec} 时:",
  "WhileParsingVersionsForPort": "分析来自 {path} 的 {package_name} 版本时",
  "WhileRunningAssetCacheScriptCommandLine": "运行资产缓存脚本命令行时",
  "WhileValidatingVersion": "验证版本: {version} 时",
  "WindowsEnvMustAlwaysBePresent": "应始终在 Windows 上设置 {env_var}。",
  "WindowsOnlyCommand": "此命令仅支持 Windows。",
  "WroteNuGetPkgConfInfo": "已将 NuGet 包配置信息写入 {path}",
  "FatalTheRootFolder$CannotBeCreated": "严重: 无法创建根文件夹“${p0}”",
  "FatalTheGlobalConfigurationFile$CannotBeCreated": "严重: 无法创建全局配置文件“${p0}”",
  "VCPKGCOMMANDWasNotSet": "未设置 VCPKG_COMMAND",
  "RunningVcpkgInternallyReturnedANonzeroExitCode$": "在内部运行 vcpkg 返回了非零退出代码: ${p0}",
  "failedToDownloadFrom$": "未能从 ${p0} 下载",
  "failedToDownload$FromAnySource": "未能从任何源下载 ${p0}",
  "ErrorParsingConditionalDemand$$": "分析条件需求“${p0}”时出错 - ${p1}",
  "MissingIdentity$": "缺少标识“${p0}”",
  "infoidShouldBeOfTypestringFound$": "info.id 的类型应为“string”，但找到的是“${p0}”",
  "MissingVersion$": "缺少版本“${p0}”",
  "infoversionShouldBeOfTypestringFound$": "info.version 的类型应为“string”，但找到的是“${p0}”",
  "infosummaryShouldBeOfTypestringFound$": "info.summary 的类型应为“string”，但找到的是“${p0}”",
  "infodescriptionShouldBeOfTypestringFound$": "info.description 的类型应为“string”，但找到的是“${p0}”",
  "infooptionsShouldBeASequenceFound$": "info.options 应为序列，找到的是“${p0}”",
  "TheInfoBlockIsDeprecatedForConsistencyWithVcpkgjsonMoveInfoMembersToTheOutside": "由于 vcpkg.json; 将信息成员移至外部，导致一致性出现问题，该信息区已被弃用。",
  "idShouldBeOfTypestringFound$": "ID 的类型应为“string”，但找到的是“${p0}”",
  "versionShouldBeOfTypestringFound$": "版本的类型应为“string”，但找到的是“${p0}”",
  "summaryShouldBeOfTypestringFound$": "摘要的类型应为“string”，但找到的是“${p0}”",
  "descriptionShouldBeOfTypestringFound$": "描述的类型应为“string”，但找到的是“${p0}”",
  "optionsShouldBeASequenceFound$": "选项应为序列，找到的是“${p0}”",
  "DuplicateKeysDetectedInManifest$": "在清单中检测到重复的密钥:“${p0}”",
  "noPostscriptFileRunVcpkgshellWithTheSameArguments": "无 postscript 文件：使用相同的参数运行 vcpkg-shell",
  "DuplicateDefine$DuringActivationNewValueWillReplaceOld": "激活过程中重复定义 ${p0}。新值将替换旧值。",
  "DuplicateToolDeclared$DuringActivationNewValueWillReplaceOld": "激活过程中声明了重复的工具 ${p0}。新值将替换旧值。",
  "DuplicateAliasDeclared$DuringActivationNewValueWillReplaceOld": "激活过程中声明了重复的别名 ${p0}。新值将替换旧值。",
  "DuplicateLocationDeclared$DuringActivationNewValueWillReplaceOld": "激活过程中声明了重复的位置 ${p0}。新值将替换旧值。",
  "CircularVariableReferenceDetected$": "检测到循环变量引用: ${p0}",
  "CircularVariableReferenceDetected$$": "检测到循环变量引用: ${p0} - ${p1}",
  "VariableReferenceFound$$$ThatIsReferencingAnUnknownBaseObject": "变量引用发现引用未知基对象的“$${p0}.${p1}”。",
  "UnresolvedVariableReferenceFound$$$DuringVariableSubstitution": "变量替换过程找到的无法解析的变量引用($${p0}.${p1})。",
  "InvalidPathDoesNotExist$": "路径无效 - 不存在: ${p0}",
  "Activating$": "正在激活: ${p0}",
  "Deactivating$": "正在停用: ${p0}",
  "nothingIsActivatedNoChangesHaveBeenMade": "未激活任何内容，未进行任何更改",
  "InvalidArtifactId$": "无效的项目 ID“${p0}”",
  "UnknownInstallerType$": "未知的安装程序类型 ${p0}",
  "WhileResolvingDependenciesOf$$In$CouldNotBeResolvedToARegistry": "解析 ${p0} 的依赖项时，无法将 ${p2} 中的 ${p1} 解析到注册表。",
  "WhileResolvingDependenciesOfTheProjectFile$$DidNotSpecifyARegistry": "解析项目文件 ${p0} 的依赖项时，${p1} 未指定注册表。",
  "UnableToResolveDependency$In$": "无法解析 ${p1} 中的依赖项 ${p0}。",
  "Artifact": "项目",
  "Version": "版本",
  "Status": "状态",
  "Dependency": "依赖项",
  "Summary": "摘要",
  "progressUnknown": "(进度未知)",
  "verifying": "正在验证",
  "downloading$$": "正在下载 ${p0} -> ${p1}",
  "unpacking$": "正在解压缩 ${p0}",
  "Installing$": "正在安装 ${p0}...",
  "$AlreadyInstalled": "已安装 ${p0}。",
  "Downloading$": "正在下载 ${p0}...",
  "Unpacking$": "正在解压缩 ${p0}...",
  "ErrorInstalling$$": "安装时出错 ${p0} - ${p1}",
  "error": "错误:",
  "warning": "警告:",
  "ExpectedASingleValueFor$FoundMultiple": "${p0} 只需要一个值 - 找到多个值",
  "ExpectedASingleValueFor$": "“--${p0}”只需要一个值。",
  "Assuming$IsCorrectSupplyAHashInTheArtifactMetadataToSuppressThisMessage": "假定“${p0}”正确; 在项目元数据中提供哈希以禁止显示此消息。",
  "DownloadedFile$DidNotHaveTheCorrectHash$$": "下载的文件“${p0}”没有正确的哈希(${p1}: ${p2}) ",
  "packageReference$IsNotAValidNugetPackageReferencenameversion": "包引用“${p0}”不是有效的 nuget 包引用({name}/{version})",
  "statsMayNotBeUndefined": "统计信息可能未定义",
  "CannotRenameFilesAcrossFilesystems": "无法跨文件系统重命名文件",
  "CopyFailedSource$IsAFolderTarget$IsAFile": "复制失败: 源(${p0})是一个文件夹，目标(${p1})是一个文件",
  "UriMayNotBeEmpty": "URI 不能为空",
  "scheme$AlreadyRegistered": "方案“${p0}”已注册",
  "uri$HasNoScheme": "URI ${p0} 没有方案",
  "scheme$HasNoFilesystemAssociatedWithIt": "方案 ${p0} 没有与之关联的文件系统",
  "mayNotRenameAcrossFilesystems": "不能跨文件系统重命名",
  "CouldNotActivateEspidfPythonWasNotFound": "无法激活 esp-idf: 未找到 python。",
  "GitIsNotInstalled": "未安装 Git。",
  "InitializingRepositoryFolder": "正在初始化存储库文件夹",
  "FailedToInitializeGitRepositoryFolder$": "无法初始化文件夹(${p0})的 git 存储库",
  "AddingRemote$ToGitRepositoryFolder": "正在将远程 ${p0} 添加到 git 存储库文件夹",
  "FailedToSetGitOrigin$InFolder$": "未能在文件夹(${p1})中设置 git 原点(${p0})",
  "FetchingRemote$ForGitRepositoryFolder": "正在提取 git 存储库文件夹的远程 ${p0}",
  "UnableToFetchGitDataFor$InFolder$": "无法提取文件夹(${p1})中(${p0})的数据",
  "CheckingOutCommit$For$ToGitRepositoryFolder": "正在将 ${p0} ${p1} 提交到 GIT 存储库文件夹",
  "UnableToCheckoutDataFor$InFolder$": "无法签出文件夹(${p1})中(${p0})的数据",
  "UpdatingSubmodulesForRepository$InTheGitRepositoryFolder": "正在更新 GIT 存储库文件夹中存储库 ${p0} 的子模块",
  "UnableToSetSubmoduleShallowDataFor$InFolder$": "无法为文件夹(${p1})中的(${p0})设置子模块浅数据",
  "UnableUpdateSubmodulesFor$InFolder$": "无法更新文件夹(${p1})中(${p0})的子模块",
  "ExpectedCommaFound$": "应为逗号，找到的是 ${p0}",
  "ExpectedOneOfNumberBooleanIdentifierStringFoundToken$": "应为 {Number, Boolean, Identifier, String} 中的一个，找到令牌 ${p0}",
  "ExpressionSpecifiedNOTTwice": "表达式指定 NOT 两次",
  "ExpectedCloseParenthesisForExpressionFound$": "表达式需要右括号，找到的是 ${p0}",
  "ExpectedExpressionFound$": "应为表达式，找到的是 ${p0}",
  "ParseErrorDigitExpected": "ParseError: 数字应为(0-9)",
  "ParseErrorHexDigitExpectedFf": "ParseError: 需要十六进制数字(0-F,0-f)",
  "ParseErrorBinaryDigitExpected": "ParseError: 二进制数字应为(0,1)",
  "UnexpectedEndOfFileWhileSearchingFor$": "搜索“${p0}”时意外的文件结尾",
  "InvalidEscapeSequence": "转义序列无效",
  "FailedToDeserializeIndex$": "未能反序列化索引 ${p0}",
  "$MatchedMoreThanOneResult$": "“${p0}”与多个结果匹配(${p1})。",
  "UnsupportedRegistryScheme$": "不支持的注册表方案“${p0}”",
  "TriedToAdd$As$But$IsAlready$": "尝试将 ${p0} 添加为 ${p1}，但 ${p2} 已经是 ${p3}。",
  "UnknownRegistry$in$TheFollowingAreKnown$": "(${p1} 中)的未知注册表 ${p0}。以下注册表为已知: ${p2}",
  "UpdatingRegistryDataFrom$": "正在从 ${p0} 更新注册表数据",
  "$MustBeAString": "${p0} 必须是字符串",
  "$MustBeABool": "${p0} 必须是布尔值",
  "$MustBeAnArrayOfStringsOrUnset": "${p0} 必须是字符串数组，或未设置",
  "FoundAMismatched$In$ForALiteral$Use$$Instead": "在“${p1}”中发现不匹配的 ${p0}。对于文本 ${p2}，请改用 ${p3}${p4}。",
  "CouldNotFindAValueFor$In$ToWriteTheLiteralValueUse$Instead": "在“${p1}”中找不到 {${p0}} 的值。若要写入文本值，请改用“{{${p2}}}”。",
  "MatchedMoreThanOneInstallBlock$": "匹配了多个安装块 [${p0}]",
  "UnableToFindProjectInFolderorParentFoldersFor$": "无法在 ${p0} 的文件夹(或父文件夹)中找到项目",
  "UnableToAcquireProject": "无法获取项目",
  "NoArtifactsSpecified": "未指定项目",
  "NoArtifactsAreAcquired": "未获取任何项目",
  "AllArtifactsAreAlreadyInstalled": "已安装所有项目",
  "$ArtifactsInstalledSuccessfully": "已成功安装 ${p0} 个项目",
  "InstallationFailedStopping": "安装失败 - 正在停止",
  "MultipleArtifactsSpecifiedButNotAnEqualNumberOf$Switches": "指定了多个项目，但 ${p0} 个切换的数量不相等",
  "TriedToAddAnArtifact$$ButCouldNotDetermineTheRegistryToUse": "尝试添加项目 [${p0}]:${p1} 但无法确定要使用的注册表。",
  "TriedToAddRegistry$As$ButItWasAlready$PleaseAdd$ToThisProjectManuallyAndReattempt": "尝试将注册表 ${p0} 添加为 ${p1}，但它已经是 ${p2}。请手动将 ${p3} 添加到此项目并重新尝试。",
  "RunvcpkgshellActivateToApplyToTheCurrentTerminal": "运行\\`vcpkg-shell activate\\`以应用于当前终端",
  "DownloadsFolderCleared$": "下载文件夹已清除(${p0}) ",
  "InstalledArtifactFolderCleared$": "已安装的项目文件夹已清除(${p0}) ",
  "CacheFolderCleared$": "缓存文件夹已清除(${p0}) ",
  "DeletingArtifact$From$": "正在从 ${p1} 中删除项目 ${p0}",
  "NoArtifactsFoundMatchingCriteria$": "找不到符合条件的项目: ${p0}",
  "UnableToActivateProject": "无法激活项目",
  "RegeneratingIndexFor$": "正在重新生成 ${p0} 的索引",
  "RegenerationCompleteIndexContains$MetadataFiles": "重新生成完成。索引包含 ${p0} 个元数据文件",
  "Registry$ContainsNoArtifacts": "注册表:“${p0}”不包含项目。",
  "error$": "错误 ${p0}: ",
  "Removing$FromProjectManifest": "正在从项目清单中删除 ${p0}",
  "unableToFindArtifact$InTheProjectManifest": "无法在项目清单中找到项目 ${p0}",
  "Updated$ItContains$MetadataFiles": "已更新 ${p0}。它包含 ${p1} 元数据文件。",
  "UnableToDownload$": "无法下载 ${p0}。",
  "$CouldNotBeUpdatedItCouldBeMalformed": "无法更新 ${p0}; 可能格式不正确。",
  "TheXupdateregistryCommandDownloadsNewRegistryInformationAndThusCannotBeUsedWithLocalRegistriesDidYouMeanXregenerate$": "x-update-registry 命令下载新的注册表信息，因此不能与本地注册表一起使用。是否是说 x-regenerate ${p0}?",
  "UnableToFindRegistry$": "无法找到注册表 ${p0}。",
  "NoArtifactsAreBeingAcquired": "未获取到任何项目",
  "UnableToFindProjectEnvironment$": "无法找到项目环境 ${p0}"
}